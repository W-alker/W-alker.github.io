<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="JavaScript，数据结构与算法，集合、字典、哈希表、树、二叉树、二叉搜索树、图,路修远,博客,ayer,学习笔记,前端,萌新" />
   
  <meta name="description" content="路修远个人博客,前端萌新" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    JavaScript数据结构与算法（2） |  路修远
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="路修远" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-JavaScript数据结构与算法（2）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  JavaScript数据结构与算法（2）
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/19/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89/" class="article-date">
  <time datetime="2021-01-19T12:19:01.000Z" itemprop="datePublished">2021-01-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a> / <a class="article-category-link" href="/categories/JavaScript/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a> / <a class="article-category-link" href="/categories/JavaScript/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">26.5k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">109 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>注意：原教学视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1a5411t7vZ">JavaScript(ES6)数据结构和算法</a>  |  <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1r7411n7Pw">JavaScript数据结构与算法</a> (都是CoderWhy老师的教学)</p>
<p>原作者（笔记）链接：<a target="_blank" rel="noopener" href="https://github.com/XPoet/JS-Data-Structures-and-Algorithms">JavaScript 数据结构与算法</a>  |  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/AhuntSun-blog/p/12636718.html">JavaScript数据结构与算法博客目录</a></p>
<p>PS：本文仅在学习过程中，对两篇笔记进行整合及总结（包含少量补充），以作学习之用。侵权立删。</p>
<p>Part2: 集合、字典、哈希表、树、二叉树、二叉搜索树（红黑树这里不作整合，因为我也还没看懂）、图。</p>
</blockquote>
<a id="more"></a>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><hr>

<p>几乎每种编程语言中，都有集合结构。集合比较常见的实现方式是哈希表，这里使用 JavaScript 的 Object 进行封装。</p>
<h3 id="集合特点"><a href="#集合特点" class="headerlink" title="集合特点"></a>集合特点</h3><ul>
<li>集合通常是由一组<strong>无序的</strong>、<strong>不能重复的</strong>元素构成。<ul>
<li>数学中常指的集合中的元素是可以重复的，但是计算机中集合的元素不能重复。</li>
</ul>
</li>
<li>集合是特殊的数组：<ul>
<li>特殊之处在于里面的元素<strong>没有顺序</strong>，<strong>也不能重复</strong>。</li>
<li>没有顺序意味着<strong>不能通过下标值进行访问</strong>，不能重复意味着<strong>相同的对象</strong>在集合中<strong>只会存在一份</strong>。</li>
</ul>
</li>
</ul>
<h3 id="集合常见的操作"><a href="#集合常见的操作" class="headerlink" title="集合常见的操作"></a>集合常见的操作</h3><ul>
<li><code>add(value)</code>：向集合添加一个新的项；</li>
<li><code>remove(value)</code>：从集合中移除一个值；</li>
<li><code>has(value)</code>：如果值在集合中，返回<code>true</code>，否则返回<code>false</code>；</li>
<li><code>clear()</code>：移除集合中的所有项；</li>
<li><code>size()</code>：返回集合所包含元素的数量，与数组的<code>length</code>属性相似；</li>
<li><code>values()</code>：返回一个包含集合中所有值的数组；</li>
</ul>
<ul>
<li>还有其他的方法，用的不多这里不做封装。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>实现集合类</strong></p>
<ul>
<li>在ES6中的<strong>Set</strong>类就是一个集合类，这里我们重新封装一个Set类，了解集合的底层实现。</li>
<li>JavaScript中的<strong>Object</strong>类中的<strong>key</strong>就是一个集合，可以使用它来封装集合类Set。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装集合类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//属性</span></span><br><span class="line">  <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法</span></span><br><span class="line">  <span class="comment">//一.has方法</span></span><br><span class="line">  <span class="built_in">Set</span>.prototype.has = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.hasOwnProperty(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//二.add方法</span></span><br><span class="line">  <span class="built_in">Set</span>.prototype.add = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//判断集合中是否已经包含该元素</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.has(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将元素添加到集合中</span></span><br><span class="line">    <span class="built_in">this</span>.items[value] = value;<span class="comment">//表示该属性键和值都为value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//表示添加成功</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//三.remove方法</span></span><br><span class="line">  <span class="built_in">Set</span>.prototype.remove = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//1.判断集合中是否包含该元素</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.has(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.将元素从属性中删除</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.items[value];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//四.clear方法</span></span><br><span class="line">  <span class="built_in">Set</span>.prototype.clear = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//原来的对象没有引用指向，会被自动回收</span></span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//五.size方法</span></span><br><span class="line">  <span class="built_in">Set</span>.prototype.size = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items).length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取集合中所有的值</span></span><br><span class="line">  <span class="comment">//六.values方法</span></span><br><span class="line">  <span class="built_in">Set</span>.prototype.values = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码测试</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试集合类</span></span><br><span class="line"><span class="comment">//1.创建Set类对象</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="comment">//2.测试add方法</span></span><br><span class="line"><span class="built_in">console</span>.log(set.add(<span class="string">&#x27;a&#x27;</span>));										<span class="comment">//67</span></span><br><span class="line"><span class="built_in">console</span>.log(set.add(<span class="string">&#x27;a&#x27;</span>));										<span class="comment">//68</span></span><br><span class="line"><span class="built_in">console</span>.log(set.add(<span class="string">&#x27;b&#x27;</span>));										<span class="comment">//69</span></span><br><span class="line"><span class="built_in">console</span>.log(set.add(<span class="string">&#x27;c&#x27;</span>));										<span class="comment">//70</span></span><br><span class="line"><span class="built_in">console</span>.log(set.add(<span class="string">&#x27;d&#x27;</span>));										<span class="comment">//71</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试values方法</span></span><br><span class="line"><span class="built_in">console</span>.log(set.values());										<span class="comment">//74</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="comment">//4.测试remove方法</span></span><br><span class="line"><span class="built_in">console</span>.log(set.remove(<span class="string">&#x27;a&#x27;</span>));									<span class="comment">//78</span></span><br><span class="line"><span class="built_in">console</span>.log(set.remove(<span class="string">&#x27;a&#x27;</span>));									<span class="comment">//79</span></span><br><span class="line"><span class="built_in">console</span>.log(set.values());										<span class="comment">//80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.测试has方法</span></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="string">&#x27;b&#x27;</span>));										<span class="comment">//83</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.测试size方法和clear方法</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size());										<span class="comment">//86</span></span><br><span class="line">set.clear();</span><br><span class="line"><span class="comment">// 由于clear方法的实现原理为指向另外一个空对象，所以不影响原来的对象</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size());										<span class="comment">//89</span></span><br><span class="line"><span class="built_in">console</span>.log(set.values());										<span class="comment">//90</span></span><br></pre></td></tr></table></figure>
<p><strong>测试结果</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9B%86%E5%90%88%E5%92%8C%E5%AD%97%E5%85%B8/1.png"></p>
<h3 id="集合间的操作"><a href="#集合间的操作" class="headerlink" title="集合间的操作"></a>集合间的操作</h3><p><strong>集合间操作：</strong></p>
<ul>
<li><strong>并集</strong>：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合；</li>
<li><strong>交集</strong>：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合；</li>
<li><strong>差集</strong>：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合；</li>
<li><strong>子集</strong>：验证一个给定集合是否是另一个集合的子集；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9B%86%E5%90%88%E5%92%8C%E5%AD%97%E5%85%B8/2.png" alt="image-20200228210239984"></p>
<h4 id="并集的实现："><a href="#并集的实现：" class="headerlink" title="并集的实现："></a>并集的实现：</h4><p>实现思路：创建集合C代表集合A和集合B的并集，先将集合<code>A</code>中的所有元素添加到集合<code>C</code>中，再遍历集合<code>B</code>，如果是集合<code>C</code>所没有的元素就把它添加到集合<code>C</code>中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.union = <span class="function">(<span class="params">otherSet</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// this:集合对象A</span></span><br><span class="line">     <span class="comment">// otherSet:集合对象B</span></span><br><span class="line">     <span class="comment">//1.创建一个新的集合</span></span><br><span class="line">     <span class="keyword">let</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//2.将A集合中的所有元素添加到新集合中</span></span><br><span class="line">     <span class="keyword">let</span> values = <span class="built_in">this</span>.values();</span><br><span class="line">     <span class="comment">// for(let i of values)&#123;</span></span><br><span class="line">     <span class="comment">//   unionSet.add(i)</span></span><br><span class="line">     <span class="comment">// &#125;</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; values.length;i++)&#123;</span><br><span class="line">       unionSet.add(values[i]);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//3.取出B集合中的元素,判断是否需要加到新集合中</span></span><br><span class="line">     values = otherSet.values();</span><br><span class="line">     <span class="comment">// for(let i of values)&#123;</span></span><br><span class="line">     <span class="comment">//   //由于集合的add方法已经对重复的元素进行了判断,所以这里可以直接添加</span></span><br><span class="line">     <span class="comment">//   unionSet.add(i)</span></span><br><span class="line">     <span class="comment">// &#125;</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; values.length;i++)&#123;</span><br><span class="line">       unionSet.add(values[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> unionSet;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="交集的实现："><a href="#交集的实现：" class="headerlink" title="交集的实现："></a>交集的实现：</h4><p>实现思路：遍历集合A，当取得的元素也存在于集合B时，就把该元素添加到另一个集合C中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.intersection = <span class="function">(<span class="params">otherSet</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// this:集合A</span></span><br><span class="line">     <span class="comment">// otherSet:集合B</span></span><br><span class="line">     <span class="comment">//1.创建新的集合</span></span><br><span class="line">     <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//2.从A中取出一个元素，判断是否同时存在于集合B中，是则放入新集合中</span></span><br><span class="line">     <span class="keyword">let</span> values = <span class="built_in">this</span>.values();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span> ; i &lt; values.length; i++)&#123;</span><br><span class="line">       <span class="keyword">let</span> item = values[i];</span><br><span class="line">       <span class="keyword">if</span> (otherSet.has(item)) &#123;</span><br><span class="line">         intersectionSet.add(item);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> intersectionSet;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="差集的实现："><a href="#差集的实现：" class="headerlink" title="差集的实现："></a>差集的实现：</h4><p>实现思路：遍历集合A，当取得的元素不存在于集合B时，就把该元素添加到另一个集合C中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.diffrence = <span class="function">(<span class="params">otherSet</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//this:集合A</span></span><br><span class="line">        <span class="comment">//otherSet:集合B</span></span><br><span class="line">        <span class="comment">//1.创建新的集合</span></span><br><span class="line">        <span class="keyword">var</span> diffrenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.取出A集合中的每一个元素，判断是否同时存在于B中，不存在则添加到新集合中</span></span><br><span class="line">        <span class="keyword">var</span> values = <span class="built_in">this</span>.values();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; values.length; i++)&#123;</span><br><span class="line">          <span class="keyword">var</span> item = values[i];</span><br><span class="line">          <span class="keyword">if</span> (!otherSet.has(item)) &#123;</span><br><span class="line">            diffrenceSet.add(item);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diffrenceSet;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="子集的实现："><a href="#子集的实现：" class="headerlink" title="子集的实现："></a>子集的实现：</h4><p>实现思路：遍历集合A，当取得的元素中有一个不存在于集合B时，就说明集合A不是集合B的子集，返回false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.subset = <span class="function">(<span class="params">otherSet</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">//this:集合A</span></span><br><span class="line">       <span class="comment">//otherSet：集合B</span></span><br><span class="line">       <span class="comment">//遍历集合A中的所有元素，如果发现，集合A中的元素，在集合B中不存在，那么放回false，如果遍历完整个集合A没有返回false，就返回true</span></span><br><span class="line">       <span class="keyword">let</span> values = <span class="built_in">this</span>.values();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++)&#123;</span><br><span class="line">         <span class="keyword">let</span> item = values[i];</span><br><span class="line">         <span class="keyword">if</span>(!otherSet.has(item))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>


<h3 id="使用Class的完整实现"><a href="#使用Class的完整实现" class="headerlink" title="使用Class的完整实现"></a>使用Class的完整实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合结构的封装</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// has(value) 判断集合中是否存在 value 值，存在返回 true，否则返回 false</span></span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.hasOwnProperty(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add(value) 往集合中添加 value</span></span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.has(value)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.items[value] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove(value) 删除集合中指定的 value</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果集合不存在该 value，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.has(value)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.items[value];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// clear() 清空集合中所有 value</span></span><br><span class="line">  <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// size() 获取集合中的 value 个数</span></span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items).length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// values() 获取集合中所有的 value</span></span><br><span class="line">  <span class="function"><span class="title">values</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ------- 集合间的操作 ------- //</span></span><br><span class="line">  <span class="comment">// union() 求两个集合的并集</span></span><br><span class="line">  <span class="function"><span class="title">union</span>(<span class="params">otherSet</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、创建一个新集合</span></span><br><span class="line">    <span class="keyword">let</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、将当前集合（this）的所有 value，添加到新集合（unionSet）中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="built_in">this</span>.values()) &#123;</span><br><span class="line">      unionSet.add(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、将 otherSet 集合的所有 value，添加到新集合（unionSet）中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> otherSet.values()) &#123;</span><br><span class="line">      unionSet.add(value); <span class="comment">// add() 已经有重复判断</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unionSet;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// intersection() 求两个集合的交集</span></span><br><span class="line">  <span class="function"><span class="title">intersection</span>(<span class="params">otherSet</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建一个新集合</span></span><br><span class="line">    <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="built_in">this</span>.values()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (otherSet.has(value)) &#123;</span><br><span class="line">        intersectionSet.add(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intersectionSet;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// difference() 差集</span></span><br><span class="line">  <span class="function"><span class="title">difference</span>(<span class="params">otherSet</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建一个新集合</span></span><br><span class="line">    <span class="keyword">let</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在，不存在的即为差集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="built_in">this</span>.values()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!otherSet.has(value)) &#123;</span><br><span class="line">        differenceSet.add(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> differenceSet;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// subset() 子集</span></span><br><span class="line">  <span class="function"><span class="title">subset</span>(<span class="params">otherSet</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在，有不存在的返回 false</span></span><br><span class="line">    <span class="comment">// 遍历完所有的，返回 true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="built_in">this</span>.values()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!otherSet.has(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><hr>

<blockquote>
<p>一般会用哈希表实现，这里只作简单讲解。</p>
</blockquote>
<h3 id="字典特点"><a href="#字典特点" class="headerlink" title="字典特点"></a>字典特点</h3><ul>
<li>字典存储的是<strong>键值对</strong>，主要特点是<strong>一一对应</strong>。</li>
<li>比如保存一个人的信息<ul>
<li>数组形式：<code>[19，‘Tom’，1.65]</code>，可通过下标值取出信息。</li>
<li>字典形式：<code>&#123;&quot;age&quot;：19，&quot;name&quot;：&quot;Tom&quot;，&quot;height&quot;：165&#125;</code>，可以通过 <code>key</code> 取出 <code>value</code>。</li>
</ul>
</li>
<li>此外，在字典中 key 是不能重复且无序的，而 Value 可以重复。</li>
</ul>
<h3 id="字典和映射的关系"><a href="#字典和映射的关系" class="headerlink" title="字典和映射的关系"></a>字典和映射的关系</h3><ul>
<li>有些编程语言中称这种映射关系为<strong>字典</strong>，如 Swift 中的 Dictonary，Python 中的 dict。</li>
<li>有些编程语言中称这种映射关系为 <strong>Map</strong>，比如 Java 中的 HashMap 和 TreeMap 等。</li>
</ul>
<h3 id="字典和对象"><a href="#字典和对象" class="headerlink" title="字典和对象"></a>字典和对象</h3><ul>
<li>很多编程语言（如Java）中对字典和对象区分比较明显，对象通常是一种在编译期就确定下来的结构，不可以动态的添加或者删除属性。而字典通常会使用类似于哈希表和数据结构去实现一种可以动态的添加数据的结构。</li>
<li>但是在JavaScript中，似乎对象本身就是一种字典。所以在早期的Javascript中，没有字典这种数据类型，因为你完全可以使用对象去代替。</li>
</ul>
<h3 id="字典常见的操作"><a href="#字典常见的操作" class="headerlink" title="字典常见的操作"></a>字典常见的操作</h3><ul>
<li><code>set(key,value)</code> 向字典中添加新元素。</li>
<li><code>remove(key)</code> 通过使用键值来从字典中移除键值对应的数据值。</li>
<li><code>has(key)</code> 如果某个键值存在于这个字典中，则返回 <code>true</code>，反之则返回 <code>false</code>。</li>
<li><code>get(key)</code> 通过键值查找特定的数值并返回。</li>
<li><code>clear()</code> 将这个字典中的所有元素全部删除。</li>
<li><code>size()</code> 返回字典所包含元素的数量。与数组的 <code>length</code> 属性类似。</li>
<li><code>keys()</code> 将字典所包含的所有键名以数组形式返回。</li>
<li><code>values()</code> 将字典所包含的所有数值以数组形式返回。</li>
</ul>
<h3 id="字典封装"><a href="#字典封装" class="headerlink" title="字典封装"></a>字典封装</h3><p><strong>代码实现</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装字典类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dictionary</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//字典属性</span></span><br><span class="line">  <span class="built_in">this</span>.items = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//字典操作方法</span></span><br><span class="line">  <span class="comment">//一.在字典中添加键值对</span></span><br><span class="line">  Dictionary.prototype.set = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.items[key] = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//二.判断字典中是否有某个key</span></span><br><span class="line">  Dictionary.prototype.has = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.hasOwnProperty(key)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//三.从字典中移除元素</span></span><br><span class="line">  Dictionary.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1.判断字典中是否有这个key</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.has(key)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.从字典中删除key</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.items[key]</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//四.根据key获取value</span></span><br><span class="line">  Dictionary.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.has(key) ? <span class="built_in">this</span>.items[key] : <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//五.获取所有keys</span></span><br><span class="line">  Dictionary.prototype.keys = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//六.size方法</span></span><br><span class="line">  Dictionary.prototype.keys = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.keys().length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//七.clear方法</span></span><br><span class="line">  Dictionary.prototype.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用class实现*/</span></span><br><span class="line"><span class="comment">// 字典结构的封装</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Map</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// has(key) 判断字典中是否存在某个 key</span></span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.hasOwnProperty(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set(key, value) 在字典中添加键值对</span></span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove(key) 在字典中删除指定的 key</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果集合不存在该 key，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.has(key)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.items[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get(key) 获取指定 key 的 value，如果没有，返回 undefined</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.has(key) ? <span class="built_in">this</span>.items[key] : <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取所有的 key</span></span><br><span class="line">  <span class="function"><span class="title">keys</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取所有的 value</span></span><br><span class="line">  <span class="function"><span class="title">values</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.values(<span class="built_in">this</span>.items);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// size() 获取字典中的键值对个数</span></span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.keys().length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// clear() 清空字典中所有的键值对</span></span><br><span class="line">  <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码测试</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// set() 测试</span></span><br><span class="line">map.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;XPoet&quot;</span>);</span><br><span class="line">map.set(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line">map.set(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;i@xpoet.cn&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// &#123;items: &#123;name: &quot;XPoet&quot;, age: 18, email: &quot;i@xpoet.cn&quot;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// has() 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">&quot;name&quot;</span>)); <span class="comment">//--&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">&quot;address&quot;</span>)); <span class="comment">//--&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// remove() 测试</span></span><br><span class="line">map.remove(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// &#123;age: 18, email: &quot;i@xpoet.cn&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get() 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">&quot;age&quot;</span>)); <span class="comment">//--&gt; 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// keys() 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(map.keys()); <span class="comment">//--&gt; [&quot;age&quot;, &quot;email&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// values() 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(map.values()); <span class="comment">//--&gt; [18, &quot;i@xpoet.cn&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// size() 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size()); <span class="comment">//--&gt; 2</span></span><br></pre></td></tr></table></figure>
<br>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><hr>

<h3 id="认识哈希表"><a href="#认识哈希表" class="headerlink" title="认识哈希表"></a>认识哈希表</h3><p>哈希表是一种非常重要的数据结构，几乎所有的编程语言都直接或者间接应用这种数据结构。</p>
<p>哈希表通常是<strong>基于数组</strong>实现的，但是相对于数组，它存在更多<strong>优势</strong>：</p>
<ul>
<li>哈希表可以提供非常快速的<strong>插入-删除-查找</strong>操作。</li>
<li>无论多少数据，插入和删除值都只需接近常量的时间，即 <strong>O(1)</strong> 的时间复杂度。实际上，只需要几个机器指令即可完成。</li>
<li>哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。</li>
<li>哈希表相对于树来说编码要简单得多。</li>
</ul>
<p>哈希表同样存在<strong>不足之处</strong>：</p>
<ul>
<li>哈希表中的数据是<strong>没有顺序</strong>的，所以不能以一种固定的方式（比如从小到大 ）来遍历其中的元素。</li>
<li>通常情况下，哈希表中的 key 是<strong>不允许重复</strong>的，不能放置相同的 key，用于保存不同的元素。</li>
</ul>
<p><strong>哈希表是什么？</strong></p>
<ul>
<li>哈希表并不好理解，不像数组、链表和树等可通过图形的形式表示其结构和原理。</li>
<li>哈希表的结构就是数组，但它<strong>神奇之处在于对下标值的一种变换</strong>，这种变换我们可以称之为<strong>哈希函数</strong>，通过哈希函数可以获取 <strong>HashCode</strong>。</li>
</ul>
<p>通过以下案例了解哈希表：</p>
<ul>
<li>案例一：公司想要存储 1000 个人的信息，每一个工号对应一个员工的信息。若使用数组，增删数据时比较麻烦；使用链表，获取数据时比较麻烦。有没有一种数据结构，能把某一员工的姓名转换为它对应的工号，再根据工号查找该员工的完整信息呢？没错此时就可以使用哈希表的哈希函数来实现。</li>
<li>案例二：存储联系人和对应的电话号码：当要查找张三（比如）的号码时，若使用数组：由于不知道存储张三数据对象的下标值，所以查找起来十分麻烦，使用链表时也同样麻烦。而使用哈希表就能通过哈希函数把张三这个名称转换为它对应的下标值，再通过下标值查找效率就非常高了。</li>
</ul>
<p>也就是说：哈希表最后还是基于数据来实现的，只不过哈希表能够通过哈希函数把字符串转化为对应的<strong>下标值</strong>，建立字符串和下标值的映射关系。</p>
<h3 id="认识哈希化"><a href="#认识哈希化" class="headerlink" title="认识哈希化"></a>认识哈希化</h3><p>为了把字符串转化为对应的下标值，需要有一套编码系统，为了方便理解我们创建这样一套编码系统：比如 a 为 1，b 为 2，c 为 3，以此类推 z 为 26，空格为 27（不考虑大写情况）。</p>
<p>有了编码系统后，将字母转化为数字也有很多种方案：</p>
<ul>
<li>方案一：数字相加。</li>
</ul>
<p>例如 cats 转化为数字：<code>3 + 1 + 20 + 19 = 43</code>，那么就把 43 作为 cats 单词的下标值储存在数组中；</p>
<p>但是这种方式会存在这样的问题：很多的单词按照该方式转化为数字后都是 43，比如 was。而在数组中一个下标值只能储存一个数据，所以该方式不合理。</p>
<ul>
<li>方案二：幂的连乘。</li>
</ul>
<p>我们平时使用的大于 10 的数字，就是用幂的连乘来表示它的唯一性的。 比如： <code>6543 = 6 * 10^3 + 5 * 10^2 + 4 * 10 + 3</code>；这样单词也可以用该种方式来表示：<code>cats = 3 * 27^3 + 1 * 27^2 + 20 * 27 + 17 = 60337</code>。</p>
<p>虽然该方式可以保证字符的唯一性，但是如果是较长的字符（如 aaaaaaaaaa）所表示的数字就非常大，此时要求很大容量的数组，然而其中却有许多下标值指向的是无效的数据（比如不存在 zxcvvv 这样的单词），造成了数组空间的浪费。</p>
<p>两种方案总结：</p>
<ul>
<li>第一种方案（让数字相加求和）产生的数组下标太少。</li>
<li>第二种方案（与 27 的幂相乘求和）产生的数组下标又太多。</li>
</ul>
<p>现在需要一种压缩方法，把幂的连乘方案系统中得到的<strong>巨大整数范围压缩到可接受的数组范围中</strong>。可以通过<strong>取余</strong>操作来实现。虽然取余操作得到的结构也有可能重复，但是可以通过其他方式解决。</p>
<p>现在需要一种<strong>压缩方法</strong>，把幂的连乘方案系统中得到的<strong>巨大整数范围</strong>压缩到<strong>可接受的数组范围</strong>中。可以通过取余操作来实现。虽然取余操作得到的结构也有可能重复，但是可以通过其他方式解决。</p>
<h3 id="哈希表的一些概念"><a href="#哈希表的一些概念" class="headerlink" title="哈希表的一些概念"></a>哈希表的一些概念</h3><ul>
<li><strong>哈希化：</strong>将<strong>大数字</strong>转化成<strong>数组范围内下标</strong>的过程，称之为<strong>哈希化</strong>；</li>
<li><strong>哈希函数：</strong>我们通常会将<strong>单词</strong>转化成<strong>大数字</strong>，把<strong>大数字</strong>进行<strong>哈希化</strong>的代码实现放在一个函数中，该函数就称为<strong>哈希函数</strong>；</li>
<li><strong>哈希表：</strong>对最终将数据插入的<strong>数组</strong>进行整个<strong>结构的封装</strong>，得到的就是<strong>哈希表</strong>。</li>
</ul>
<h3 id="地址的冲突"><a href="#地址的冲突" class="headerlink" title="地址的冲突"></a>地址的冲突</h3><p>在实际中，经过哈希函数哈希化过后得到的下标值可能<strong>有重复</strong>，这种情况称为<strong>冲突</strong>，冲突是不可避免的，我们只能解决冲突。</p>
<p>解决冲突常见的两种方案：<strong>链地址法</strong>（拉链法）和<strong>开放地址法</strong>。</p>
<h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>如下图所示，我们将每一个数字都对<strong>10</strong>进行取余操作，则余数的范围<strong>0~9</strong>作为数组的下标值。并且，数组每一个下标值对应的位置存储的不再是一个数字了，而是存储由经过取余操作后得到相同余数的数字组成的<strong>数组</strong>或<strong>链表</strong>。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/1.png"></p>
<p>这样可以根据下标值获取到整个数组或链表，之后继续在数组或链表中查找就可以了。而且，产生冲突的元素一般不会太多。</p>
<p><strong>总结：</strong>链地址法解决冲突的办法是<strong>每个数组单元</strong>中存储的不再是<strong>单个数据</strong>，而是一条<strong>链条</strong>，这条链条常使用的数据结构为<strong>数组或链表</strong>，两种数据结构查找的效率相当（因为链条的元素一般不会太多）。</p>
<h4 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h4><p>开放地址法的主要工作方式是<strong>寻找空白的单元格</strong>来放置<strong>冲突</strong>的数据项。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/2.png"></p>
<p>根据探测空白单元格位置方式的不同，可分为三种方法：</p>
<ul>
<li><strong>线性探测</strong></li>
<li><strong>二次探测</strong></li>
<li><strong>再哈希法</strong></li>
</ul>
<h5 id="寻找空白单元格的方式"><a href="#寻找空白单元格的方式" class="headerlink" title="寻找空白单元格的方式"></a>寻找空白单元格的方式</h5><h6 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h6><p>线性探测很好理解：<strong>线性地查找空白的单元</strong>。</p>
<p><strong>当插入13时</strong>：</p>
<ul>
<li>经过哈希化（对10取余）之后得到的下标值index=3，但是该位置已经放置了数据33。而线性探测就是从<strong>index位置+1</strong>开始向后一个一个来查找<strong>合适的位置</strong>来放置13，所谓合适的位置指的是<strong>空的位置</strong>，如上图中index=4的位置就是合适的位置。</li>
</ul>
<p><strong>当查询13时</strong>：</p>
<ul>
<li>首先13经过哈希化得到index=3，如果index=3的位置存放的数据与需要查询的数据13相同，就直接返回；</li>
<li>不相同时，则线性查找，从<strong>index+1</strong>位置开始一个一个位置地查找数据13；</li>
<li>查询过程中不会遍历整个哈希表，只要查询到<strong>空位置，就停止</strong>，因为插入13时不会跳过空位置去插入其他位置。</li>
</ul>
<p><strong>当删除13时</strong>：</p>
<ul>
<li>删除操作和上述两种情况类似，但需要注意的是，删除一个数据项时，<strong>不能</strong>将该位置下标的内容<strong>设置为null</strong>，否则会<strong>影响到之后其他的查询操作</strong>，因为一遇到为null的位置就会停止查找。</li>
<li>通常<strong>删除一个位置的数据项</strong>时，我们可以<strong>将它进行特殊处理</strong>（比如设置为-1），这样在查找时遇到-1就知道要<strong>继续查找</strong>。</li>
</ul>
<p><strong>线性探测存在的问题</strong>：</p>
<ul>
<li>线性探测存在一个比较严重的问题，就是<strong>聚集</strong>；</li>
<li>如哈希表中还没插入任何元素时，插入23、24、25、26、27，这就意味着下标值为3、4、5、6、7的位置都放置了数据，这种<strong>一连串填充单元</strong>就称为<strong>聚集</strong>；</li>
<li>聚集会影响哈希表的<strong>性能</strong>，无论是插入/查询/删除都会影响；</li>
<li>比如插入13时就会发现，连续的单元3~7都不允许插入数据，并且在插入的过程中需要经历多次这种情况。二次探测法可以解决该问题。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/3.png"></p>
<h6 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h6><p>上文所说的<strong>线性探测存在的问题</strong>：</p>
<ul>
<li><p>如果之前的数据是<strong>连续插入</strong>的，那么新插入的一个数据可能需要<strong>探测很长的距离</strong>；</p>
<p>二次探测是在线性探测的基础上进行了<strong>优化</strong>：</p>
</li>
<li><p><strong>线性探测</strong>：我们可以看成是<strong>步长为1</strong>的探测，比如从下表值x开始，那么线性探测就是按照下标值：x+1、x+2、x+3等依次探测；</p>
</li>
<li><p><strong>二次探测</strong>：对步长进行了优化，比如从下标值x开始探测：x+1<sup>2</sup>、x+2<sup>2</sup>、x+3<sup>2</sup>。这样<strong>一次性探测比较长的距离</strong>，避免了数据聚集带来的影响。</p>
</li>
</ul>
<p><strong>二次探测存在的问题</strong>：</p>
<ul>
<li>当插入数据分布性较大的一组数据时，比如：13-163-63-3-213，这种情况会造成<strong>步长不一的一种聚集</strong>（虽然这种情况出现的概率较线性探测的聚集要小），同样会影响性能。</li>
</ul>
<h6 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h6><p>在开放地址法中寻找空白单元格的最好的解决方式为<strong>再哈希化</strong>：</p>
<ul>
<li>二次探测的步长是固定的：1，4，9，16依次类推；</li>
<li>现在需要一种方法：产生一种<strong>依赖关键字(数据)的探测序列</strong>，而不是每个关键字探测步长都一样；</li>
<li>这样，<strong>不同的关键字</strong>即使映射到<strong>相同的数组下标</strong>，也可以使用<strong>不同的探测序列</strong>；</li>
<li>再哈希法的做法为：把关键字用<strong>另一个</strong>哈希函数，<strong>再做一次哈希化</strong>，用这次哈希化的<strong>结果作为该关键字的步长</strong>；</li>
</ul>
<p>第二次哈希化需要满足以下两点：</p>
<ul>
<li>和<strong>第一个哈希函数不同</strong>，不然哈希化后的结果仍是原来位置；</li>
<li><strong>不能输出为0</strong>，否则每次探测都是原地踏步的死循环；</li>
</ul>
<p><strong>优秀的哈希函数</strong>：</p>
<ul>
<li><strong>stepSize = constant - （key % constant）</strong>；</li>
<li>其中constant是<strong>质数</strong>，且小于数组的容量；</li>
<li>例如：stepSize = 5 - （key % 5），满足需求，并且结果不可能为0；</li>
</ul>
<p><strong>哈希化的效率</strong></p>
<p>哈希表中执行插入和搜索操作效率是非常高的。</p>
<ul>
<li>如果没有<strong>发生冲突</strong>，那么效率就会更高；</li>
<li>如果<strong>发生冲突</strong>，存取时间就依赖后来的探测长度；</li>
<li>平均探测长度以及平均存取时间，取决于<strong>填装因子</strong>，随着填装因子变大，探测长度会越来越长。</li>
</ul>
<p>理解概念<strong>装填因子</strong>：</p>
<ul>
<li>装填因子表示当前哈希表中已经<strong>包含的数据项</strong>和<strong>整个哈希表长度</strong>的<strong>比值</strong>；</li>
<li><strong>装填因子 = 总数据项 / 哈希表长度</strong>；</li>
<li><strong>开放地址法的装填因子</strong>最大为<strong>1</strong>，因为只有空白的单元才能放入元素；</li>
<li><strong>链地址法的装填因子</strong>可以<strong>大于1</strong>，因为只要愿意，拉链法可以无限延伸下去；</li>
</ul>
<h6 id="不同探测方式性能的比较"><a href="#不同探测方式性能的比较" class="headerlink" title="不同探测方式性能的比较"></a>不同探测方式性能的比较</h6><blockquote>
<p>推算来自于Knuth（算法分析领域的专家，现代计算机的先驱人物）。这里不再给出推导过程和公式，仅根据公式模型说明它的效率。</p>
</blockquote>
<ul>
<li><strong>线性探测：</strong></li>
</ul>
<p>可以看到，随着装填因子的增大，平均探测长度呈指数形式增长，性能较差。实际情况中，最好的装填因子取决于存储效率和速度之间的平衡，随着装填因子变小，存储效率下降，而速度上升。</p>
<img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/4.png" style="zoom:80%;">



<ul>
<li><strong>二次探测和再哈希化的性能</strong>：</li>
</ul>
<p>二次探测和再哈希法性能相当，它们的性能比线性探测略好。由下图可知，随着装填因子的变大，平均探测长度呈指数形式增长，需要探测的次数也呈指数形式增长，性能不高。</p>
<img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/5.png" style="zoom:80%;">



<ul>
<li><strong>链地址法的性能：</strong></li>
</ul>
<p>可以看到随着装填因子的增加，平均探测长度呈线性增长，较为平缓。在开发中使用链地址法较多，比如Java中的HashMap中使用的就是<strong>链地址法</strong>。</p>
<img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/6.png" style="zoom:80%;">

<br>

<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>哈希表的优势在于它的速度，所以哈希函数不能采用消耗性能较高的复杂算法。提高速度的一个方法是在哈希函数中<strong>尽量减少乘法和除法</strong>。</p>
<p>性能高的哈希函数应具备以下两个优点：</p>
<ul>
<li><strong>快速的计算</strong>；</li>
<li><strong>均匀的分布</strong>。</li>
</ul>
<h4 id="快速计算"><a href="#快速计算" class="headerlink" title="快速计算"></a>快速计算</h4><p><strong>霍纳法则</strong>：在中国霍纳法则也叫做<strong>秦九韶算法</strong>，具体算法为：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/7.png"></p>
<p>求多项式的值时，首先计算最内层括号内一次多项式的值，然后由内向外逐层计算一次多项式的值。这种算法把求 n 次多项式 f(x)的值就转化为求 n 个一次多项式的值。</p>
<p>例如我们在前面计算哈希值时候使用的方式：</p>
<ul>
<li>cats = 3 * 27^3 + 1 * 27^2 + 20 * 27 + 17 = 60037</li>
</ul>
<p>将这个表达式抽象成一个多项式，则此时问题就变成了该多项式的乘法和加法的次数：</p>
<ul>
<li>变换之前：<ul>
<li>乘法次数：n(n+1)/2 次；</li>
<li>加法次数：n 次；</li>
</ul>
</li>
<li>变换之后：<ul>
<li>乘法次数：n 次；</li>
<li>加法次数：n 次；</li>
</ul>
</li>
</ul>
<p>如果使用大 O 表示时间复杂度的话，直接从变换前的 O(N^2)降到了 O(N)。</p>
<h4 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h4><p>在设计哈希表时，我们已经有办法处理映射到相同下标值的情况：链地址法或者开放地址法。</p>
<p>但是，为了提供效率，最好的情况还是让数据在哈希表中<strong>均匀分布</strong>。因此，我们需要在<strong>使用常量</strong>的地方，尽量使用<strong>质数</strong>。比如：哈希表的长度、N 次幂的底数等。（至于为什么最好取质数，数学问题这里不作原因讲解，可以自行了解）</p>
<p>Java 中的 HashMap 采用的是链地址法，哈希化采用的是公式为：index = HashCode(key) &amp; (Length-1)</p>
<p> 即将数据化为二进制进行<strong>与</strong>运算，而不是取余运算。这样计算机直接运算二进制数据，效率更高。但是 JavaScript 在进行较大数据的与运算时会出现问题，所以我们使用 JavaScript 实现哈希化时采用取余运算。</p>
<br>

<h3 id="封装哈希表"><a href="#封装哈希表" class="headerlink" title="封装哈希表"></a>封装哈希表</h3><h4 id="哈希表常见操作"><a href="#哈希表常见操作" class="headerlink" title="哈希表常见操作"></a>哈希表常见操作</h4><ul>
<li><code>put(key, value)</code> 插入或修改操作。</li>
<li><code>get(key)</code> 获取哈希表中特定位置的元素。</li>
<li><code>remove(key)</code> 删除哈希表中特定位置的元素。</li>
<li><code>isEmpty()</code> 如果哈希表中不包含任何元素，返回 trun，如果哈希表长度大于 0 则返回 false。</li>
<li><code>size()</code> 返回哈希表包含的元素个数。</li>
<li><code>resize(value)</code> 对哈希表进行扩容操作。</li>
</ul>
<h4 id="哈希函数的简单实现"><a href="#哈希函数的简单实现" class="headerlink" title="哈希函数的简单实现"></a>哈希函数的简单实现</h4><p>首先使用霍纳法则计算 hashCode 的值，通过取余操作实现哈希化，此处先简单地指定数组的大小。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashFunc</span>(<span class="params">string, size = <span class="number">7</span></span>) </span>&#123;   <span class="comment">//参数二为长度，默认为7</span></span><br><span class="line">  <span class="comment">// 自己采用的一个质数（无强制要求，质数即可），这里采用常用的37</span></span><br><span class="line">  <span class="keyword">const</span> PRIME = <span class="number">37</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1、定义存储 hashCode 的变量</span></span><br><span class="line">  <span class="keyword">let</span> hashCode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2、使用霍纳法则（秦九韶算法），计算 hashCode 的值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; string.length; i++) &#123;</span><br><span class="line">    hashCode = PRIME * hashCode + <span class="built_in">String</span>.charCodeAt(i);</span><br><span class="line">      <span class="comment">//charCodeAt():返回字符串指定位置字符的Unicode编码</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3、对 hashCode 取余，并返回</span></span><br><span class="line">  <span class="keyword">return</span> hashCode % size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>哈希函数测试</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(hashFunc(<span class="string">&quot;123&quot;</span>)); <span class="comment">//--&gt; 4</span></span><br><span class="line"><span class="built_in">console</span>.log(hashFunc(<span class="string">&quot;nba&quot;</span>)); <span class="comment">//--&gt; 5</span></span><br><span class="line"><span class="built_in">console</span>.log(hashFunc(<span class="string">&quot;abcd&quot;</span>)); <span class="comment">//--&gt; 3</span></span><br></pre></td></tr></table></figure>
<h4 id="哈希表的实现"><a href="#哈希表的实现" class="headerlink" title="哈希表的实现"></a>哈希表的实现</h4><blockquote>
<p>这里只放出使用function实现的代码，使用class实现见后面完整代码。</p>
</blockquote>
<h5 id="0-创建哈希表类"><a href="#0-创建哈希表类" class="headerlink" title="0. 创建哈希表类"></a>0. 创建哈希表类</h5><p>这里使用链地址法实现哈希表。</p>
<p>封装哈希表的数组结构模型:</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/9.png"></p>
<p>首先创建哈希表类HashTable，并添加必要的属性和上面实现的哈希函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装哈希表类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//属性</span></span><br><span class="line">  <span class="built_in">this</span>.storage = [];</span><br><span class="line">  <span class="built_in">this</span>.count = <span class="number">0</span>;<span class="comment">//计算已经存储的元素个数</span></span><br><span class="line">  <span class="comment">//装填因子：loadFactor &gt; 0.75时需要扩容；loadFactor &lt; 0.25时需要减少容量</span></span><br><span class="line">  <span class="built_in">this</span>.limit = <span class="number">7</span>;<span class="comment">//初始长度</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">//方法</span></span><br><span class="line">  <span class="comment">//哈希函数</span></span><br><span class="line">  HashTable.prototype.hashFunc = <span class="function"><span class="keyword">function</span>(<span class="params">str, size=<span class="number">7</span></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 自己采用的一个质数（无强制要求，质数即可），这里采用常用的37</span></span><br><span class="line">  <span class="keyword">const</span> PRIME = <span class="number">37</span>;</span><br><span class="line">  <span class="comment">// 1、定义存储 hashCode 的变量</span></span><br><span class="line">  <span class="keyword">let</span> hashCode = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 2、使用霍纳法则（秦九韶算法），计算 hashCode 的值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; string.length; i++) &#123;</span><br><span class="line">    hashCode = PRIME * hashCode + <span class="built_in">String</span>.charCodeAt(i);</span><br><span class="line">      <span class="comment">//charCodeAt():返回字符串指定位置字符的Unicode编码</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3、对 hashCode 取余，并返回</span></span><br><span class="line">  <span class="keyword">return</span> hashCode % size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-put-key-value"><a href="#1-put-key-value" class="headerlink" title="1. put(key,value)"></a>1. put(key,value)</h5><p>哈希表的插入和修改操作是同一个函数：因为，当使用者传入一个&lt;key，value&gt;时，如果原来不存在该key，那么就是插入操作，如果原来已经存在该key，那么就是修改操作。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/10.png"></p>
<p><strong>实现思路：</strong></p>
<ul>
<li>首先，根据key获取索引值index，目的为将数据插入到storage的对应位置；</li>
<li>然后，根据索引值取出bucket，如果bucket不存在，先创建bucket，随后放置在该索引值的位置；</li>
<li>接着，判断新增还是修改原来的值。如果已经有值了，就修改该值；如果没有，就执行后续操作。</li>
<li>最后，进行新增数据操作。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入&amp;修改操作</span></span><br><span class="line">HashTable.prototype.put = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.根据key获取对应的index</span></span><br><span class="line">  <span class="keyword">let</span> index = <span class="built_in">this</span>.hashFunc(key, <span class="built_in">this</span>.limit);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.根据index取出对应的bucket</span></span><br><span class="line">  <span class="keyword">let</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.判断该bucket是否为null</span></span><br><span class="line">  <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">    bucket = [];</span><br><span class="line">    <span class="built_in">this</span>.storage[index] = bucket;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4.判断是否是修改数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> tuple = bucket[i];  <span class="comment">//此时tuple为[key,value]的数组</span></span><br><span class="line">    <span class="keyword">if</span> (tuple[<span class="number">0</span>] == key) &#123;</span><br><span class="line">      tuple[<span class="number">1</span>] = value;</span><br><span class="line">      <span class="keyword">return</span><span class="comment">//不用返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//5.进行添加操作</span></span><br><span class="line">  bucket.push([key, value]);</span><br><span class="line">  <span class="built_in">this</span>.count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试哈希表</span></span><br><span class="line"><span class="comment">//1.创建哈希表</span></span><br><span class="line"><span class="keyword">let</span> ht = <span class="keyword">new</span> HashTable();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">ht.put(<span class="string">&#x27;class1&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class2&#x27;</span>,<span class="string">&#x27;Mary&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class3&#x27;</span>,<span class="string">&#x27;Gogo&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class4&#x27;</span>,<span class="string">&#x27;Tony&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class4&#x27;</span>, <span class="string">&#x27;Vibi&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ht);</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/11.png"></p>
<br>

<h5 id="2-get-key"><a href="#2-get-key" class="headerlink" title="2. get(key)"></a>2. get(key)</h5><p><strong>实现思路</strong>：</p>
<ul>
<li>首先，根据key通过哈希函数获取它在storage中对应的索引值index；</li>
<li>然后，根据索引值获取对应的bucket；</li>
<li>接着，判断获取到的bucket是否为null，如果为null，直接返回null；</li>
<li>随后，线性遍历bucket中每一个key是否等于传入的key。如果等于，直接返回对应的value；</li>
<li>最后，遍历完bucket后，仍然没有找到对应的key，直接return null即可。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取操作</span></span><br><span class="line"> HashTable.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//1.根据key获取对应的index</span></span><br><span class="line">   <span class="keyword">let</span> index = <span class="built_in">this</span>.hashFunc(key, <span class="built_in">this</span>.limit);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.根据index获取对应的bucket</span></span><br><span class="line">   <span class="keyword">let</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.判断bucket是否等于null</span></span><br><span class="line">   <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//4.有bucket，那么就进行线性查找</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">     <span class="keyword">let</span> tuple = bucket[i];</span><br><span class="line">     <span class="keyword">if</span> (tuple[<span class="number">0</span>] == key) &#123;<span class="comment">//tuple[0]存储key，tuple[1]存储value</span></span><br><span class="line">       <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//5.依然没有找到，那么返回null</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//测试哈希表</span></span><br><span class="line">   <span class="comment">//1.创建哈希表</span></span><br><span class="line">   <span class="keyword">let</span> ht = <span class="keyword">new</span> HashTable();</span><br><span class="line">   </span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">   ht.put(<span class="string">&#x27;class1&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line">   ht.put(<span class="string">&#x27;class2&#x27;</span>,<span class="string">&#x27;Mary&#x27;</span>)</span><br><span class="line">   ht.put(<span class="string">&#x27;class3&#x27;</span>,<span class="string">&#x27;Gogo&#x27;</span>)</span><br><span class="line">   ht.put(<span class="string">&#x27;class4&#x27;</span>,<span class="string">&#x27;Tony&#x27;</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//3.获取数据</span></span><br><span class="line">   <span class="built_in">console</span>.log(ht.get(<span class="string">&#x27;class3&#x27;</span>));</span><br><span class="line">   <span class="built_in">console</span>.log(ht.get(<span class="string">&#x27;class2&#x27;</span>));</span><br><span class="line">   <span class="built_in">console</span>.log(ht.get(<span class="string">&#x27;class1&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/12.png"></p>
<br>

<h5 id="3-remove-key"><a href="#3-remove-key" class="headerlink" title="3. remove(key)"></a>3. remove(key)</h5><p><strong>实现思路</strong>：</p>
<ul>
<li>首先，根据key通过哈希函数获取它在storage中对应的索引值index；</li>
<li>然后，根据索引值获取对应的bucket；</li>
<li>接着，判断获取到的bucket是否为null，如果为null，直接返回null；</li>
<li>随后，线性查找bucket，寻找对应的数据，并且删除；</li>
<li>最后，依然没有找到，返回null；</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"> HashTable.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//1.根据key获取对应的index</span></span><br><span class="line">   <span class="keyword">let</span> index = <span class="built_in">this</span>.hashFunc(key, <span class="built_in">this</span>.limit);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.根据index获取对应的bucket</span></span><br><span class="line">   <span class="keyword">let</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.判断bucket是否为null</span></span><br><span class="line">   <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//4.有bucket,那么就进行线性查找并删除</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">     <span class="keyword">let</span> tuple = bucket[i];</span><br><span class="line">     <span class="keyword">if</span> (tuple[<span class="number">0</span>] == key) &#123;</span><br><span class="line">       bucket.splice(i,<span class="number">1</span>);  <span class="comment">//splice()会改变原数组</span></span><br><span class="line">       <span class="built_in">this</span>.count -= <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//5.依然没有找到，返回null</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//测试哈希表</span></span><br><span class="line">   <span class="comment">//1.创建哈希表</span></span><br><span class="line">   <span class="keyword">let</span> ht = <span class="keyword">new</span> HashTable();</span><br><span class="line">   </span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">   ht.put(<span class="string">&#x27;class1&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line">   ht.put(<span class="string">&#x27;class2&#x27;</span>,<span class="string">&#x27;Mary&#x27;</span>);</span><br><span class="line">   ht.put(<span class="string">&#x27;class3&#x27;</span>,<span class="string">&#x27;Gogo&#x27;</span>);</span><br><span class="line">   ht.put(<span class="string">&#x27;class4&#x27;</span>,<span class="string">&#x27;Tony&#x27;</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//3.删除数据</span></span><br><span class="line">   <span class="built_in">console</span>.log( ht.remove(<span class="string">&#x27;class2&#x27;</span>));</span><br><span class="line">   <span class="built_in">console</span>.log(ht.get(<span class="string">&#x27;class2&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/13.png"></p>
<br>

<h5 id="4-其他方法"><a href="#4-其他方法" class="headerlink" title="4. 其他方法"></a>4. 其他方法</h5><p>其他方法包括：**isEmpty()、size()**：</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断哈希表是否为null</span></span><br><span class="line">  HashTable.prototype.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取哈希表中元素的个数</span></span><br><span class="line">  HashTable.prototype.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<br>

<h4 id="哈希表的扩容与压缩"><a href="#哈希表的扩容与压缩" class="headerlink" title="哈希表的扩容与压缩"></a>哈希表的扩容与压缩</h4><p>为什么需要扩容？</p>
<ul>
<li>前面我们在哈希表中使用的是<strong>长度为7的数组</strong>，由于使用的是**链地址法，装填因子(loadFactor)**可以大于1，所以这个哈希表可以无限制地插入新数据。</li>
<li>但是，随着<strong>数据量的增多</strong>，storage中每一个index对应的bucket数组（链表）就会越来越长，这就会造成哈希表<strong>效率的降低</strong></li>
</ul>
<blockquote>
<p><strong>装填因子</strong> = 哈希表中数据 / 哈希表长度，即 loadFactor = count / HashTable.length。</p>
</blockquote>
<p>什么情况下需要扩容？</p>
<ul>
<li>常见的情况是<strong>loadFactor &gt; 0.75</strong>的时候进行扩容；</li>
</ul>
<p>如何进行扩容？</p>
<ul>
<li>简单的扩容可以直接扩大<strong>两倍</strong>（关于质数，之后讨论）；</li>
<li>扩容之后<strong>所有的</strong>数据项都要进行<strong>同步修改</strong>；</li>
</ul>
<p><strong>实现思路:</strong></p>
<ul>
<li>首先，定义一个变量，比如oldStorage指向原来的storage；</li>
<li>然后，创建一个新的容量更大的数组，让this.storage指向它；</li>
<li>最后，将oldStorage中的每一个bucket中的每一个数据取出来依次添加到this.storage指向的新数组中；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/15.png"></p>
<p>代码实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表扩容</span></span><br><span class="line">HashTable.prototype.resize = <span class="function"><span class="keyword">function</span>(<span class="params">newLimit</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.保存旧的storage数组内容</span></span><br><span class="line">  <span class="keyword">let</span> oldStorage = <span class="built_in">this</span>.storage;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.重置所有的属性</span></span><br><span class="line">  <span class="built_in">this</span>.storage = [];</span><br><span class="line">  <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.limit = newLimit;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.遍历oldStorage中所有的bucket</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; oldStorage.length; i++) &#123;</span><br><span class="line">    <span class="comment">//3.1.取出对应的bucket</span></span><br><span class="line">    <span class="keyword">const</span> bucket = oldStorage[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2.判断bucket是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;      </span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3.bucket中有数据，就取出数据重新插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">      <span class="keyword">const</span> tuple = bucket[j];</span><br><span class="line">      <span class="built_in">this</span>.put(tuple[<span class="number">0</span>], tuple[<span class="number">1</span>]);<span class="comment">//插入数据的key和value</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述定义的哈希表的resize方法，既可以实现哈希表的<strong>扩容</strong>，也可以实现哈希表容量的<strong>压缩</strong>。</p>
<ul>
<li>通常情况下当<strong>装填因子laodFactor &gt; 0.75</strong>时，对哈希表进行扩容。在哈希表中的添加方法（push方法）中添加如下代码，判断是否需要调用扩容函数进行扩容：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容操作</span></span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">this</span>.count &gt; <span class="built_in">this</span>.limit * <span class="number">0.75</span>)&#123;</span><br><span class="line">   <span class="built_in">this</span>.resize(<span class="built_in">this</span>.limit * <span class="number">2</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当<strong>装填因子laodFactor &lt; 0.25</strong>时，对哈希表容量进行压缩。在哈希表中的删除方法（remove方法）中添加如下代码，判断是否需要调用扩容函数进行压缩：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缩小容量</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.limit &gt; <span class="number">7</span> &amp;&amp; <span class="built_in">this</span>.count &lt; <span class="built_in">this</span>.limit * <span class="number">0.25</span>) &#123;</span><br><span class="line">  <span class="built_in">this</span>.resize(<span class="built_in">Math</span>.floor(<span class="built_in">this</span>.limit / <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="选择质数作为哈希表容量"><a href="#选择质数作为哈希表容量" class="headerlink" title="选择质数作为哈希表容量"></a>选择质数作为哈希表容量</h4><p><strong>判断质数的方法</strong>：</p>
<blockquote>
<p>注意1不是质数</p>
</blockquote>
<ul>
<li>方法一：针对质数的特点：只能被1和num整除，不能被2 ~ (num-1)整除。遍历2 ~ (num-1) 。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num &lt;= <span class="number">1</span> )&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= num - <span class="number">1</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(num % i ==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法虽然能实现质数的判断，但是效率不高。</p>
<ul>
<li>方法二：只需要遍历2 ~ num的平方根即可。(原因这里不作讲解，可以参考视频)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//1.获取num的平方根:Math.sqrt(num)</span></span><br><span class="line">   <span class="comment">//2.循环判断</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i&lt;= <span class="built_in">Math</span>.sqrt(num); i++ )&#123;</span><br><span class="line">     <span class="keyword">if</span>(num % i == <span class="number">0</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现扩容后的哈希表容量为质数</strong></p>
<p><strong>实现思路：</strong></p>
<p>2倍扩容之后，通过循环调用isPrime判断得到的容量是否为质数，不是则+1，直到是为止。比如原长度：7，2倍扩容后长度为14，14不是质数，14 + 1 = 15不是质数，15 + 1 = 16不是质数，16 + 1 = 17是质数，停止循环，由此得到质数17。</p>
<p><strong>代码实现：</strong></p>
<ul>
<li><strong>第一步：</strong>首先需要为HashTable类添加判断质数的isPrime方法和获取质数的getPrime方法：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断传入的num是否质数</span></span><br><span class="line">HashTable.prototype.isPrime = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.获取num的平方根:Math.sqrt(num)</span></span><br><span class="line">    <span class="comment">//2.循环判断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i&lt;= <span class="built_in">Math</span>.sqrt(num); i++ )&#123;</span><br><span class="line">      <span class="keyword">if</span>(num % i == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取质数的方法</span></span><br><span class="line">  HashTable.prototype.getPrime = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">     <span class="comment">//7*2=14,+1=15,+1=16,+1=17(质数)</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isPrime(num)) &#123;</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>第二步：</strong>修改添加元素的put方法和删除元素的remove方法中关于数组扩容的相关操作：</li>
</ul>
<p>在put方法中添加如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容操作</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.count &gt; <span class="built_in">this</span>.limit * <span class="number">0.75</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> newSize = <span class="built_in">this</span>.limit * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">let</span> newPrime = <span class="built_in">this</span>.getPrime(newSize);</span><br><span class="line">  <span class="built_in">this</span>.resize(newPrime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在remove方法中添加如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缩小容量</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.limit &gt; <span class="number">7</span> &amp;&amp; <span class="built_in">this</span>.count &lt; <span class="built_in">this</span>.limit * <span class="number">0.25</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newSize = <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.limit / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">let</span> newPrime = <span class="built_in">this</span>.getPrime(newSize);</span><br><span class="line">  <span class="built_in">this</span>.resize(newPrime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ht = <span class="keyword">new</span> HashTable();</span><br><span class="line"></span><br><span class="line">ht.put(<span class="string">&#x27;class1&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class2&#x27;</span>,<span class="string">&#x27;Mary&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class3&#x27;</span>,<span class="string">&#x27;Gogo&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class4&#x27;</span>,<span class="string">&#x27;Tony&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class5&#x27;</span>,<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class6&#x27;</span>,<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class7&#x27;</span>,<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class8&#x27;</span>,<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class9&#x27;</span>,<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class10&#x27;</span>,<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ht.size());<span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(ht.limit);<span class="comment">//17</span></span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/16.png"></p>
<h4 id="哈希表的完整实现"><a href="#哈希表的完整实现" class="headerlink" title="哈希表的完整实现"></a>哈希表的完整实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用function实现*/</span>	</span><br><span class="line">    <span class="comment">//封装哈希表类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//属性</span></span><br><span class="line">      <span class="built_in">this</span>.storage = []</span><br><span class="line">      <span class="built_in">this</span>.count = <span class="number">0</span><span class="comment">//计算已经存储的元素个数</span></span><br><span class="line">      <span class="comment">//装填因子：loadFactor &gt; 0.75时需要扩容；loadFactor &lt; 0.25时需要减少容量</span></span><br><span class="line">      <span class="built_in">this</span>.limit = <span class="number">7</span><span class="comment">//初始长度</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//方法</span></span><br><span class="line">      <span class="comment">//哈希函数</span></span><br><span class="line">      HashTable.prototype.hashFunc = <span class="function"><span class="keyword">function</span>(<span class="params">str, size=<span class="number">7</span></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//1.定义hashCode变量</span></span><br><span class="line">      <span class="keyword">let</span> hashCode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.霍纳法则，计算hashCode的值</span></span><br><span class="line">      <span class="comment">//cats -&gt; Unicode编码</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ;i &lt; str.length; i++)&#123;</span><br><span class="line">        <span class="comment">// str.charCodeAt(i)//获取某个字符对应的unicode编码</span></span><br><span class="line">        hashCode = <span class="number">37</span> * hashCode + str.charCodeAt(i);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.取余操作</span></span><br><span class="line">      <span class="keyword">let</span> index = hashCode % size;</span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一.插入&amp;修改操作</span></span><br><span class="line">    HashTable.prototype.put = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//1.根据key获取对应的index</span></span><br><span class="line">      <span class="keyword">let</span> index = <span class="built_in">this</span>.hashFunc(key, <span class="built_in">this</span>.limit);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.根据index取出对应的bucket</span></span><br><span class="line">      <span class="keyword">let</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.判断该bucket是否为null</span></span><br><span class="line">      <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">        bucket = [];</span><br><span class="line">        <span class="built_in">this</span>.storage[index] = bucket;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.判断是否是修改数据</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tuple = bucket[i];</span><br><span class="line">        <span class="keyword">if</span> (tuple[<span class="number">0</span>] == key) &#123;</span><br><span class="line">          tuple[<span class="number">1</span>] = value;</span><br><span class="line">          <span class="keyword">return</span><span class="comment">//不用返回值</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//5.进行添加操作</span></span><br><span class="line">      bucket.push([key, value]);</span><br><span class="line">      <span class="built_in">this</span>.count += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//6.判断是否需要扩容操作</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>.count &gt; <span class="built_in">this</span>.limit * <span class="number">0.75</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> newSize = <span class="built_in">this</span>.limit * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">let</span> newPrime = <span class="built_in">this</span>.getPrime(newSize);</span><br><span class="line">        <span class="built_in">this</span>.resize(newPrime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二.获取操作</span></span><br><span class="line">    HashTable.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//1.根据key获取对应的index</span></span><br><span class="line">      <span class="keyword">let</span> index = <span class="built_in">this</span>.hashFunc(key, <span class="built_in">this</span>.limit);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.根据index获取对应的bucket</span></span><br><span class="line">      <span class="keyword">let</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.判断bucket是否等于null</span></span><br><span class="line">      <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.有bucket，那么就进行线性查找</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tuple = bucket[i];</span><br><span class="line">        <span class="keyword">if</span> (tuple[<span class="number">0</span>] == key); &#123;<span class="comment">//tuple[0]存储key，tuple[1]存储value</span></span><br><span class="line">          <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//5.依然没有找到，那么返回null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//三.删除操作</span></span><br><span class="line">    HashTable.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//1.根据key获取对应的index</span></span><br><span class="line">      <span class="keyword">let</span> index = <span class="built_in">this</span>.hashFunc(key, <span class="built_in">this</span>.limit);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.根据index获取对应的bucket</span></span><br><span class="line">      <span class="keyword">let</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.判断bucket是否为null</span></span><br><span class="line">      <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.有bucket,那么就进行线性查找并删除</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tuple = bucket[i];</span><br><span class="line">        <span class="keyword">if</span> (tuple[<span class="number">0</span>] == key) &#123;</span><br><span class="line">          bucket.splice(i,<span class="number">1</span>);</span><br><span class="line">          <span class="built_in">this</span>.count -= <span class="number">1</span> ;</span><br><span class="line">          <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">          <span class="comment">//6.缩小容量</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">this</span>.limit &gt; <span class="number">7</span> &amp;&amp; <span class="built_in">this</span>.count &lt; <span class="built_in">this</span>.limit * <span class="number">0.25</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> newSize = <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.limit / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">let</span> newPrime = <span class="built_in">this</span>.getPrime(newSize);</span><br><span class="line">            <span class="built_in">this</span>.resize(newPrime);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//5.依然没有找到，返回null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*------------------其他方法--------------------*/</span></span><br><span class="line">  <span class="comment">//判断哈希表是否为null</span></span><br><span class="line">  HashTable.prototype.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取哈希表中元素的个数</span></span><br><span class="line">  HashTable.prototype.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//哈希表扩容</span></span><br><span class="line">  HashTable.prototype.resize = <span class="function"><span class="keyword">function</span>(<span class="params">newLimit</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1.保存旧的storage数组内容</span></span><br><span class="line">    <span class="keyword">let</span> oldStorage = <span class="built_in">this</span>.storage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.重置所有的属性</span></span><br><span class="line">    <span class="built_in">this</span>.storage = [];</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.limit = newLimit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.遍历oldStorage中所有的bucket</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; oldStorage.length; i++) &#123;</span><br><span class="line">      <span class="comment">//3.1.取出对应的bucket</span></span><br><span class="line">      <span class="keyword">const</span> bucket = oldStorage[i];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.2.判断bucket是否为null</span></span><br><span class="line">      <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;      </span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.3.bucket中有数据，就取出数据重新插入</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">        <span class="keyword">const</span> tuple = bucket[j];</span><br><span class="line">        <span class="built_in">this</span>.put(tuple[<span class="number">0</span>], tuple[<span class="number">1</span>]);<span class="comment">//插入数据的key和value</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断传入的num是否质数</span></span><br><span class="line">  HashTable.prototype.isPrime = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//1.获取num的平方根:Math.sqrt(num)</span></span><br><span class="line">      <span class="comment">//2.循环判断</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">2</span>; i&lt;= <span class="built_in">Math</span>.sqrt(num); i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>(num % i == <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取质数的方法</span></span><br><span class="line">    HashTable.prototype.getPrime = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">       <span class="comment">//7*2=14,+1=15,+1=16,+1=17(质数)</span></span><br><span class="line">      <span class="keyword">while</span> (!<span class="built_in">this</span>.isPrime(num)) &#123;</span><br><span class="line">        num++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用class实现*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.storage = []; <span class="comment">// 哈希表存储数据的变量</span></span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>; <span class="comment">// 当前存放的元素个数</span></span><br><span class="line">    <span class="built_in">this</span>.limit = <span class="number">7</span>;  <span class="comment">// 哈希表长度（初始设为质数 7）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装填因子(已有个数/总个数)</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = <span class="number">0.75</span>;</span><br><span class="line">    <span class="built_in">this</span>.minLoadFactor = <span class="number">0.25</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getPrime(number) 根据传入的 number 获取最临近的质数</span></span><br><span class="line">  <span class="function"><span class="title">getPrime</span>(<span class="params">number</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!isPrime(number)) &#123;</span><br><span class="line">      number++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// put(key, value) 往哈希表里添加数据</span></span><br><span class="line">  <span class="function"><span class="title">put</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、根据 key 获取要映射到 storage 里面的 index（通过哈希函数获取）</span></span><br><span class="line">    <span class="keyword">const</span> index = hashFn(key, <span class="built_in">this</span>.limit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、根据 index 取出对应的 bucket</span></span><br><span class="line">    <span class="keyword">let</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、判断是否存在 bucket</span></span><br><span class="line">    <span class="keyword">if</span> (bucket === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      bucket = [];  <span class="comment">// 不存在则创建</span></span><br><span class="line">      <span class="built_in">this</span>.storage[index] = bucket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、判断是插入数据操作还是修改数据操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> tuple = bucket[i]; <span class="comment">// tuple 的格式：[key, value]</span></span><br><span class="line">      <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123; <span class="comment">// 如果 key 相等，则修改数据</span></span><br><span class="line">        tuple[<span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 修改完 tuple 里数据，return 终止，不再往下执行。</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、bucket 新增数据</span></span><br><span class="line">    bucket.push([key, value]); <span class="comment">// bucket 存储元组 tuple，格式为 [key, value]</span></span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断哈希表是否要扩容，若装填因子 &gt; 0.75，则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.count / <span class="built_in">this</span>.limit &gt; <span class="built_in">this</span>.loadFactor) &#123;</span><br><span class="line">      <span class="built_in">this</span>.resize(<span class="built_in">this</span>.getPrime(<span class="built_in">this</span>.limit * <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 get(key) 获取 value</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> index = hashFn(key, <span class="built_in">this</span>.limit);</span><br><span class="line">    <span class="keyword">const</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bucket === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> tuple <span class="keyword">of</span> bucket) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">        <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove(key) 删除指定 key 的数据</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> index = hashFn(key, <span class="built_in">this</span>.limit);</span><br><span class="line">    <span class="keyword">const</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bucket === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 bucket，找到对应位置的 tuple，将其删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = bucket.length; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> tuple = bucket[i];</span><br><span class="line">      <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">        bucket.splice(i, <span class="number">1</span>); <span class="comment">// 删除对应位置的数组项</span></span><br><span class="line">        <span class="built_in">this</span>.count--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据装填因子的大小，判断是否要进行哈希表压缩</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.limit &gt; <span class="number">7</span> &amp;&amp; <span class="built_in">this</span>.count / <span class="built_in">this</span>.limit &lt; <span class="built_in">this</span>.minLoadFactor) &#123;</span><br><span class="line">          <span class="built_in">this</span>.resize(<span class="built_in">this</span>.getPrime(<span class="built_in">Math</span>.floor(<span class="built_in">this</span>.limit / <span class="number">2</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tuple;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重新调整哈希表大小，扩容或压缩</span></span><br><span class="line">  <span class="function"><span class="title">resize</span>(<span class="params">newLimit</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、保存旧的 storage 数组内容</span></span><br><span class="line">    <span class="keyword">const</span> oldStorage = <span class="built_in">this</span>.storage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、重置所有属性</span></span><br><span class="line">    <span class="built_in">this</span>.storage = [];</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.limit = newLimit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、遍历 oldStorage，取出所有数据，重新 put 到 this.storage</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> bucket <span class="keyword">of</span> oldStorage) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bucket) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bucket) &#123;</span><br><span class="line">          <span class="built_in">this</span>.put(b[<span class="number">0</span>], b[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><hr>

<h3 id="树结构简介"><a href="#树结构简介" class="headerlink" title="树结构简介"></a>树结构简介</h3><p><strong>什么是树？</strong></p>
<p>真实的树：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/1.png"></p>
<p><strong>树的特点：</strong></p>
<ul>
<li>树一般都有一个<strong>根</strong>，连接着根的是<strong>树干</strong>；</li>
<li>树干会发生分叉，形成许多<strong>树枝</strong>，树枝会继续分化成更小的<strong>树枝</strong>；</li>
<li>树枝的最后是<strong>叶子</strong>；</li>
</ul>
<p>现实生活中很多结构都是树的抽象，模拟的树结构相当于旋转<code>180°</code>的树。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/2.png"></p>
<p><strong>树结构对比于数组/链表/哈希表有哪些优势呢：</strong></p>
<p><em>数组：</em></p>
<ul>
<li>优点：可以通过<strong>下标值访问</strong>，效率高；</li>
<li>缺点：查找数据时需要先对数据进行<strong>排序</strong>，生成<strong>有序数组</strong>，才能提高查找效率；并且在插入和删除元素时，需要大量的<strong>位移操作</strong>；</li>
</ul>
<p><em>链表：</em></p>
<ul>
<li>优点：数据的插入和删除操作效率都很高；</li>
<li>缺点：<strong>查找</strong>效率低，需要从头开始依次查找，直到找到目标数据为止；当需要在链表中间位置插入或删除数据时，插入或删除的效率都不高。</li>
</ul>
<p><em>哈希表：</em></p>
<ul>
<li>优点：哈希表的插入/查询/删除效率都非常高；</li>
<li>缺点：<strong>空间利用率不高</strong>，底层使用的数组中很多单元没有被利用；并且哈希表中的元素是<strong>无序</strong>的，不能按照固定顺序遍历哈希表中的元素；而且不能快速找出哈希表中<strong>最大值或最小值</strong>这些特殊值。</li>
</ul>
<p><em>树结构：</em></p>
<p>优点：树结构综合了上述三种结构的优点，同时也弥补了它们存在的缺点（虽然效率不一定都比它们高），比如树结构中数据都是有序的，查找效率高；空间利用率高；并且可以快速获取最大值和最小值等。</p>
<p>总的来说：<strong>每种数据结构都有自己特定的应用场景</strong>。</p>
<h3 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h3><ul>
<li><strong>树（Tree）</strong>:由 n（n ≥ 0）个节点构成的<strong>有限集合</strong>。当 n = 0 时，称为<strong>空树</strong>。</li>
</ul>
<p>对于任一棵非空树（n &gt; 0），它具备以下性质：</p>
<ul>
<li>数中有一个称为<strong>根（Root）</strong>的特殊节点，用 **r **表示；</li>
<li>其余节点可分为 m（m &gt; 0）个互不相交的有限集合 T1，T2，…，Tm，其中每个集合本身又是一棵树，称为原来树的<strong>子树（SubTree）</strong>。</li>
</ul>
<h4 id="树的常用术语"><a href="#树的常用术语" class="headerlink" title="树的常用术语"></a>树的常用术语</h4><p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/3.png"></p>
<ul>
<li><strong>节点的度（Degree）</strong>：节点的<strong>子树个数</strong>，比如节点B的度为2；</li>
<li><strong>树的度</strong>：树的所有节点中<strong>最大的度数</strong>，如上图树的度为2；</li>
<li><strong>叶节点（Leaf）</strong>：<strong>度为0的节点</strong>（也称为叶子节点），如上图的H，I等；</li>
<li><strong>父节点（Parent）</strong>：度不为0的节点称为父节点，如上图节点B是节点D和E的父节点；</li>
<li><strong>子节点（Child）</strong>：若B是D的父节点，那么D就是B的子节点；</li>
<li><strong>兄弟节点（Sibling）</strong>：具有同一父节点的各节点彼此是兄弟节点，比如上图的B和C，D和E互为兄弟节点；</li>
<li><strong>路径和路径长度</strong>：路径指的是一个节点到另一节点的通道，路径所包含边的个数称为路径长度，比如A-&gt;H的路径长度为3；</li>
<li><strong>节点的层次（Level）</strong>：规定<strong>根节点在1层</strong>，其他任一节点的层数是其父节点的<strong>层数加1</strong>。如B和C节点的层次为2；</li>
<li><strong>树的深度（Depth）</strong>：树种所有节点中的<strong>最大层次</strong>是这棵树的深度，如上图树的深度为4；</li>
</ul>
<h4 id="树结构的表示"><a href="#树结构的表示" class="headerlink" title="树结构的表示"></a>树结构的表示</h4><ul>
<li><strong>最普通的表示方法</strong>：</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/4.png"></p>
<p>如图，树结构的组成方式类似于链表，都是由一个个节点连接构成。不过，根据每个父节点子节点数量的不同，每一个父节点需要的引用数量也不同。比如节点A需要3个引用，分别指向子节点B，C，D；B节点需要2个引用，分别指向子节点E和F；K节点由于没有子节点，所以不需要引用。</p>
<p>这种方法缺点在于我们无法确定某一结点的引用数。</p>
<ul>
<li><strong>儿子-兄弟表示法</strong>：</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/5.png"></p>
<p>这种表示方法可以完整地记录每个节点的数据，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点A</span></span><br><span class="line">Node&#123;</span><br><span class="line">  <span class="comment">//存储数据</span></span><br><span class="line">  <span class="built_in">this</span>.data = data;</span><br><span class="line">  <span class="comment">//统一只记录左边的子节点</span></span><br><span class="line">  <span class="built_in">this</span>.leftChild = B;</span><br><span class="line">  <span class="comment">//统一只记录右边的第一个兄弟节点</span></span><br><span class="line">  <span class="built_in">this</span>.rightSibling = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点B</span></span><br><span class="line">Node&#123;</span><br><span class="line">  <span class="built_in">this</span>.data = data;</span><br><span class="line">  <span class="built_in">this</span>.leftChild = E;</span><br><span class="line">  <span class="built_in">this</span>.rightSibling = C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点F</span></span><br><span class="line">Node&#123;</span><br><span class="line">  <span class="built_in">this</span>.data = data;</span><br><span class="line">  <span class="built_in">this</span>.leftChild = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.rightSibling = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种表示法的优点在于每一个节点中引用的数量都是确定的。</p>
<ul>
<li><strong>儿子-兄弟表示法旋转</strong></li>
</ul>
<p>将儿子-兄弟表示法组成的树结构顺时针旋转45°之后：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/7.png"></p>
<p>这样就成为了一棵<strong>二叉树</strong>，由此我们可以得出结论：<strong>任何树都可以通过二叉树进行模拟</strong>。但是这样父节点不是变了吗？其实，父节点的设置只是为了方便指向子节点，在代码实现中谁是父节点并没有关系，只要能正确找到对应节点即可。</p>
<blockquote>
<p>因为任何树都可以通过二叉树进行模拟，所以我们这里不再讨论一般的树，而是直接学习二叉树。</p>
</blockquote>
<br>

<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><hr>

<h3 id="二叉树简介"><a href="#二叉树简介" class="headerlink" title="二叉树简介"></a>二叉树简介</h3><p><strong>二叉树的概念</strong>：如果树中的每一个节点最多只能有<strong>两个子节点</strong>（左子节点和右子节点），这样的树就称为<strong>二叉树</strong>。</p>
<p>二叉树十分重要，不仅仅是因为简单，更是因为几乎所有的树都可以表示成二叉树形式。</p>
<p><strong>二叉树的组成</strong>：</p>
<ul>
<li>二叉树可以为空，也就是没有节点；</li>
<li>若二叉树不为空，则它由根节点和称为其左子树TL和右子树TR的两个不相交的二叉树组成。</li>
</ul>
<p><strong>二叉树的五种形态</strong>：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/8.png"></p>
<p>上图分别表示：空的二叉树、只有一个节点的二叉树、只有左子树TL的二叉树、只有右子树TR的二叉树和有左右两个子树的二叉树。</p>
<p><strong>二叉树的特性</strong>：</p>
<ul>
<li><p>一个二叉树的第 i 层的最大节点树为：2<sup>(i-1)</sup>，i &gt;= 1；</p>
</li>
<li><p>深度为k的二叉树的最大节点总数为：2<sup>k </sup>- 1 ，k &gt;= 1；</p>
</li>
<li><p>对任何非空二叉树，若 n<sub>0</sub> 表示叶子节点的个数，n<sub>2</sub>表示度为2的非叶子节点个数，那么两者满足关系：n<sub>0</sub>  = n<sub>2</sub>+ 1。</p>
<p>如下图所示：H，E，I，J，G为叶子节点，总数为5；A，B，C，F为度为2的非叶子节点，总数为4；满足n<sub>0</sub>  = n<sub>2</sub> + 1的规律。</p>
</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/9.png"></p>
<h3 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h3><p><strong>完美二叉树</strong></p>
<p>完美二叉树（Perfect Binary Tree）也成为满二叉树（Full Binary Tree），在二叉树中，除了最下一层的叶子节点外，每层节点都有2个子节点，这就构成了完美二叉树。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/10.png"></p>
<p><strong>完全二叉树</strong></p>
<p>完全二叉树（Complete Binary Tree）:</p>
<ul>
<li>除了二叉树最后一层外，其他各层的节点数都达到了最大值；</li>
<li>并且，最后一层的叶子节点从左向右是连续存在，只缺失右侧若干叶子节点；</li>
<li>完美二叉树是特殊的完全二叉树。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/11.png"></p>
<h3 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h3><p>常见的二叉树存储方式为<strong>数组</strong>和<strong>链表</strong>：</p>
<p><strong>使用数组：</strong></p>
<ul>
<li><strong>完全二叉树</strong>：按从上到下，从左到右的方式存储数据。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/12.png"></p>
<table>
<thead>
<tr>
<th>节点</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
<th>H</th>
</tr>
</thead>
<tbody><tr>
<td><strong>序号</strong></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>4</strong></td>
<td><strong>5</strong></td>
<td><strong>6</strong></td>
<td><strong>7</strong></td>
<td><strong>8</strong></td>
</tr>
</tbody></table>
<p>使用数组存储时，取数据的时候也十分方便：左子节点的序号等于父节点序号 * 2，右子节点的序号等于父节点序号 * 2 + 1 。</p>
<ul>
<li><strong>非完全二叉树</strong>：非完全二叉树需要转换成完全二叉树才能按照上面的方案存储，这样会浪费很大的存储空间。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/13.png"></p>
<table>
<thead>
<tr>
<th>节点</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>^</th>
<th>^</th>
<th>F</th>
<th>^</th>
<th>^</th>
<th>^</th>
<th>^</th>
<th>^</th>
<th>^</th>
<th>M</th>
</tr>
</thead>
<tbody><tr>
<td><strong>序号</strong></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>4</strong></td>
<td><strong>5</strong></td>
<td><strong>6</strong></td>
<td><strong>7</strong></td>
<td><strong>8</strong></td>
<td><strong>9</strong></td>
<td><strong>10</strong></td>
<td><strong>11</strong></td>
<td><strong>12</strong></td>
<td><strong>13</strong></td>
</tr>
</tbody></table>
<p><strong>使用链表</strong></p>
<p>二叉树最常见的存储方式为<strong>链表</strong>：每一个节点封装成一个Node，Node中包含存储的数据、左节点的引用和右节点的引用。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/14.png"></p>
<br>

<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><hr>

<h3 id="认识二叉搜索树"><a href="#认识二叉搜索树" class="headerlink" title="认识二叉搜索树"></a>认识二叉搜索树</h3><p><strong>二叉搜索树</strong>（<strong>BST</strong>，Binary Search Tree），也称为<strong>二叉排序树</strong>和<strong>二叉查找树</strong>。</p>
<p>二叉搜索树是一棵二叉树，可以为空；</p>
<p>如果不为空，则满足以下<strong>性质</strong>：</p>
<ul>
<li>条件1：非空左子树的<strong>所有</strong>键值<strong>小于</strong>其根节点的键值。比如三中节点6的所有非空左子树的键值都小于6；</li>
<li>条件2：非空右子树的<strong>所有</strong>键值<strong>大于</strong>其根节点的键值；比如三中节点6的所有非空右子树的键值都大于6；</li>
<li>条件3：左、右子树本身也都是二叉搜索树（即左右子树也包含上述性质）。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/15.png"></p>
<p>如上图所示，树二和树三符合3个条件属于二叉树，树一不满足条件3所以不是二叉树。</p>
<p><strong>总结：</strong>二叉搜索树的特点主要是<strong>较小的值</strong>总是保存在<strong>左节点</strong>上，相对<strong>较大的值</strong>总是保存在<strong>右节点</strong>上。这种特点使得二叉搜索树的查询效率非常高，这也就是二叉搜索树中”搜索”的来源。</p>
<h3 id="二叉搜索树应用举例"><a href="#二叉搜索树应用举例" class="headerlink" title="二叉搜索树应用举例"></a>二叉搜索树应用举例</h3><p>下面是一个二叉搜索树：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/16.png"></p>
<p>若想在其中查找数据10，只需要查找4次，查找效率非常高。</p>
<ul>
<li>第1次：将10与根节点9进行比较，由于10 &gt; 9，所以10下一步与根节点9的右子节点13比较；</li>
<li>第2次：由于10 &lt; 13，所以10下一步与父节点13的左子节点11比较；</li>
<li>第3次：由于10 &lt; 11，所以10下一步与父节点11的左子节点10比较；</li>
<li>第4次：由于10 = 10，最终查找到数据10 。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/17.png"></p>
<p>同样是15个数据，在排序好的数组中查询数据10，需要查询10次：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/18.png"></p>
<p>其实：如果是排序好的数组，可以通过二分查找：第一次找9，第二次找13，第三次找15…。我们发现如果把每次二分的数据拿出来以树的形式表示的话就是<strong>二叉搜索树</strong>。这就是数组二分法查找效率之所以高的原因。</p>
<h3 id="二叉搜索树的封装"><a href="#二叉搜索树的封装" class="headerlink" title="二叉搜索树的封装"></a>二叉搜索树的封装</h3><h4 id="二叉树搜索树的基本属性"><a href="#二叉树搜索树的基本属性" class="headerlink" title="二叉树搜索树的基本属性"></a>二叉树搜索树的基本属性</h4><p>如图所示：二叉搜索树有四个最基本的属性：指向节点的<strong>根</strong>（root），节点中的<strong>键</strong>（key）、<strong>左指针</strong>（right）、<strong>右指针</strong>（right）。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/1.png"></p>
<p>所以，二叉搜索树中除了定义root属性外，还应定义一个节点内部类，里面包含每个节点中的left、right和key三个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//封装二叉搜索树</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">BinarySearchTree</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.key = key;</span><br><span class="line">      <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">      <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉搜索树的常见操作"><a href="#二叉搜索树的常见操作" class="headerlink" title="二叉搜索树的常见操作"></a>二叉搜索树的常见操作</h4><ul>
<li><code>insert(key)</code>：向树中插入一个新的键；</li>
<li><code>search(key)</code>：在树中查找一个键，如果节点存在，则返回true；如果不存在，则返回false；</li>
<li><code>inOrderTraverse</code>：通过中序遍历方式遍历所有节点；</li>
<li><code>preOrderTraverse</code>：通过先序遍历方式遍历所有节点；</li>
<li><code>postOrderTraverse</code>：通过后序遍历方式遍历所有节点；</li>
<li><code>min</code>：返回树中最小的值/键；</li>
<li><code>max</code>：返回树中最大的值/键；</li>
<li><code>remove(key)</code>：从树中移除某个键；</li>
</ul>
<h4 id="二叉搜索树方法实现"><a href="#二叉搜索树方法实现" class="headerlink" title="二叉搜索树方法实现"></a>二叉搜索树方法实现</h4><h5 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1. 插入数据"></a>1. 插入数据</h5><p><strong>实现思路：</strong></p>
<ul>
<li>首先根据传入的key创建节点对象；</li>
<li>然后判断根节点是否存在，不存在时通过：<code>this.root = newNode</code>，直接把新节点作为二叉搜索树的根节点。</li>
<li>若存在根节点则重新定义一个内部方法insertNode()用于查找插入点。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//insert方法:对外向用户暴露的方法</span></span><br><span class="line"> BinarySearchTree.prototype.insert = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//1.根据key创建节点</span></span><br><span class="line">   <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(key);</span><br><span class="line">     </span><br><span class="line">   <span class="comment">//2.判断根节点是否存在</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="built_in">this</span>.root = newNode;</span><br><span class="line">     <span class="comment">//根节点存在时</span></span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.insertNode(<span class="built_in">this</span>.root, newNode);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>内部方法insertNode()的实现思路</strong>:</p>
<p>根据比较传入的两个节点，一直查找新节点适合插入的位置，直到成功插入新节点为止。</p>
<p>当newNode.key &lt; node.key向左查找:</p>
<ul>
<li>情况1：当node无左子节点时，直接插入：</li>
<li>情况2：当node有左子节点时，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/2.png"></p>
<p>当newNode.key &gt;= node.key向右查找，与向左查找类似：</p>
<ul>
<li>情况1：当node无右子节点时，直接插入：</li>
<li>情况2：当node有右子节点时，依然递归调用insertNode(),直到遇到传入insertNode方法的node无右子节点成功插入newNode为止：</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/3.png"></p>
<p><strong>insertNode()代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部使用的insertNode方法:用于比较节点从左边插入还是右边插入</span></span><br><span class="line">BinarySearchTree.prototype.insertNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, newNode</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//当newNode.key &lt; node.key向左查找</span></span><br><span class="line">  <span class="keyword">if</span>(newNode.key &lt; node.key)&#123;</span><br><span class="line">    <span class="comment">//情况1：node无左子节点，直接插入</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">      node.left = newNode;</span><br><span class="line">    <span class="comment">//情况2：node有左子节点，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.insertNode(node.left, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">  <span class="comment">//当newNode.key &gt;= node.key向右查找</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//情况1：node无右子节点，直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">      node.right == newNode;</span><br><span class="line">    <span class="comment">//情况2：node有右子节点，依然递归调用insertNode(),直到遇到无右子节点成功插入newNode为止</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.insertNode(node.right, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//测试代码</span></span><br><span class="line">   <span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line">   <span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.插入数据</span></span><br><span class="line">   bst.insert(<span class="number">11</span>);</span><br><span class="line">   bst.insert(<span class="number">7</span>);</span><br><span class="line">   bst.insert(<span class="number">15</span>);</span><br><span class="line">   bst.insert(<span class="number">5</span>);</span><br><span class="line">   bst.insert(<span class="number">9</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bst);</span><br></pre></td></tr></table></figure>
<p>应得到下图所示的二叉搜索树：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/5.png"></p>
<p><strong>测试结果</strong>:</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/6.png"></p>
<br>

<h5 id="2-数据遍历"><a href="#2-数据遍历" class="headerlink" title="2. 数据遍历"></a>2. 数据遍历</h5><p>这里所说的树的遍历不仅仅针对二叉搜索树，而是适用于所有的二叉树。由于树结构不是线性结构，所以遍历方式有多种选择，常见的三种二叉树遍历方式为：</p>
<ul>
<li>先序遍历；</li>
<li>中序遍历；</li>
<li>后序遍历。</li>
</ul>
<p>还有层序遍历，使用较少。</p>
<h6 id="2-1-先序遍历"><a href="#2-1-先序遍历" class="headerlink" title="2.1.先序遍历"></a>2.1.先序遍历</h6><p>先序遍历的过程为：</p>
<ul>
<li>首先，遍历根节点；</li>
<li>然后，遍历其左子树；</li>
<li>最后，遍历其右子树。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/7.png"></p>
<p>如上图所示，二叉树的节点遍历顺序为：A -&gt; B -&gt; D -&gt; H -&gt; I -&gt; E -&gt; C -&gt; F -&gt; G。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line">   <span class="comment">//掺入一个handler函数方便之后对得到的key进行处理</span></span><br><span class="line">   BinarySearchTree.prototype.preOrderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">handler</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">this</span>.preOrderTraversalNode(<span class="built_in">this</span>.root, handler);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//封装内部方法，对某个节点进行遍历</span></span><br><span class="line">   BinarySearchTree.prototype.preOrderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node,handler</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="comment">//1.处理经过的节点</span></span><br><span class="line">       handler(node.key);</span><br><span class="line">       <span class="comment">/*-------递归1---------*/</span></span><br><span class="line">       <span class="comment">//2.遍历左子树中的节点</span></span><br><span class="line">       <span class="built_in">this</span>.preOrderTraversalNode(node.left, handler);</span><br><span class="line">       <span class="comment">/*--------递归2-------*/</span></span><br><span class="line">       <span class="comment">//3.遍历右子树中的节点</span></span><br><span class="line">       <span class="built_in">this</span>.preOrderTraversalNode(node.right, handler);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>过程详解：</strong></p>
<p>以遍历以下二叉搜索树为例：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/8.png"></p>
<p>首先调用preOrderTraversal方法，在方法里再调用preOrderTraversalNode方法用于遍历二叉搜索树。在preOrderTraversalNode方法中，递归1负责遍历左子节点，递归2负责遍历右子节点。先执行递归1，执行过程如下图所示：</p>
<blockquote>
<p><strong>记：preOrderTraversalNode() 为 A()</strong></p>
</blockquote>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/9.png"></p>
<p>可以看到一共递归调用了4次方法A，分别传入11、7、5、3，最后遇到null不满足 node != null 条件结束递归1；注意此时只是执行完最开始的递归1，并没有执行递归2，并且递归1执行到null停止后要一层层地往上返回，按顺序将调用的函数压出函数调用栈。</p>
<p>关于函数调用栈：之前的四次递归共把4个函数压入了函数调用栈，现在递归执行完了一层层地把函数压出栈。</p>
<p>值得注意的是：每一层函数都只是执行完了递归1，当返回到该层函数时，比如A（3）要继续执行递归2遍历二叉搜索树中的右子节点；</p>
<p>在执行递归2的过程中会不断调用方法A，并依次执行递归1和递归2，以此类推直到遇到null不满足 node != null 条件为止，才停止递归并一层层返回，如此循环。同理A（5）层、A（7）层、A（11）层都要经历上述循环，直到将二叉搜索树中的节点全部遍历完为止。</p>
<p>具体过程如下图所示：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/10.png"></p>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line"><span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">bst.insert(<span class="number">11</span>);</span><br><span class="line">bst.insert(<span class="number">7</span>);</span><br><span class="line">bst.insert(<span class="number">15</span>);</span><br><span class="line">bst.insert(<span class="number">5</span>);</span><br><span class="line">bst.insert(<span class="number">3</span>);</span><br><span class="line">bst.insert(<span class="number">9</span>);</span><br><span class="line">bst.insert(<span class="number">8</span>);</span><br><span class="line">bst.insert(<span class="number">10</span>);</span><br><span class="line">bst.insert(<span class="number">13</span>);</span><br><span class="line">bst.insert(<span class="number">12</span>);</span><br><span class="line">bst.insert(<span class="number">14</span>);</span><br><span class="line">bst.insert(<span class="number">20</span>);</span><br><span class="line">bst.insert(<span class="number">18</span>);</span><br><span class="line">bst.insert(<span class="number">25</span>);</span><br><span class="line">bst.insert(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试遍历</span></span><br><span class="line"><span class="keyword">let</span> resultString = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">//掺入处理节点值的处理函数</span></span><br><span class="line">bst.preOrderTraversal(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">  resultString += key + <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">&#125;)</span><br><span class="line">alert(resultString);</span><br></pre></td></tr></table></figure>
<p>应输出这样的顺序：11 -&gt; 7 -&gt; 5 -&gt; 3 -&gt; 6 -&gt; 9 -&gt; 8 -&gt; 10 -&gt; 15 -&gt; 13 -&gt;12 -&gt; 14 -&gt; 20 -&gt; 18 -&gt; 25 。</p>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/11.png"></p>
<br>

<h6 id="2-2-中序遍历"><a href="#2-2-中序遍历" class="headerlink" title="2.2.中序遍历"></a>2.2.中序遍历</h6><p>实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。</p>
<ul>
<li>首先，遍历其左子树；</li>
<li>然后，遍历根（父）节点；</li>
<li>最后，遍历其右子树。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line">BinarySearchTree.prototype.midOrderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">handler</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.midOrderTraversalNode(<span class="built_in">this</span>.root, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinarySearchTree.prototype.midOrderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, handler</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//1.遍历左子树中的节点</span></span><br><span class="line">    <span class="built_in">this</span>.midOrderTraversalNode(node.left, handler);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.处理节点</span></span><br><span class="line">    handler(node.key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.遍历右子树中的节点</span></span><br><span class="line">    <span class="built_in">this</span>.midOrderTraversalNode(node.right, handler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>过程详解：</strong></p>
<p>遍历的顺序应如下图所示：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/12.png"></p>
<blockquote>
<p>原作者这里画的有点错误，看到了吗？</p>
</blockquote>
<p>首先调用midOrderTraversal方法，在方法里再调用midOrderTraversalNode方法用于遍历二叉搜索树。先使用递归1遍历左子树中的节点；然后，处理父节点；最后，遍历右子树中的节点。</p>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">  <span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line">  <span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.插入数据</span></span><br><span class="line">  bst.insert(<span class="number">11</span>);</span><br><span class="line">  bst.insert(<span class="number">7</span>);</span><br><span class="line">  bst.insert(<span class="number">15</span>);</span><br><span class="line">  bst.insert(<span class="number">5</span>);</span><br><span class="line">  bst.insert(<span class="number">3</span>);</span><br><span class="line">  bst.insert(<span class="number">9</span>);</span><br><span class="line">  bst.insert(<span class="number">8</span>);</span><br><span class="line">  bst.insert(<span class="number">10</span>);</span><br><span class="line">  bst.insert(<span class="number">13</span>);</span><br><span class="line">  bst.insert(<span class="number">12</span>);</span><br><span class="line">  bst.insert(<span class="number">14</span>);</span><br><span class="line">  bst.insert(<span class="number">20</span>);</span><br><span class="line">  bst.insert(<span class="number">18</span>);</span><br><span class="line">  bst.insert(<span class="number">25</span>);</span><br><span class="line">  bst.insert(<span class="number">6</span>);	</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//3.测试中序遍历</span></span><br><span class="line">  <span class="keyword">let</span> resultString2 =<span class="string">&quot;&quot;</span>;</span><br><span class="line">  bst.midOrderTraversal(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    resultString2 += key + <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  alert(resultString2);</span><br></pre></td></tr></table></figure>
<p>输出节点的顺序应为：3 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 11 -&gt; 12 -&gt; 13 -&gt; 14 -&gt; 15 -&gt; 18 -&gt; 20 -&gt; 25 。</p>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/13.png"></p>
<br>

<h6 id="2-3-后序遍历"><a href="#2-3-后序遍历" class="headerlink" title="2.3.后序遍历"></a>2.3.后序遍历</h6><p>实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。</p>
<ul>
<li>首先，遍历其左子树；</li>
<li>然后，遍历其右子树；</li>
<li>最后，遍历根（父）节点；</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line">BinarySearchTree.prototype.postOrderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">handler</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.postOrderTraversalNode(<span class="built_in">this</span>.root, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinarySearchTree.prototype.postOrderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, handler</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//1.遍历左子树中的节点</span></span><br><span class="line">    <span class="built_in">this</span>.postOrderTraversalNode(node.left, handler);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.遍历右子树中的节点</span></span><br><span class="line">    <span class="built_in">this</span>.postOrderTraversalNode(node.right, handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.处理节点</span></span><br><span class="line">    handler(node.key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>过程详解：</strong></p>
<p>遍历的顺序应如下图所示：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/14.png"></p>
<p>首先调用postOrderTraversal方法，在方法里再调用postOrderTraversalNode方法用于遍历二叉搜索树。先使用递归1遍历左子树中的节点；然后，遍历右子树中的节点；最后，处理父节点。</p>
<p><strong>测试代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line"><span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">bst.insert(<span class="number">11</span>);</span><br><span class="line">bst.insert(<span class="number">7</span>);</span><br><span class="line">bst.insert(<span class="number">15</span>);</span><br><span class="line">bst.insert(<span class="number">5</span>);</span><br><span class="line">bst.insert(<span class="number">3</span>);</span><br><span class="line">bst.insert(<span class="number">9</span>);</span><br><span class="line">bst.insert(<span class="number">8</span>);</span><br><span class="line">bst.insert(<span class="number">10</span>);</span><br><span class="line">bst.insert(<span class="number">13</span>);</span><br><span class="line">bst.insert(<span class="number">12</span>);</span><br><span class="line">bst.insert(<span class="number">14</span>);</span><br><span class="line">bst.insert(<span class="number">20</span>);</span><br><span class="line">bst.insert(<span class="number">18</span>);</span><br><span class="line">bst.insert(<span class="number">25</span>);</span><br><span class="line">bst.insert(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试后序遍历</span></span><br><span class="line"><span class="keyword">let</span> resultString3 =<span class="string">&quot;&quot;</span>;</span><br><span class="line">bst.postOrderTraversal(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">  resultString3 += key + <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">&#125;)</span><br><span class="line">alert(resultString3);</span><br></pre></td></tr></table></figure>
<p>输出节点的顺序应为：3 -&gt; 6 -&gt; 5 -&gt; 8 -&gt; 10 -&gt; 9 -&gt; 7 -&gt; 12 -&gt; 14 -&gt; 13 -&gt; 18 -&gt; 25 -&gt; 20 -&gt; 15 -&gt; 11 。</p>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/15.png"></p>
<p><strong>总结：</strong>以遍历根（父）节点的顺序来区分三种遍历方式。比如：先序遍历先遍历根节点、中序遍历第二遍历根节点、后续遍历最后遍历根节点。</p>
<br>

<h5 id="3-查找数据"><a href="#3-查找数据" class="headerlink" title="3. 查找数据"></a>3. 查找数据</h5><h6 id="3-1-查找最大值-amp-最小值"><a href="#3-1-查找最大值-amp-最小值" class="headerlink" title="3.1.查找最大值&amp;最小值"></a>3.1.查找最大值&amp;最小值</h6><p>在二叉搜索树中查找最值非常简单，最小值在二叉搜索树的最左边，最大值在二叉搜索树的最右边。只需要一直向左/右查找就能得到最值，如下图所示：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/16.png"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找最大值</span></span><br><span class="line">BinarySearchTree.prototype.max = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//1.获取根节点</span></span><br><span class="line">  <span class="keyword">let</span> node = <span class="built_in">this</span>.root;</span><br><span class="line">  <span class="comment">//2.定义key保存节点值</span></span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//3.依次向右不断查找，直到节点为null</span></span><br><span class="line">  <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">    key = node.key;</span><br><span class="line">    node = node.right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找最小值</span></span><br><span class="line">BinarySearchTree.prototype.min = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//1.获取根节点</span></span><br><span class="line">   <span class="keyword">let</span> node = <span class="built_in">this</span>.root;</span><br><span class="line">  <span class="comment">//2.定义key保存节点值</span></span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//3.依次向左不断查找，直到节点为null</span></span><br><span class="line">  <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">    key = node.key;</span><br><span class="line">    node = node.left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"> <span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line"> <span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//2.插入数据</span></span><br><span class="line"> bst.insert(<span class="number">11</span>);</span><br><span class="line"> bst.insert(<span class="number">7</span>);</span><br><span class="line"> bst.insert(<span class="number">15</span>);</span><br><span class="line"> bst.insert(<span class="number">5</span>);</span><br><span class="line"> bst.insert(<span class="number">3</span>);</span><br><span class="line"> bst.insert(<span class="number">9</span>);</span><br><span class="line"> bst.insert(<span class="number">8</span>);</span><br><span class="line"> bst.insert(<span class="number">10</span>);</span><br><span class="line"> bst.insert(<span class="number">13</span>);</span><br><span class="line"> bst.insert(<span class="number">12</span>);</span><br><span class="line"> bst.insert(<span class="number">14</span>);</span><br><span class="line"> bst.insert(<span class="number">20</span>);</span><br><span class="line"> bst.insert(<span class="number">18</span>);</span><br><span class="line"> bst.insert(<span class="number">25</span>);</span><br><span class="line"> bst.insert(<span class="number">6</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//4.测试最值</span></span><br><span class="line"> <span class="built_in">console</span>.log(bst.max());</span><br><span class="line"> <span class="built_in">console</span>.log(bst.min());</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/17.png"></p>
<br>

<h6 id="3-2-查找特定值"><a href="#3-2-查找特定值" class="headerlink" title="3.2.查找特定值"></a>3.2.查找特定值</h6><p>查找二叉搜索树当中的特定值效率也非常高。只需要从根节点开始将需要查找节点的key值与之比较，若<strong>node.key &lt; root**则向左查找，若**node.key &gt; root</strong>就向右查找，直到找到或查找到null为止。这里可以使用递归实现，也可以采用循环来实现。</p>
<p><strong>实现代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找特定的key</span></span><br><span class="line"> BinarySearchTree.prototype.search = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//1.获取根节点</span></span><br><span class="line">   <span class="keyword">let</span> node = <span class="built_in">this</span>.root;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.循环搜索key</span></span><br><span class="line">   <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">     <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">       <span class="comment">//小于根(父)节点就往左边找</span></span><br><span class="line">       node = node.left;</span><br><span class="line">       <span class="comment">//大于根(父)节点就往右边找</span></span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; node.key)&#123;</span><br><span class="line">       node = node.right;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line"><span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">bst.insert(<span class="number">11</span>);</span><br><span class="line">bst.insert(<span class="number">7</span>);</span><br><span class="line">bst.insert(<span class="number">15</span>);</span><br><span class="line">bst.insert(<span class="number">5</span>);</span><br><span class="line">bst.insert(<span class="number">3</span>);</span><br><span class="line">bst.insert(<span class="number">9</span>);</span><br><span class="line">bst.insert(<span class="number">8</span>);</span><br><span class="line">bst.insert(<span class="number">10</span>);</span><br><span class="line">bst.insert(<span class="number">13</span>);</span><br><span class="line">bst.insert(<span class="number">12</span>);</span><br><span class="line">bst.insert(<span class="number">14</span>);</span><br><span class="line">bst.insert(<span class="number">20</span>);</span><br><span class="line">bst.insert(<span class="number">18</span>);</span><br><span class="line">bst.insert(<span class="number">25</span>);</span><br><span class="line">bst.insert(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试搜索方法</span></span><br><span class="line"><span class="built_in">console</span>.log(bst.search(<span class="number">24</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(bst.search(<span class="number">13</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(bst.search(<span class="number">2</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/18.png"></p>
<br>

<h5 id="4-删除数据"><a href="#4-删除数据" class="headerlink" title="4. 删除数据"></a>4. 删除数据</h5><p><strong>实现思路：</strong></p>
<p><strong>第一步：</strong>先找到需要删除的节点，若没找到，则不需要删除；</p>
<p>首先定义变量current用于保存需要删除的节点、变量parent用于保存它的父节点、变量isLeftChild保存current是否为parent的左节点，这样方便之后删除节点时改变相关节点的指向。</p>
<p><strong>实现代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.1.定义变量</span></span><br><span class="line">     <span class="keyword">let</span> current = <span class="built_in">this</span>.root;</span><br><span class="line">     <span class="keyword">let</span> parent = <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">let</span> isLeftChild = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//1.2.开始寻找删除的节点</span></span><br><span class="line">     <span class="keyword">while</span> (current.key != key) &#123;</span><br><span class="line">       parent = current;</span><br><span class="line">       <span class="comment">// 小于则往左查找</span></span><br><span class="line">       <span class="keyword">if</span> (key &lt; current.key) &#123;</span><br><span class="line">         isLeftChild = <span class="literal">true</span>;</span><br><span class="line">         current = current.left;</span><br><span class="line">       &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="comment">//大于则往右查找</span></span><br><span class="line">         isLeftChild = <span class="literal">false</span>;</span><br><span class="line">         current = current.rigth;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//找到最后依然没有找到相等的节点</span></span><br><span class="line">       <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//结束while循环后：current.key = key</span></span><br></pre></td></tr></table></figure>
<p><strong>第二步：</strong>删除找到的指定节点，后分3种情况：</p>
<ul>
<li>删除叶子节点；</li>
<li>删除只有一个子节点的节点；</li>
<li>删除有两个子节点的节点。</li>
</ul>
<h6 id="4-1-情况1：没有子节点"><a href="#4-1-情况1：没有子节点" class="headerlink" title="4.1.情况1：没有子节点"></a>4.1.情况1：没有子节点</h6><p>没有子节点时也有两种情况：</p>
<p>当该叶子节点为根节点时，如下图所示，此时<strong>current == this.root</strong>，直接通过：<strong>this.root = null</strong>，删除根节点。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/19.png"></p>
<p>当该叶子节点不为根节点时也有两种情况，如下图所示：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/20.png"></p>
<p>若current = 8，可以通过：parent.left = null，删除节点8；</p>
<p>若current = 10，可以通过：parent.right = null，删除节点10。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况1：删除的是叶子节点(没有子节点)</span></span><br><span class="line"><span class="keyword">if</span> (current.left == <span class="literal">null</span> &amp;&amp; current.right ==<span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild)&#123;</span><br><span class="line">    parent.left = <span class="literal">null</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    parent.right =<span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-2-情况2：有一个子节点"><a href="#4-2-情况2：有一个子节点" class="headerlink" title="4.2.情况2：有一个子节点"></a>4.2.情况2：有一个子节点</h6><p>有六种情况分别是：</p>
<p>当current存在左子节点时（current.right == null）：</p>
<ul>
<li>情况1：current为根节点（current == this.root），如节点11，此时通过：this.root = current.left，删除根节点11；</li>
<li>情况2：current为父节点parent的左子节点（isLeftChild == true），如节点5，此时通过：parent.left = current.left，删除节点5；</li>
<li>情况3：current为父节点parent的右子节点（isLeftChild == false），如节点9，此时通过：parent.right = current.left，删除节点9；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/21.png"></p>
<p>当current存在右子节点时（current.left = null）：</p>
<ul>
<li>情况4：current为根节点（current == this.root），如节点11，此时通过：this.root = current.right，删除根节点11。</li>
<li>情况5：current为父节点parent的左子节点（isLeftChild == true），如节点5，此时通过：parent.left = current.right，删除节点5；</li>
<li>情况6：current为父节点parent的右子节点（isLeftChild == false），如节点9，此时通过：parent.right = current.right，删除节点9；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/22.png"></p>
<p><strong>实现代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//情况2：删除的节点有一个子节点</span></span><br><span class="line">  <span class="comment">//当current存在左子节点时</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(current.right == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = current.left;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">          parent.left = current.left;</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">          parent.right = current.left;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">//当current存在右子节点时</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(current.left == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = current.right;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">          parent.left = current.right;</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">          parent.right = current.right;</span><br><span class="line">      &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-3-情况3：有两个子节点"><a href="#4-3-情况3：有两个子节点" class="headerlink" title="4.3.情况3：有两个子节点"></a>4.3.情况3：有两个子节点</h6><p>这种情况<strong>十分复杂</strong>，首先依据以下二叉搜索树，讨论这样的问题：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/23.png"></p>
<p><strong>删除节点9</strong></p>
<p>在保证删除节点9后原二叉树仍为二叉搜索树的前提下，有两种方式：</p>
<ul>
<li>方式1：从节点9的左子树中选择一合适的节点替代节点9，可知节点8符合要求；</li>
<li>方式2：从节点9的右子树中选择一合适的节点替代节点9，可知节点10符合要求；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/24.png"></p>
<p><strong>删除节点7</strong></p>
<p>在保证删除节点7后原二叉树仍为二叉搜索树的前提下，也有两种方式：</p>
<ul>
<li>方式1：从节点7的左子树中选择一合适的节点替代节点7，可知节点5符合要求；</li>
<li>方式2：从节点7的右子树中选择一合适的节点替代节点7，可知节点8符合要求；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/25.png"></p>
<p><strong>删除节点15</strong></p>
<p>在保证删除节点15后原树二叉树仍为二叉搜索树的前提下，同样有两种方式：</p>
<ul>
<li>方式1：从节点15的左子树中选择一合适的节点替代节点15，可知节点14符合要求；</li>
<li>方式2：从节点15的右子树中选择一合适的节点替代节点15，可知节点18符合要求；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/26.png"></p>
<p>相信你已经发现其中的规律了！</p>
<p><strong>规律总结：</strong>如果要删除的节点有两个子节点，甚至子节点还有子节点，这种情况下需要从要删除节点<strong>下面的子节点中找到一个合适的节点</strong>，来替换当前的节点。</p>
<p>若用current表示需要删除的节点，则合适的节点指的是：</p>
<ul>
<li>current左子树中比current<strong>小一点点的节点</strong>，即current<strong>左子树</strong>中的<strong>最大值</strong>；</li>
<li>current右子树中比current<strong>大一点点的节点</strong>，即current<strong>右子树</strong>中的<strong>最小值</strong>。</li>
</ul>
<p><strong>前驱&amp;后继</strong></p>
<p>在二叉搜索树中，这两个特殊的节点有特殊的名字：</p>
<ul>
<li>比current小一点点的节点，称为current节点的<strong>前驱</strong>。比如下图中的节点5就是节点7的前驱；</li>
<li>比current大一点点的节点，称为current节点的<strong>后继</strong>。比如下图中的节点8就是节点7的后继；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/27.png"></p>
<p><strong>代码实现：</strong></p>
<ul>
<li>查找需要被删除的节点current的后继时，需要在current的<strong>右子树</strong>中查找<strong>最小值</strong>，即在current的<strong>右子树</strong>中一直<strong>向左遍历</strong>查找；</li>
<li>查找前驱时，则需要在current的<strong>左子树</strong>中查找<strong>最大值</strong>，即在current的<strong>左子树</strong>中一直<strong>向右</strong>遍历查找。</li>
</ul>
<p>下面只讨论查找current后继的情况，查找前驱的原理相同，这里暂不讨论。</p>
<h6 id="4-4-完整实现"><a href="#4-4-完整实现" class="headerlink" title="4.4.完整实现"></a>4.4.完整实现</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//删除节点</span></span><br><span class="line">      BinarySearchTree.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line"><span class="comment">/*------------------------------1.寻找要删除的节点---------------------------------*/</span></span><br><span class="line">        <span class="comment">//1.1.定义变量current保存删除的节点，parent保存它的父节点。isLeftChild保存current是否为parent的左节点</span></span><br><span class="line">        <span class="keyword">let</span> current = <span class="built_in">this</span>.root;</span><br><span class="line">        <span class="keyword">let</span> parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> isLeftChild = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.2.开始寻找删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> (current.key != key) &#123;</span><br><span class="line">          parent = current;</span><br><span class="line">          <span class="comment">// 小于则往左查找</span></span><br><span class="line">          <span class="keyword">if</span> (key &lt; current.key) &#123;</span><br><span class="line">            isLeftChild = <span class="literal">true</span>;</span><br><span class="line">            current = current.left;</span><br><span class="line">          &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            isLeftChild = <span class="literal">false</span>;</span><br><span class="line">            current = current.right;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//找到最后依然没有找到相等的节点</span></span><br><span class="line">          <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束while循环后：current.key = key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------2.根据对应情况删除节点------------------------------*/</span></span><br><span class="line">        <span class="comment">//情况1：删除的是叶子节点(没有子节点)</span></span><br><span class="line">        <span class="keyword">if</span> (current.left == <span class="literal">null</span> &amp;&amp; current.right ==<span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild)&#123;</span><br><span class="line">            parent.left = <span class="literal">null</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right =<span class="literal">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//情况2：删除的节点有一个子节点</span></span><br><span class="line">        <span class="comment">//当current存在左子节点时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(current.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">              <span class="built_in">this</span>.root = current.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">                parent.left = current.left;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                parent.right = current.left;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//当current存在右子节点时</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(current.left == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">              <span class="built_in">this</span>.root = current.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">                parent.left = current.right;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                parent.right = current.right</span><br><span class="line">            &#125; </span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">//情况3：删除的节点有两个子节点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//1.获取后继节点</span></span><br><span class="line">          <span class="keyword">let</span> successor = <span class="built_in">this</span>.getSuccessor(current);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//2.判断是否根节点</span></span><br><span class="line">          <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root = successor;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild)&#123;</span><br><span class="line">            parent.left = successor;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.right = successor;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//3.将后继的左子节点改为被删除节点的左子节点</span></span><br><span class="line">          successor.left = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//封装查找后继的方法</span></span><br><span class="line">      BinarySearchTree.prototype.getSuccessor = <span class="function"><span class="keyword">function</span>(<span class="params">delNode</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//1.定义变量,保存找到的后继</span></span><br><span class="line">        <span class="keyword">let</span> successor = delNode;</span><br><span class="line">        <span class="keyword">let</span> current = delNode.right;</span><br><span class="line">        <span class="keyword">let</span> successorParent = delNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.循环查找current的右子树节点</span></span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">          successorParent = successor</span><br><span class="line">          successor = current;</span><br><span class="line">          current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.判断寻找到的后继节点是否直接就是删除节点的right节点</span></span><br><span class="line">        <span class="keyword">if</span>(successor != delNode.right)&#123;</span><br><span class="line">          successorParent.left = successor.right;</span><br><span class="line">          successor.right = delNode.right ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"> <span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line"> <span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//2.插入数据</span></span><br><span class="line"> bst.insert(<span class="number">11</span>);</span><br><span class="line"> bst.insert(<span class="number">7</span>);</span><br><span class="line"> bst.insert(<span class="number">15</span>);</span><br><span class="line"> bst.insert(<span class="number">5</span>);</span><br><span class="line"> bst.insert(<span class="number">3</span>);</span><br><span class="line"> bst.insert(<span class="number">9</span>);</span><br><span class="line"> bst.insert(<span class="number">8</span>);</span><br><span class="line"> bst.insert(<span class="number">10</span>);</span><br><span class="line"> bst.insert(<span class="number">13</span>);</span><br><span class="line"> bst.insert(<span class="number">12</span>);</span><br><span class="line"> bst.insert(<span class="number">14</span>);</span><br><span class="line"> bst.insert(<span class="number">20</span>);</span><br><span class="line"> bst.insert(<span class="number">18</span>);</span><br><span class="line"> bst.insert(<span class="number">25</span>);</span><br><span class="line"> bst.insert(<span class="number">6</span>);</span><br><span class="line"> bst.insert(<span class="number">19</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//3.测试删除代码</span></span><br><span class="line"> <span class="comment">//删除没有子节点的节点</span></span><br><span class="line"> bst.remove(<span class="number">3</span>);</span><br><span class="line"> bst.remove(<span class="number">8</span>);</span><br><span class="line"> bst.remove(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//删除有一个子节点的节点</span></span><br><span class="line"> bst.remove(<span class="number">5</span>);</span><br><span class="line"> bst.remove(<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//删除有两个子节点的节点</span></span><br><span class="line"> bst.remove(<span class="number">9</span>);</span><br><span class="line"> bst.remove(<span class="number">7</span>);</span><br><span class="line"> bst.remove(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//遍历二叉搜索树并输出</span></span><br><span class="line"> <span class="keyword">let</span> resultString = <span class="string">&quot;&quot;</span>;</span><br><span class="line"> bst.midOrderTraversal(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">   resultString += key + <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line"> &#125;)</span><br><span class="line"> alert(resultString);</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/28.png"></p>
<p>可见三种情况的节点都被成功删除了。</p>
<h5 id="完整封装"><a href="#完整封装" class="headerlink" title="完整封装"></a>完整封装</h5><h6 id="1）-使用function实现"><a href="#1）-使用function实现" class="headerlink" title="1） 使用function实现"></a>1） 使用function实现</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用function实现*/</span>    </span><br><span class="line"><span class="comment">//封装二叉搜索树</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">BinarySearchTree</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//节点内部类</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key</span><br><span class="line">        <span class="built_in">this</span>.left = <span class="literal">null</span></span><br><span class="line">        <span class="built_in">this</span>.right = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//属性</span></span><br><span class="line">      <span class="built_in">this</span>.root = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//方法</span></span><br><span class="line">      <span class="comment">//一.插入数据：insert方法:对外向用户暴露的方法</span></span><br><span class="line">      BinarySearchTree.prototype.insert = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//1.根据key创建节点</span></span><br><span class="line">        <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(key)</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//2.判断根节点是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="built_in">this</span>.root = newNode</span><br><span class="line">          <span class="comment">//根节点存在时</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.insertNode(<span class="built_in">this</span>.root, newNode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//内部使用的insertNode方法:用于比较节点从左边插入还是右边插入</span></span><br><span class="line">      BinarySearchTree.prototype.insertNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, newNode</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//当newNode.key &lt; node.key向左查找</span></span><br><span class="line">        <span class="keyword">if</span>(newNode.key &lt; node.key)&#123;</span><br><span class="line">          <span class="comment">//情况1：node无左子节点，直接插入</span></span><br><span class="line">          <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.left = newNode</span><br><span class="line">          <span class="comment">//情况2：node有左子节点，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。</span></span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.insertNode(node.left, newNode)</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">//当newNode.key &gt;= node.key向右查找</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//情况1：node无右子节点，直接插入</span></span><br><span class="line">          <span class="keyword">if</span>(node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            node.right = newNode</span><br><span class="line">          <span class="comment">//情况2：node有右子节点，依然递归调用insertNode(),直到遇到无右子节点成功插入newNode为止</span></span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.insertNode(node.right, newNode)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//二.树的遍历</span></span><br><span class="line">      <span class="comment">//1.先序遍历</span></span><br><span class="line">      <span class="comment">//掺入一个handler函数对得到的key进行处理</span></span><br><span class="line">      BinarySearchTree.prototype.preOrderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">handler</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.preOrderTraversalNode(<span class="built_in">this</span>.root, handler)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//封装内部方法，对某个节点进行遍历</span></span><br><span class="line">      BinarySearchTree.prototype.preOrderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//1.处理经过的节点</span></span><br><span class="line">          handler(node.key)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//2.遍历经过节点的左子节点</span></span><br><span class="line">          <span class="built_in">this</span>.preOrderTraversalNode(node.left, handler)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//3.遍历经过节点的右子节点</span></span><br><span class="line">          <span class="built_in">this</span>.preOrderTraversalNode(node.right, handler)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.中序遍历</span></span><br><span class="line">      BinarySearchTree.prototype.midOrderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">handler</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.midOrderTraversalNode(<span class="built_in">this</span>.root, handler)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      BinarySearchTree.prototype.midOrderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//1.遍历左子树中的节点</span></span><br><span class="line">          <span class="built_in">this</span>.midOrderTraversalNode(node.left, handler)</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//2.处理节点</span></span><br><span class="line">          handler(node.key)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//3.遍历右子树中的节点</span></span><br><span class="line">          <span class="built_in">this</span>.midOrderTraversalNode(node.right, handler)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.后序遍历</span></span><br><span class="line">      BinarySearchTree.prototype.postOrderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">handler</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.postOrderTraversalNode(<span class="built_in">this</span>.root, handler)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      BinarySearchTree.prototype.postOrderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//1.遍历左子树中的节点</span></span><br><span class="line">          <span class="built_in">this</span>.postOrderTraversalNode(node.left, handler)</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//2.遍历右子树中的节点</span></span><br><span class="line">          <span class="built_in">this</span>.postOrderTraversalNode(node.right, handler)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//3.处理节点</span></span><br><span class="line">          handler(node.key)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//三.寻找最值</span></span><br><span class="line">      <span class="comment">//寻找最大值</span></span><br><span class="line">      BinarySearchTree.prototype.max = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取根节点</span></span><br><span class="line">        <span class="keyword">let</span> node = <span class="built_in">this</span>.root</span><br><span class="line">        <span class="comment">//2.定义key保存节点值</span></span><br><span class="line">        <span class="keyword">let</span> key = <span class="literal">null</span></span><br><span class="line">        <span class="comment">//3.依次向右不断查找，直到节点为null</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          key = node.key</span><br><span class="line">          node = node.right</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> key</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//寻找最小值</span></span><br><span class="line">      BinarySearchTree.prototype.min = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="comment">//1.获取根节点</span></span><br><span class="line">         <span class="keyword">let</span> node = <span class="built_in">this</span>.root</span><br><span class="line">        <span class="comment">//2.定义key保存节点值</span></span><br><span class="line">        <span class="keyword">let</span> key = <span class="literal">null</span></span><br><span class="line">        <span class="comment">//3.依次向左不断查找，直到节点为null</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          key = node.key</span><br><span class="line">          node = node.left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> key</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//查找特定的key</span></span><br><span class="line">      BinarySearchTree.prototype.search = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//1.获取根节点</span></span><br><span class="line">        <span class="keyword">let</span> node = <span class="built_in">this</span>.root</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.循环搜索key</span></span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">            <span class="comment">//小于根(父)节点就往左边找</span></span><br><span class="line">            node = node.left</span><br><span class="line">            <span class="comment">//大于根(父)节点就往右边找</span></span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; node.key)&#123;</span><br><span class="line">            node = node.right</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//四.删除节点</span></span><br><span class="line">      BinarySearchTree.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line"><span class="comment">/*------------------------------1.寻找要删除的节点---------------------------------*/</span></span><br><span class="line">        <span class="comment">//1.1.定义变量current保存删除的节点，parent保存它的父节点。isLeftChild保存current是否为parent的左节点</span></span><br><span class="line">        <span class="keyword">let</span> current = <span class="built_in">this</span>.root</span><br><span class="line">        <span class="keyword">let</span> parent = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">let</span> isLeftChild = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.2.开始寻找删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> (current.key != key) &#123;</span><br><span class="line">          parent = current</span><br><span class="line">          <span class="comment">// 小于则往左查找</span></span><br><span class="line">          <span class="keyword">if</span> (key &lt; current.key) &#123;</span><br><span class="line">            isLeftChild = <span class="literal">true</span></span><br><span class="line">            current = current.left</span><br><span class="line">          &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            isLeftChild = <span class="literal">false</span></span><br><span class="line">            current = current.right</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//找到最后依然没有找到相等的节点</span></span><br><span class="line">          <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束while循环后：current.key = key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------2.根据对应情况删除节点------------------------------*/</span></span><br><span class="line">        <span class="comment">//情况1：删除的是叶子节点(没有子节点)</span></span><br><span class="line">        <span class="keyword">if</span> (current.left == <span class="literal">null</span> &amp;&amp; current.right ==<span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root = <span class="literal">null</span></span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild)&#123;</span><br><span class="line">            parent.left = <span class="literal">null</span></span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right =<span class="literal">null</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//情况2：删除的节点有一个子节点</span></span><br><span class="line">        <span class="comment">//当current存在左子节点时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(current.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">              <span class="built_in">this</span>.root = current.left</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">                parent.left = current.left</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                parent.right = current.left</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//当current存在右子节点时</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(current.left == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">              <span class="built_in">this</span>.root = current.right</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">                parent.left = current.right</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                parent.right = current.right</span><br><span class="line">            &#125; </span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">//情况3：删除的节点有两个子节点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//1.获取后继节点</span></span><br><span class="line">          <span class="keyword">let</span> successor = <span class="built_in">this</span>.getSuccessor(current)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//2.判断是否根节点</span></span><br><span class="line">          <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root = successor</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild)&#123;</span><br><span class="line">            parent.left = successor</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.right = successor</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//3.将后继的左子节点改为被删除节点的左子节点</span></span><br><span class="line">          successor.left = current.left</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//封装查找后继的方法</span></span><br><span class="line">      BinarySearchTree.prototype.getSuccessor = <span class="function"><span class="keyword">function</span>(<span class="params">delNode</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//1.定义变量,保存找到的后继</span></span><br><span class="line">        <span class="keyword">let</span> successor = delNode</span><br><span class="line">        <span class="keyword">let</span> current = delNode.right</span><br><span class="line">        <span class="keyword">let</span> successorParent = delNode</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.循环查找current的右子树节点</span></span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">          successorParent = successor</span><br><span class="line">          successor = current</span><br><span class="line">          current = current.left</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.判断寻找到的后继节点是否直接就是删除节点的right节点</span></span><br><span class="line">        <span class="keyword">if</span>(successor != delNode.right)&#123;</span><br><span class="line">          successorParent.left = successor.right</span><br><span class="line">          successor.right = delNode.right </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> successor</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="2）使用class实现"><a href="#2）使用class实现" class="headerlink" title="2）使用class实现"></a>2）使用class实现</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="function"><span class="title">remove</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.root;</span><br><span class="line">  <span class="keyword">let</span> parentNode = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> isLeftChild = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环查找到要删除的节点 currentNode，以及它的 parentNode、isLeftChild</span></span><br><span class="line">  <span class="keyword">while</span> (currentNode.key !== key) &#123;</span><br><span class="line"></span><br><span class="line">    parentNode = currentNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小于，往左查找</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; currentNode.key) &#123;</span><br><span class="line">      isLeftChild = <span class="literal">true</span>;</span><br><span class="line">      currentNode = currentNode.left;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 否则往右查找</span></span><br><span class="line">      isLeftChild = <span class="literal">false</span>;</span><br><span class="line">      currentNode = currentNode.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最后都没找到相等的节点，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1、删除的是叶子节点的情况</span></span><br><span class="line">  <span class="keyword">if</span> (currentNode.left === <span class="literal">null</span> &amp;&amp; currentNode.right === <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="built_in">this</span>.root) &#123;</span><br><span class="line">      <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">      parentNode.left = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parentNode.right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、删除的是只有一个子节点的节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentNode.right === <span class="literal">null</span>) &#123; <span class="comment">// currentNode 只存在左节点</span></span><br><span class="line">    <span class="comment">//-- 2.1、currentNode 只存在&lt;左节点&gt;的情况</span></span><br><span class="line">    <span class="comment">//---- 2.1.1、currentNode 等于 root</span></span><br><span class="line">    <span class="comment">//---- 2.1.2、parentNode.left 等于 currentNode</span></span><br><span class="line">    <span class="comment">//---- 2.1.3、parentNode.right 等于 currentNode</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="built_in">this</span>.root) &#123;</span><br><span class="line">      <span class="built_in">this</span>.root = currentNode.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">      parentNode.left = currentNode.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parentNode.right = currentNode.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentNode.left === <span class="literal">null</span>) &#123; <span class="comment">// currentNode 只存在右节点</span></span><br><span class="line">    <span class="comment">//-- 2.2、currentNode 只存在&lt;右节点&gt;的情况</span></span><br><span class="line">    <span class="comment">//---- 2.1.1 currentNode 等于 root</span></span><br><span class="line">    <span class="comment">//---- 2.1.1 parentNode.left 等于 currentNode</span></span><br><span class="line">    <span class="comment">//---- 2.1.1 parentNode.right 等于 currentNode</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="built_in">this</span>.root) &#123;</span><br><span class="line">      <span class="built_in">this</span>.root = currentNode.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">      parentNode.left = currentNode.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parentNode.right = currentNode.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、删除的是有两个子节点的节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、找到后续节点</span></span><br><span class="line">    <span class="keyword">let</span> successor = <span class="built_in">this</span>.getSuccessor(currentNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、判断是否为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="built_in">this</span>.root) &#123;</span><br><span class="line">      <span class="built_in">this</span>.root = successor;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">      parentNode.left = successor;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parentNode.right = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、将后续的左节点改为被删除的左节点</span></span><br><span class="line">    successor.left = currentNode.left;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取后续节点，即从要删除的节点的右边开始查找最小的值</span></span><br><span class="line"><span class="function"><span class="title">getSuccessor</span>(<span class="params">delNode</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义变量，保存要找到的后续</span></span><br><span class="line">  <span class="keyword">let</span> successor = delNode;</span><br><span class="line">  <span class="keyword">let</span> current = delNode.right;</span><br><span class="line">  <span class="keyword">let</span> successorParent = delNode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环查找 current 的右子树节点</span></span><br><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    successorParent = successor;</span><br><span class="line">    successor = current;</span><br><span class="line">    current = current.left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断寻找到的后续节点是否直接就是要删除节点的 right</span></span><br><span class="line">  <span class="keyword">if</span> (successor !== delNode.right) &#123;</span><br><span class="line">    successorParent.left = successor.right;</span><br><span class="line">    successor.right = delNode.right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> successor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><p><strong>二叉搜索树的缺陷：</strong></p>
<p>当插入的数据是有序的数据，就会造成二叉搜索树的深度过大。比如原二叉搜索树右 11 7 15 组成，如下图所示：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/29.png"></p>
<p>当插入一组有序数据：6 5 4 3 2就会变成深度过大的搜索二叉树，会严重影响二叉搜索树的性能。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/30.png"></p>
<p><strong>非平衡树</strong></p>
<ul>
<li>比较好的二叉搜索树，它的数据应该是<strong>左右均匀分布</strong>的；</li>
<li>但是插入<strong>连续数据</strong>后，二叉搜索树中的数据分布就变得<strong>不均匀</strong>了，我们称这种树为<strong>非平衡树</strong>；</li>
<li>对于一棵<strong>平衡二叉树</strong>来说，插入/查找等操作的效率是<strong>O（logN）</strong>；</li>
<li>而对于一棵<strong>非平衡二叉树</strong>来说，相当于编写了一个链表，查找效率变成了<strong>O（N）</strong>;</li>
</ul>
<p><strong>树的平衡性</strong></p>
<p>为了能以<strong>较快的时间O（logN）</strong>来操作一棵树，我们需要<strong>保证树总是平衡</strong>的：</p>
<ul>
<li>起码大部分是平衡的，此时的时间复杂度也是接近O（logN）的；</li>
<li>这就要求树中<strong>每个节点左边的子孙节点</strong>的个数，应该尽可能地等于<strong>右边的子孙节点</strong>的个数；</li>
</ul>
<p><strong>常见的平衡树</strong></p>
<ul>
<li><strong>AVL树</strong>：是最早的一种平衡树，它通过在每个节点多存储一个额外的数据来保持树的平衡。由于AVL树是平衡树，所以它的时间复杂度也是O（logN）。但是它的整体效率不如红黑树，开发中比较少用。</li>
<li><strong>红黑树</strong>：同样通过<strong>一些特性</strong>来保持树的平衡，时间复杂度也是O（logN）。进行插入/删除等操作时，性能优于AVL树，所以平衡树的应用基本都是红黑树。</li>
</ul>
<blockquote>
<p>这里有一份平衡二叉树的JS实现代码的链接，原地址：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wang516038746/article/details/66565505">JS实现平衡二叉树</a>。</p>
</blockquote>
<br>

<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><hr>

<blockquote>
<p>这里只作较简单的说明和代码封装，感兴趣的请自行深入了解。</p>
</blockquote>
<h3 id="图的简介"><a href="#图的简介" class="headerlink" title="图的简介"></a>图的简介</h3><p><strong>什么是图？</strong></p>
<ul>
<li><strong>图结构</strong>是一种与<strong>树结构</strong>有些相似的数据结构；</li>
<li><strong>图论</strong>是数学的一个分支，并且，在数学中，树是图的一种；</li>
<li>图论以图为研究对象，研究<strong>顶点</strong>和<strong>边</strong>组成的<strong>图形</strong>的数学理论和方法；</li>
<li>主要的研究目的为：<strong>事物之间的联系</strong>，<strong>顶点</strong>代表<strong>事物</strong>，<strong>边</strong>代表两个事物间的<strong>关系</strong>；</li>
</ul>
<p><strong>图的特点：</strong></p>
<ul>
<li><strong>一组顶点</strong>：通常用 <strong>V</strong> （Vertex）表示顶点的集合；</li>
<li>一组边：通常用 E（Edge）表示边的集合；<ul>
<li>边是顶点和顶点之间的连线；</li>
<li>边可以是有向的，也可以是无向的。比如A—-B表示无向，A —&gt; B 表示有向；</li>
</ul>
</li>
</ul>
<p><strong>图的常用术语：</strong></p>
<ul>
<li><strong>顶点：</strong>表示图中的一个<strong>节点</strong>；</li>
<li><strong>边：</strong>表示<strong>顶点和顶点</strong>给之间的<strong>连线</strong>；</li>
<li><strong>相邻顶点：</strong>由一条边连接在一起的顶点称为<strong>相邻顶点</strong>；</li>
<li><strong>度：</strong>一个顶点的<strong>度</strong>是<strong>相邻顶点的数量</strong>；</li>
<li><strong>路径：</strong><ul>
<li><strong>简单路径：</strong>简单路径要求不包含重复的顶点；</li>
<li><strong>回路：</strong>第一个顶点和最后一个顶点<strong>相同</strong>的路径称为回路；</li>
</ul>
</li>
<li><strong>无向图：</strong>图中的所有边都是<strong>没有</strong>方向的；</li>
<li><strong>有向图：</strong>图中的所有边都是<strong>有</strong>方向的；</li>
<li><strong>无权图：</strong>无权图中的边没有任何权重意义；</li>
<li><strong>带权图：</strong>带权图中的边有一定的权重含义；</li>
</ul>
<h3 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>表示图的常用方式为：<strong>邻接矩阵</strong>。</p>
<ul>
<li>可以使用二维数组来表示邻接矩阵；</li>
<li>邻接矩阵让<strong>每个节点和一个整数相关联</strong>，该<strong>整数作为数组的下标值</strong>；</li>
<li>使用一个<strong>二维数组</strong>来表示顶点之间的<strong>连接</strong>。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/1.png"></p>
<p>如上图所示：</p>
<ul>
<li>二维数组中的<strong>0</strong>表示没有连线，<strong>1</strong>表示有连线；</li>
<li>如：A[ 0 ] [ 3 ] = 1，表示 A 和 C 之间有连接；</li>
<li>邻接矩阵的对角线上的值都为0，表示A - A ，B - B，等自回路都没有连接（自己与自己之间没有连接）；</li>
<li>若为无向图，则邻接矩阵应为对角线上元素全为0的对称矩阵；</li>
</ul>
<p><strong>邻接矩阵的问题：</strong></p>
<ul>
<li>如果图是一个<strong>稀疏图</strong>，那么邻接矩阵中将存在<strong>大量的 0</strong>，造成存储空间的浪费。</li>
</ul>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>另外一种表示图的常用方式为：<strong>邻接表</strong>。</p>
<ul>
<li>邻接表由图中<strong>每个顶点</strong>以及<strong>和顶点相邻的顶点列表</strong>组成；</li>
<li>这个列表可用多种方式存储，比如：<strong>数组/链表/字典（哈希表）</strong>等都可以；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/2.png"></p>
<p>如上图所示：</p>
<ul>
<li>图中可清楚看到<strong>A与B、C、D相邻</strong>，假如要表示这些与A顶点相邻的顶点（边），可以通过将它们作为A的值（value）存入到对应的<strong>数组/链表/字典</strong>中。</li>
<li>之后，通过键（key）A可以十分方便地取出对应的数据；</li>
</ul>
<p><strong>邻接表的问题：</strong></p>
<ul>
<li>邻接表可以简单地得出<strong>出度</strong>，即某一顶点指向其他顶点的个数；</li>
<li>但是，邻接表计算<strong>入度</strong>（指向某一顶点的其他顶点的个数称为该顶点的入度）十分困难。此时需要构造<strong>逆邻接表</strong>才能有效计算入度；</li>
</ul>
<br>

<h3 id="封装图结构"><a href="#封装图结构" class="headerlink" title="封装图结构"></a>封装图结构</h3><blockquote>
<p>在实现过程中采用<strong>邻接表</strong>的方式来表示边，使用<strong>字典类</strong>来存储邻接表。</p>
</blockquote>
<h4 id="添加字典类和队列类"><a href="#添加字典类和队列类" class="headerlink" title="添加字典类和队列类"></a>添加字典类和队列类</h4><p>首先需要引入之前实现的，之后会用到的字典类和队列类:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//封装字典类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dictionary</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//字典属性</span></span><br><span class="line">  <span class="built_in">this</span>.items = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//字典操作方法</span></span><br><span class="line">  <span class="comment">//一.在字典中添加键值对</span></span><br><span class="line">  Dictionary.prototype.set = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.items[key] = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//二.判断字典中是否有某个key</span></span><br><span class="line">  Dictionary.prototype.has = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.hasOwnProperty(key)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//三.从字典中移除元素</span></span><br><span class="line">  Dictionary.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1.判断字典中是否有这个key</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.has(key)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.从字典中删除key</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.items[key]</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//四.根据key获取value</span></span><br><span class="line">  Dictionary.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.has(key) ? <span class="built_in">this</span>.items[key] : <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//五.获取所有keys</span></span><br><span class="line">  Dictionary.prototype.keys = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//六.size方法</span></span><br><span class="line">  Dictionary.prototype.keys = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.keys().length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//七.clear方法</span></span><br><span class="line">  Dictionary.prototype.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 基于数组封装队列类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">      <span class="built_in">this</span>.items = []</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="comment">// 1.将元素加入到队列中</span></span><br><span class="line">    Queue.prototype.enqueue = <span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.从队列中删除前端元素</span></span><br><span class="line">    Queue.prototype.dequeue = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.items.shift()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.查看前端的元素</span></span><br><span class="line">    Queue.prototype.front = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.查看队列是否为空</span></span><br><span class="line">    Queue.prototype.isEmpty = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.items.length == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.查看队列中元素的个数</span></span><br><span class="line">    Queue.prototype.size = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.items.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.toString方法</span></span><br><span class="line">    Queue.prototype.toString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> resultString = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> <span class="built_in">this</span>.items)&#123;</span><br><span class="line">          resultString += i + <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultString</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="0-创建图类"><a href="#0-创建图类" class="headerlink" title="0. 创建图类"></a>0. 创建图类</h4><p>先创建图类Graph，并添加基本属性，再实现图类的常用方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装图类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//属性：顶点(数组)/边(字典)</span></span><br><span class="line">  <span class="built_in">this</span>.vertexes = [];  <span class="comment">//顶点</span></span><br><span class="line">  <span class="built_in">this</span>.edges = <span class="keyword">new</span> Dictionary(); <span class="comment">//边</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-添加顶点与边"><a href="#1-添加顶点与边" class="headerlink" title="1. 添加顶点与边"></a>1. 添加顶点与边</h4><p>如图所示：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/3.png"></p>
<p>创建一个数组对象vertexes存储图的顶点；创建一个字典对象edges存储图的边，其中key为顶点，value为存储key顶点相邻顶点的数组。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加方法</span></span><br><span class="line"><span class="comment">//一.添加顶点</span></span><br><span class="line">Graph.prototype.addVertex = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.vertexes.push(v);</span><br><span class="line">  <span class="built_in">this</span>.edges.set(v, []); <span class="comment">//将边添加到字典中，新增的顶点作为键，对应的值为一个存储边的空数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二.添加边</span></span><br><span class="line">Graph.prototype.addEdge = <span class="function"><span class="keyword">function</span>(<span class="params">v1, v2</span>)</span>&#123;<span class="comment">//传入两个顶点为它们添加边</span></span><br><span class="line">  <span class="built_in">this</span>.edges.get(v1).push(v2);<span class="comment">//取出字典对象edges中存储边的数组，并添加关联顶点</span></span><br><span class="line">  <span class="built_in">this</span>.edges.get(v2).push(v1);<span class="comment">//表示的是无向表，故要添加互相指向的两条边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-转换为字符串输出"><a href="#2-转换为字符串输出" class="headerlink" title="2. 转换为字符串输出"></a>2. 转换为字符串输出</h4><p>为图类Graph添加toString方法，实现以邻接表的形式输出图中各顶点。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三.实现toString方法:转换为邻接表形式</span></span><br><span class="line">Graph.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.定义字符串，保存最终结果</span></span><br><span class="line">  <span class="keyword">let</span> resultString = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.遍历所有的顶点以及顶点对应的边</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.vertexes.length; i++) &#123;</span><br><span class="line">      <span class="comment">//遍历所有顶点</span></span><br><span class="line">    resultString += <span class="built_in">this</span>.vertexes[i] + <span class="string">&#x27;--&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> vEdges = <span class="built_in">this</span>.edges.get(<span class="built_in">this</span>.vertexes[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; vEdges.length; j++) &#123;</span><br><span class="line">        <span class="comment">//遍历字典中每个顶点对应的数组</span></span><br><span class="line">      resultString += vEdges[j] + <span class="string">&#x27;  &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    resultString += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resultString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"> <span class="comment">//1.创建图结构</span></span><br><span class="line"> <span class="keyword">let</span> graph = <span class="keyword">new</span> Graph();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//2.添加顶点</span></span><br><span class="line"> <span class="keyword">let</span> myVertexes = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>];</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; myVertexes.length; i++) &#123;</span><br><span class="line">   graph.addVertex(myVertexes[i]);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//3.添加边</span></span><br><span class="line"> graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line"> graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line"> graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line"> graph.addEdge(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line"> graph.addEdge(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;G&#x27;</span>);</span><br><span class="line"> graph.addEdge(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>);</span><br><span class="line"> graph.addEdge(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line"> graph.addEdge(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;E&#x27;</span>);</span><br><span class="line"> graph.addEdge(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;F&#x27;</span>);</span><br><span class="line"> graph.addEdge(<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;I&#x27;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//4.输出结果</span></span><br><span class="line"> <span class="built_in">console</span>.log(graph.toString());</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/4.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/4.png" alt="image-20200303233737451"></a></p>
<br>

<h4 id="3-图的遍历"><a href="#3-图的遍历" class="headerlink" title="3. 图的遍历"></a>3. 图的遍历</h4><p><strong>图的遍历思想：</strong></p>
<ul>
<li>图的遍历思想与树的遍历思想一样，意味着需要将图中<strong>所有的顶点</strong>都访问一遍，并且不能有<strong>重复的访问</strong>（上面的toString方法会重复访问）；</li>
</ul>
<p><strong>遍历图的两种算法：</strong></p>
<ul>
<li>广度优先搜索（Breadth - First Search，简称<strong>BFS</strong>）;</li>
<li>深度优先搜索（Depth - First Search，简称<strong>DFS</strong>）;</li>
<li>两种遍历算法都需要指定<strong>第一个被访问的顶点</strong>；</li>
</ul>
<p>为了记录顶点是否被访问过，使用<strong>三种颜色</strong>来表示它们的状态</p>
<ul>
<li><strong>白色</strong>：表示该顶点还没有被访问过；</li>
<li><strong>灰色</strong>：表示该顶点被访问过，但其相邻顶点并未完全被访问过；</li>
<li><strong>黑色</strong>：表示该顶点被访问过，且其所有相邻顶点都被访问过；</li>
</ul>
<p>首先封装initializeColor方法将图中的所有顶点初始化为白色，代码实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//四.初始化状态颜色</span></span><br><span class="line">Graph.prototype.initializeColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> colors = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.vertexes.length; i++) &#123;</span><br><span class="line">     colors[<span class="built_in">this</span>.vertexes[i]] = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> colors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h5><p>广度优先搜索算法的思路：</p>
<ul>
<li>广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻顶点，就像一次访问图的一层；</li>
<li>也可以说是<strong>先宽后深</strong>地遍历图中的各个顶点；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/5.png"></p>
<p><strong>实现思路：</strong></p>
<p>基于<strong>队列</strong>可以简单地实现广度优先搜索算法：</p>
<ul>
<li>首先创建一个队列Q（尾部进，首部出）；</li>
<li>调用封装的initializeColor方法将所有顶点初始化为白色；</li>
<li>指定第一个顶点A，将A标注为<strong>灰色</strong>（被访问过的节点），并将A放入队列Q中；</li>
<li>循环遍历队列中的元素，只要队列Q非空，就执行以下操作：<ul>
<li>先将灰色的A从Q的首部取出；</li>
<li>取出A后，将A的所有未被访问过（白色）的相邻顶点依次从队列Q的尾部加入队列，并变为灰色。以此保证，灰色的相邻顶点不重复加入队列；</li>
<li>A的全部相邻节点加入Q后，A变为黑色，在下一次循环中被移除Q外。</li>
</ul>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//五.实现广度搜索(BFS)</span></span><br><span class="line"><span class="comment">//传入指定的第一个顶点和处理结果的函数</span></span><br><span class="line">Graph.prototype.bfs = <span class="function"><span class="keyword">function</span>(<span class="params">initV, handler</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.初始化颜色</span></span><br><span class="line">  <span class="keyword">let</span> colors = <span class="built_in">this</span>.initializeColor();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.创建队列</span></span><br><span class="line">  <span class="keyword">let</span> que = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.将顶点加入到队列中</span></span><br><span class="line">  que.enqueue(initV);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4.循环从队列中取出元素，队列为空才停止</span></span><br><span class="line">  <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">    <span class="comment">//4.1.从队列首部取出一个顶点</span></span><br><span class="line">    <span class="keyword">let</span> v = que.dequeue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2.从字典对象edges中获取和该顶点相邻的其他顶点组成的数组</span></span><br><span class="line">    <span class="keyword">let</span> vNeighbours = <span class="built_in">this</span>.edges.get(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3.将v的颜色变为灰色</span></span><br><span class="line">    colors[v] = <span class="string">&#x27;gray&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.4.遍历v所有相邻的顶点vNeighbours,并且加入队列中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vNeighbours.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> a = vNeighbours[i];</span><br><span class="line">      <span class="comment">//判断相邻顶点是否被探测过，被探测过则不加入队列中；并且加入队列后变为灰色，表示被探测过</span></span><br><span class="line">      <span class="keyword">if</span> (colors[a] == <span class="string">&#x27;white&#x27;</span>) &#123;</span><br><span class="line">        colors[a] = <span class="string">&#x27;gray&#x27;</span>;</span><br><span class="line">        que.enqueue(a);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.5.处理顶点v</span></span><br><span class="line">    handler(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.6.顶点v所有白色的相邻顶点都加入队列后，将顶点v设置为黑色。此时黑色顶点v位于队列最前面，进入下一次while循环时会被取出</span></span><br><span class="line">    colors[v] = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>过程详解：</strong></p>
<p>下为指定的第一个顶点为A时的遍历过程：</p>
<ul>
<li>如 a 图所示，将在字典edges中取出的与A相邻的且未被访问过的白色顶点B、C、D放入队列que中并变为灰色，随后将A变为黑色并移出队列；</li>
<li>接着，如图 b 所示，将在字典edges中取出的与B相邻的且未被访问过的白色顶点E、F放入队列que中并变为灰色，随后将B变为黑色并移出队列；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/6.png"></p>
<ul>
<li>如 c 图所示，将在字典edges中取出的与C相邻的且未被访问过的白色顶点G（A，D也相邻不过已变为灰色，所以不加入队列）放入队列que中并变为灰色，随后将C变为黑色并移出队列；</li>
<li>接着，如图 d 所示，将在字典edges中取出的与D相邻的且未被访问过的白色顶点H放入队列que中并变为灰色，随后将D变为黑色并移出队列。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/7.png"></p>
<p>如此循环直到队列中元素为0，即所有顶点都变黑并移出队列后才停止，此时图中顶点已被全部遍历。</p>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建图结构</span></span><br><span class="line"><span class="keyword">let</span> graph = <span class="keyword">new</span> Graph();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.添加顶点</span></span><br><span class="line"><span class="keyword">let</span> myVertexes = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; myVertexes.length; i++) &#123;</span><br><span class="line">  graph.addVertex(myVertexes[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.添加边</span></span><br><span class="line">graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;I&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.测试bfs遍历方法</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;&quot;</span></span><br><span class="line">graph.bfs(graph.vertexes[<span class="number">0</span>], <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  result += v + <span class="string">&quot;-&quot;</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/8.png"></p>
<br>

<h5 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h5><p>广度优先算法的思路：</p>
<ul>
<li>深度优先搜索算法将会从指定的第一个顶点开始遍历图，沿着一条路径遍历直到该路径的最后一个顶点都被访问过为止；</li>
<li>接着沿原来路径回退并探索下一条路径，即<strong>先深后宽</strong>地遍历图中的各个顶点。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/9.png"></p>
<p><strong>实现思路：</strong></p>
<ul>
<li>可以使用<strong>栈</strong>结构来实现深度优先搜索算法；</li>
<li>深度优先搜索算法的遍历顺序与二叉搜索树中的先序遍历较为相似，同样可以使用<strong>递归</strong>来实现（递归的本质就是<strong>函数栈</strong>的调用）。</li>
</ul>
<p>基于递归实现深度优先搜索算法：定义dfs方法用于调用递归方法dfsVisit，定义dfsVisit方法用于递归访问图中的各个顶点。</p>
<p>在dfs方法中：</p>
<ul>
<li>首先，调用initializeColor方法将所有顶点初始化为白色；</li>
<li>然后，调用dfsVisit方法遍历图的顶点；</li>
</ul>
<p>在dfsVisit方法中：</p>
<ul>
<li>首先，将传入的指定节点v标注为<strong>灰色</strong>；</li>
<li>接着，处理顶点v；</li>
<li>然后，访问v的相邻顶点；</li>
<li>最后，将顶点v标注为黑色。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//六.实现深度搜索(DFS)</span></span><br><span class="line">Graph.prototype.dfs = <span class="function"><span class="keyword">function</span>(<span class="params">initV, handler</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.初始化顶点颜色</span></span><br><span class="line">  <span class="keyword">let</span> colors = <span class="built_in">this</span>.initializeColor();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.从某个顶点开始依次递归访问</span></span><br><span class="line">  <span class="built_in">this</span>.dfsVisit(initV, colors, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了方便递归调用，封装访问顶点的函数，传入三个参数分别表示：指定的第一个顶点、颜色、处理函数</span></span><br><span class="line">Graph.prototype.dfsVisit = <span class="function"><span class="keyword">function</span>(<span class="params">v, colors, handler</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.将颜色设置为灰色</span></span><br><span class="line">  colors[v] = <span class="string">&#x27;gray&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.处理v顶点</span></span><br><span class="line">  handler(v);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.访问V的相邻顶点</span></span><br><span class="line">  <span class="keyword">let</span> vNeighbours = <span class="built_in">this</span>.edges.get(v);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vNeighbours.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = vNeighbours[i];</span><br><span class="line">    <span class="comment">//判断相邻顶点是否为白色，若为白色，递归调用函数继续访问</span></span><br><span class="line">    <span class="keyword">if</span> (colors[a] == <span class="string">&#x27;white&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.dfsVisit(a, colors, handler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4.将v设置为黑色</span></span><br><span class="line">  colors[v] = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>过程详解：</strong></p>
<p>这里主要解释一下代码中的第3步操作：访问指定顶点的相邻顶点。</p>
<ul>
<li>以指定顶点A为例，先从储存顶点及其对应相邻顶点的字典对象edges中取出由顶点A的相邻顶点组成的数组：</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/10.png"></p>
<ul>
<li><strong>第一步</strong>：A顶点变为灰色，随后进入第一个for循环，遍历A白色的相邻顶点：B、C、D；在该for循环的第1次循环中（执行B），B顶点满足：colors == “white”，触发递归，重新调用该方法；</li>
<li><strong>第二步</strong>：B顶点变为灰色，随后进入第二个for循环，遍历B白色的相邻顶点：E、F；在该for循环的第1次循环中（执行E），E顶点满足：colors == “white”，触发递归，重新调用该方法；</li>
<li><strong>第三步</strong>：E顶点变为灰色，随后进入第三个for循环，遍历E白色的相邻顶点：I；在该for循环的第1次循环中（执行I），I顶点满足：colors == “white”，触发递归，重新调用该方法；</li>
<li><strong>第四步</strong>：I顶点变为灰色，随后进入第四个for循环，由于顶点I的相邻顶点E不满足：colors == “white”，停止递归调用。过程如下图所示：</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/11.png"></p>
<ul>
<li><strong>第五步</strong>：递归结束后一路向上返回，首先回到第三个for循环中继续执行其中的第2、3…次循环，每次循环的执行过程与上面的同理，直到递归再次结束后，再返回到第二个for循环中继续执行其中的第2、3…次循环….以此类推直到将图的所有顶点访问完为止。</li>
</ul>
<p>下图为遍历图中各顶点的完整过程：</p>
<ul>
<li><strong>发现</strong>表示访问了该顶点，状态变为<strong>灰色</strong>；</li>
<li><strong>探索</strong>表示既访问了该顶点，也访问了该顶点的全部相邻顶点，状态变为<strong>黑色</strong>；</li>
<li>由于在顶点变为灰色后就调用了处理函数handler，所以handler方法的输出顺序为发现顶点的顺序即：A、B、E、I、F、C、D、G、H 。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/12.png"></p>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建图结构</span></span><br><span class="line"><span class="keyword">let</span> graph = <span class="keyword">new</span> Graph();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.添加顶点</span></span><br><span class="line"><span class="keyword">let</span> myVertexes = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; myVertexes.length; i++) &#123;</span><br><span class="line">  graph.addVertex(myVertexes[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.添加边</span></span><br><span class="line">graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;I&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.测试dfs遍历顶点</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">graph.dfs(graph.vertexes[<span class="number">0</span>], <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  result += v + <span class="string">&quot;-&quot;</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/13.png"></p>
<h4 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装图结构</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//属性：顶点(数组)/边(字典)</span></span><br><span class="line">  <span class="built_in">this</span>.vertexes = [];  <span class="comment">//顶点</span></span><br><span class="line">  <span class="built_in">this</span>.edges = <span class="keyword">new</span> Dictionary(); <span class="comment">//边</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法</span></span><br><span class="line">  <span class="comment">//添加方法</span></span><br><span class="line">  <span class="comment">//一.添加顶点</span></span><br><span class="line">  Graph.prototype.addVertex = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.vertexes.push(v);</span><br><span class="line">    <span class="built_in">this</span>.edges.set(v, []); <span class="comment">//将边添加到字典中，新增的顶点作为键，对应的值为一个存储边的空数组</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//二.添加边</span></span><br><span class="line">  Graph.prototype.addEdge = <span class="function"><span class="keyword">function</span>(<span class="params">v1, v2</span>)</span>&#123;<span class="comment">//传入两个顶点为它们添加边</span></span><br><span class="line">    <span class="built_in">this</span>.edges.get(v1).push(v2);<span class="comment">//取出字典对象edges中存储边的数组，并添加关联顶点</span></span><br><span class="line">    <span class="built_in">this</span>.edges.get(v2).push(v1);<span class="comment">//表示的是无向表，故要添加互相指向的两条边</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//三.实现toString方法:转换为邻接表形式</span></span><br><span class="line">  Graph.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1.定义字符串，保存最终结果</span></span><br><span class="line">    <span class="keyword">let</span> resultString = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.遍历所有的顶点以及顶点对应的边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.vertexes.length; i++) &#123;<span class="comment">//遍历所有顶点</span></span><br><span class="line">      resultString += <span class="built_in">this</span>.vertexes[i] + <span class="string">&#x27;--&gt;&#x27;</span>;</span><br><span class="line">      <span class="keyword">let</span> vEdges = <span class="built_in">this</span>.edges.get(<span class="built_in">this</span>.vertexes[i]);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; vEdges.length; j++) &#123;<span class="comment">//遍历字典中每个顶点对应的数组</span></span><br><span class="line">        resultString += vEdges[j] + <span class="string">&#x27;  &#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      resultString += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultString;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//四.初始化状态颜色</span></span><br><span class="line">  Graph.prototype.initializeColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> colors = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.vertexes.length; i++) &#123;</span><br><span class="line">       colors[<span class="built_in">this</span>.vertexes[i]] = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> colors;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//五.实现广度搜索(BFS)</span></span><br><span class="line">  <span class="comment">//传入指定的第一个顶点和处理结果的函数</span></span><br><span class="line">  Graph.prototype.bfs = <span class="function"><span class="keyword">function</span>(<span class="params">initV, handler</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1.初始化颜色</span></span><br><span class="line">    <span class="keyword">let</span> colors = <span class="built_in">this</span>.initializeColor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建队列</span></span><br><span class="line">    <span class="keyword">let</span> que = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.将顶点加入到队列中</span></span><br><span class="line">    que.enqueue(initV);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.循环从队列中取出元素</span></span><br><span class="line">    <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">      <span class="comment">//4.1.从队列中取出一个顶点</span></span><br><span class="line">      <span class="keyword">let</span> v = que.dequeue();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.2.获取和顶点相相邻的其他顶点</span></span><br><span class="line">      <span class="keyword">let</span> vNeighbours = <span class="built_in">this</span>.edges.get(v);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.3.将v的颜色变为灰色</span></span><br><span class="line">      colors[v] = <span class="string">&#x27;gray&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.4.遍历v所有相邻的顶点vNeighbours,并且加入队列中</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vNeighbours.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> a = vNeighbours[i];</span><br><span class="line">        <span class="comment">//判断相邻顶点是否被探测过，被探测过则不加入队列中；并且加入队列后变为灰色，表示被探测过</span></span><br><span class="line">        <span class="keyword">if</span> (colors[a] == <span class="string">&#x27;white&#x27;</span>) &#123;</span><br><span class="line">          colors[a] = <span class="string">&#x27;gray&#x27;</span>;</span><br><span class="line">          que.enqueue(a);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.5.处理顶点v</span></span><br><span class="line">      handler(v);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.6.顶点v所有白色的相邻顶点都加入队列后，将顶点v设置为黑色。此时黑色顶点v位于队列最前面，进入下一次while循环时会被取出</span></span><br><span class="line">      colors[v] = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//六.实现深度搜索(DFS)</span></span><br><span class="line">  Graph.prototype.dfs = <span class="function"><span class="keyword">function</span>(<span class="params">initV, handler</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1.初始化顶点颜色</span></span><br><span class="line">    <span class="keyword">let</span> colors = <span class="built_in">this</span>.initializeColor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.从某个顶点开始依次递归访问</span></span><br><span class="line">    <span class="built_in">this</span>.dfsVisit(initV, colors, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//为了方便递归调用，封装访问顶点的函数，传入三个参数分别表示：指定的第一个顶点、颜色、处理函数</span></span><br><span class="line">  Graph.prototype.dfsVisit = <span class="function"><span class="keyword">function</span>(<span class="params">v, colors, handler</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1.将颜色设置为灰色</span></span><br><span class="line">    colors[v] = <span class="string">&#x27;gray&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.处理v顶点</span></span><br><span class="line">    handler(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.访问v相连的其他顶点</span></span><br><span class="line">    <span class="keyword">let</span> vNeighbours = <span class="built_in">this</span>.edges.get(v)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vNeighbours.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> a = vNeighbours[i];</span><br><span class="line">      <span class="comment">//判断相邻顶点是否为白色，若为白色，递归调用函数继续访问</span></span><br><span class="line">      <span class="keyword">if</span> (colors[a] == <span class="string">&#x27;white&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.dfsVisit(a, colors, handler);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.将v设置为黑色</span></span><br><span class="line">    colors[v] = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2021/01/19/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2021/01/09/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Javascript数据结构与算法（1）</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "DxjdVENjKn4OPt6wHb07UtxP-gzGzoHsz",
    app_key: "J0hPK8lUjl1jMLcupB2S7Gws",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2021
        <i class="ri-heart-fill heart_icon"></i> Lu xiuyuan
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="路修远"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/photos">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2020/12/30/%E6%95%A3%E8%AF%97">诗集</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=28718313&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>