<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="路修远,博客,ayer,学习笔记,前端,萌新" />
   
  <meta name="description" content="路修远个人博客,前端萌新" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    Javascript红宝书学习笔记（3） |  路修远
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="路修远" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-h红宝书学习笔记第五章"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Javascript红宝书学习笔记（3）
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/03/18/h%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%94%E7%AB%A0/" class="article-date">
  <time datetime="2021-03-18T11:54:08.000Z" itemprop="datePublished">2021-03-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a> / <a class="article-category-link" href="/categories/JavaScript/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a> / <a class="article-category-link" href="/categories/JavaScript/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">6.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">24 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第五章：基本引用类型"><a href="#第五章：基本引用类型" class="headerlink" title="第五章：基本引用类型"></a>第五章：基本引用类型</h1><p>引用值（或者对象）是某个特定<strong>引用类型</strong>的<strong>实例</strong>。新对象通过使用new操作符后跟一个构造函数（constructor）来创建。</p>
<a id="more"></a>

<h2 id="5-1-Date"><a href="#5-1-Date" class="headerlink" title="5.1 Date"></a>5.1 Date</h2><blockquote>
<p>这里不对Date进行详细深入，仅基于书本列出一些常用方法。更多方法和用法请参考：<a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-obj-date.html%E3%80%82">https://www.runoob.com/jsref/jsref-obj-date.html。</a></p>
</blockquote>
<p>1）基于其他其他日期和时间创建日期对象：</p>
<p><code>Date.parse</code>  和  <code>Date.UTC</code></p>
<p><code>Date.now</code> 返回表示方法执行日期和时间的毫秒数。</p>
<p>2）继承的方法：</p>
<p>Date类型重写了 <code>toLocaleString()</code> 、<code>toString()</code> 、<code>valueOf()</code> 方法。</p>
<ul>
<li><p> <code>toLocaleString()</code> 方法返回与浏览器运行的本地环境一致的日期和时间。</p>
</li>
<li><p> <code>toString()</code> 方法通常返回带时区信息的日期和时间。</p>
</li>
<li><p> <code>valueOf</code> 被重写后返回的是日期的毫秒表示。</p>
</li>
</ul>
<p>3）日期格式化方法：</p>
<p>Date类型有几个专门用于格式化日期的方法，它们都会返回字符串：</p>
<ul>
<li><p><code>toDateString() </code>显示日期中的周几、月、日、年(格式特定于实现)；</p>
</li>
<li><p><code>toTimeString()</code> 显示日期中的时、分、秒和时区(格式特定于实现)；</p>
</li>
<li><p><code>toLocaleDateString()</code> 显示日期中的周几、月、日、年(格式特定于实现和地区)；tolocaleTimeString()显示日期中的时、分、秒(格式特定于实现)；</p>
</li>
<li><p><code>toUTCString()</code> 显示完整的UTC日期(格式特定于实现)。</p>
</li>
</ul>
<p>这些方法的输出与tolocaleString()和 tostring()一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。</p>
<blockquote>
<p>注意 还有一个方法叫 <code>toGMTString()</code>，这个方法跟 <code>toUTCString()</code> 是一样的，目的<br>是为了向后兼容。不过，规范建议新代码使用 <code>toUTCString()</code>。 </p>
</blockquote>
<p>4）日期/时间组件方法。</p>
<br>

<h2 id="5-2-RegExp"><a href="#5-2-RegExp" class="headerlink" title="5.2 RegExp `"></a>5.2 RegExp `</h2><p>ECMAScript通过RegExp类型支持正则表达式。正则表达式使用类似Perl的简洁语法来创建：</p>
<p><code>let expression = /pattern/flags;</code></p>
<p>这个正则表达式的pattern(模式)可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带零个或多个 flags(标记)，用于控制正则表达式的行为。下面给出了表示匹配模式的标记。</p>
<ul>
<li><p>g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。</p>
</li>
<li><p>i：不区分大小写，表示在查找匹配时忽略pattern和字符串的大小写。</p>
</li>
<li><p>m：多行模式，表示查找到一行文本末尾时会继续查找。</p>
</li>
<li><p>y：粘附模式，表示只查找从1astIndex开始及之后的字符串。</p>
</li>
<li><p>u：Unicode模式，启用Unicode匹配。</p>
</li>
<li><p>s：dotA11模式，表示元字符，匹配任何字符(包括\n或\r)。</p>
</li>
</ul>
<h3 id="5-2-1-RegExp实例属性"><a href="#5-2-1-RegExp实例属性" class="headerlink" title="5.2.1 RegExp实例属性"></a>5.2.1 RegExp实例属性</h3><p>每个RegExp实例都有下列属性，提供有关模式的各方面信息。</p>
<p>+　global：布尔值，表示是否设置了g标记。</p>
<p>+　ignoreCase：布尔值，表示是否设置了1标记。</p>
<p>+　unicode：布尔值，表示是否设置了u标记。</p>
<p>+　sticky：布尔值，表示是否设置了y标记</p>
<p>+　astIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。</p>
<p>+　multiline：布尔值，表示是否设置了m标记。</p>
<p>+　dotA11：布尔值，表示是否设置了。标记。</p>
<p>+　source：正则表达式的字面量字符串(不是传给构造函数的模式字符串)，没有开头和结尾的斜杠。</p>
<p>+　f1ags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回(没5有前后斜杠)。</p>
<p>通过这些属性可以全面了解正则表达式的信息，不过实际开发中用得并不多，因为模式声明中包含这些信息。</p>
<h3 id="5-2-2-实例方法"><a href="#5-2-2-实例方法" class="headerlink" title="5.2.2 实例方法"></a>5.2.2 实例方法</h3><p>1）<code>exex()</code></p>
<p>Regexp实例的主要方法是 <code>exec()</code> ，主要用于配合<strong>捕获组</strong>使用。</p>
<p>这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一不匹配信息的数组；如果没找到匹配项，则返回null。</p>
<p>返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。index是字符串中匹配模式的起始位置，input是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素。</p>
<blockquote>
<p>这里不再继续讨论 <code>exec()</code> 方法的使用，可以自行百度详细用法。或者这里我搜了两篇说的还不错的文章：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35087256/article/details/79966865">https://blog.csdn.net/qq_35087256/article/details/79966865</a> | <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018864720">https://segmentfault.com/a/1190000018864720</a></p>
</blockquote>
<p>2）<code>test()</code></p>
<p>正则表达式的另一个方法是 <code>test()</code>，接收一个字符串参数。如果输入的文本与模式匹配，则参数返回true，否则返回false。</p>
<p>这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。<code>test()</code> 经常用在if语句中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text =<span class="string">&quot;000-00-0000°;</span></span><br><span class="line"><span class="string">let pattern/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/；</span></span><br><span class="line"><span class="string">if (pattern.test(text))</span></span><br><span class="line"><span class="string">    console.log (&quot;</span>The pattern was matched.<span class="string">&quot;);</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，正达式用于测试特定的数值序列。如果输入的文本与模式匹配，则显示匹配成功的消息。这个用法常用于验证用户输入，此时我们只在乎输入是否有效，不关心为什么无效。</p>
<p>无论正则表达式是怎么创建的，继承的方法 <code>toLocaleString()</code> 和 <code>toString()</code>都返回正则表达式的字面量表示。</p>
<blockquote>
<p>注意：正则表达式的 <code>valueOf()</code>方法返回正则表达式本身。 </p>
</blockquote>
<h3 id="5-2-3-RegExp构造函数属性"><a href="#5-2-3-RegExp构造函数属性" class="headerlink" title="5.2.3 RegExp构造函数属性"></a>5.2.3 RegExp构造函数属性</h3><blockquote>
<p>这里不进行讨论。</p>
</blockquote>
<blockquote>
<p>注意：RegExp构造函数的所有属性都没有任何Web标准出处，因此不要在生成环境中使用它们。</p>
</blockquote>
<br>

<h2 id="5-3-原始值包装类型"><a href="#5-3-原始值包装类型" class="headerlink" title="5.3 原始值包装类型"></a>5.3 原始值包装类型</h2><p>为了方便操作原始值，ECMAScript提供了3种特殊的引用类型：Boolean、Number和String。</p>
<p>这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sl = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = sl.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>在这里，s1是一个包含字符串的变量，它是一个原始值。第二行紧接着在s1上调用了substring()方法，并把结果保存在s2中。我们知道，<strong>原始值本身不是对象，因此逻辑上不应该有方法</strong>。而实际上这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作。具体来说，当第二行访问s1时，是以读模式访问的，也就是要从内存中读取变量保存的值。</p>
<p>在以读模式访问字符串值的任何时候，后台都会执行以下3步：</p>
<ol>
<li><p><strong>创建一个string类型的实例；</strong></p>
</li>
<li><p><strong>调用实例上的特定方法；</strong></p>
</li>
<li><p><strong>销毁实例。</strong></p>
</li>
</ol>
<p>可以把这3步想象成执行了如下3行ECMAScript代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>这种行为可以<strong>让原始值拥有有对象的行为</strong>，对布尔值和数值而言，以上3步也会在后台发生，只不过使用的是Boolean和Number包装类型而已。</p>
<p><strong>引用类型与原始值包装类型的主要区别在于对象的生命周期</strong>，<strong>在通过new实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访同它的那行代码执行期间。</strong></p>
<p><strong>这意味着不能在运行时给原始值添加属性和方法</strong>。比如下面的倒子：</p>
<p>可以显式地使用Boolean、Number和string构造函数创建原始值包装对象。不过应该在确实必要时再这么做，否则容易让开发者疑惑，分不清它们到底是原始值还是引用值。在原始值包装类型的实例上调用 <code>typeof</code> 会返回object，<strong>所有原始值包装对象都会转换为布尔值true</strong>。</p>
<p>另外，Object 构透函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span> (<span class="string">&quot;sometext&quot;</span>)；</span><br><span class="line"><span class="built_in">console</span>.log(obj intanceof string); <span class="comment">//-&gt; true</span></span><br><span class="line"><span class="comment">//如果传给Object的是字符串，则会创建一个String的实例。如果是数值，则会创建Number的实例。布尔值则会得到Boolean的实例。</span></span><br></pre></td></tr></table></figure>
<p>注意，<strong>使用new调用原始值包装类型的构造函数，与调用同名的转型函数并不一样</strong>。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="string">&quot;25&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> number = <span class="built_in">Number</span>(value); <span class="comment">// 转型函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> number), <span class="comment">//-&gt; &quot;number”</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value); <span class="comment">// 构造函數</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj); <span class="comment">//-&gt; &quot;object&quot;</span></span><br></pre></td></tr></table></figure>
<p>虽然不推荐显式创建原始值包装类型的实例，但它们对于操作原始值的功能是很重要的。每个原值包装类型都有相应的一套方法来方便数据操作</p>
<h3 id="5-3-1-Boolean"><a href="#5-3-1-Boolean" class="headerlink" title="5.3.1 Boolean"></a>5.3.1 Boolean</h3><p>Boolean是对应布尔值的引用类型。要创建一个Boolean对象，就使用Boolean构造函数并传true或false，如下例所示：</p>
<p><code>let booleanobject = new Boolean(true);</code></p>
<p>Boolean 的实例会重写 <code>valueOf()</code>方法，返回一个原始值true 或 false。<code>toString()</code>方法被调用时也会被覆盖，返回字符串”true”或”false”。不过，Boolean对象在ECMAScript中用得很少。不仅如此，它们还容易引起误会，尤其是在布尔表达式中使用Boolean对象时。</p>
<p>除此之外，原始值和引用值(Boolean对象)还有几个区别。首先，<code>typeof</code>操作符对原始值返回“boolean”，但对引用值返回“object”。同样，Boolean对象是 Boolean 类型的实例，在使用 <code>instanceof</code> 操作符时返回true，但对原始值则返回false，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseObject); <span class="comment">//-&gt; object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseValue);  <span class="comment">//-&gt; boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(falseObject <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);  <span class="comment">//-&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(falseValue <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>): <span class="comment">//-&gt; false</span></span><br></pre></td></tr></table></figure>
<p><strong>理解原始布尔值和Boolean对象之间的区别非常重要，强烈建议永远不要使用后者</strong>。</p>
<h3 id="5-3-2-Number"><a href="#5-3-2-Number" class="headerlink" title="5.3.2 Number `"></a>5.3.2 Number `</h3><p>Number是对应数值的引用类型。要创建一个Number对象，就使用Number构造函数并传入一个数值，如下例所示：</p>
<p><code>let NumberObject = new Number(10);</code></p>
<h4 id="1）继承的方法："><a href="#1）继承的方法：" class="headerlink" title="1）继承的方法："></a>1）继承的方法：</h4><p>与Boolean 类型一样，Number 类型重写了 <code>valueOf()</code> 、<code>totocalestring()</code> 和<code> toString()</code> 方法。</p>
<p><code>valueOf()</code>方法返回Number对象表示的原始数值，另外两个方法返回数值字符串。</p>
<p><code>toString()</code> 方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串。</p>
<h4 id="2）将数值格式化为字符串的方法："><a href="#2）将数值格式化为字符串的方法：" class="headerlink" title="2）将数值格式化为字符串的方法："></a>2）将数值格式化为字符串的方法：</h4><p><code>toFixed()</code> 方法返回包含指定小数点位数的数值字符串，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>));  <span class="comment">//-&gt; &quot;10.00&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位。这个特点可以用于处理货币。但是要注意，多个浮点数值的数学计算不一定得到精确的结果。</p>
<blockquote>
<p> 注意：<code>toFixed()</code>方法可以表示有0-20个小数位的数值。某些浏览器可能支持更大的范围，但这是通常被支持的范围。</p>
</blockquote>
<p><code>toExponential()</code>，返回以科学记数法(也称为指数记数法)表示的数值字符串。与<code>toFixed()</code>一样，该方法也接收一个参数，表示结果中小数的位。</p>
<p><code>toPrecision()</code>方法会给根据情况返回最合理的验出结果。可能是固定长度，也可能是科学记数形式。这个方法接收一个参数，表示结果中数字的总位数(不包含指数)。来看几个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">99</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toprecision(<span class="number">1</span>));  <span class="comment">//-&gt; &quot;1e+2&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">2</span>));  <span class="comment">//-&gt; &quot;99&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">3</span>));  <span class="comment">//-&gt; &quot;99.0&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，首先要用1位数字表示数值99，得到“1e+2”，也就是100。因为99不能只用1数字来精确表示，所以这个方法就将它舍入为100，这样就可以只用1位数字（及其科学记数法形式）来表示了。</p>
<p>用2位数字表示99得到“99”，用3位数字则是“99.0”。本质上，<code>toPrecision()</code> 方法根据数值和精度来决定调用<code>toFixed()</code>还是<code>toExponentia1()</code>。为了以正确的小数位精确表示数值，这3个方法都会向上或向下s舍入。</p>
<blockquote>
<p>注意 <code>toprecisionl()</code>方法可以表示带1-21个小数位的数值。某些浏览器可能支持更大的范围，但这是通常被支持的范围。</p>
</blockquote>
<h4 id="3）-isInteger-方法与安全整数"><a href="#3）-isInteger-方法与安全整数" class="headerlink" title="3）**isInteger() 方法与安全整数** *"></a>3）**<code>isInteger()</code> 方法与安全整数** *</h4><p>ES6新增了 <code>Number.isInteger()</code> 方法，用于辨别一个数值是否保存为整数。</p>
<p>IEEE 754数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。这个数值范围从<code>Number.MIN_SAFE_INTEGER</code> (-2^53+1) 到 <code>Number.MAX_SAFE_INTEGER</code> (2^53-1)。对超出这个范围的数值，即使尝试保存为整数，IEEE754 编码格式也意味着二进制值可能会表示一个完全不同的数值。为了鉴别整数是否在这个范围内，可以使用 <code>Number.isSafeInteger()</code>方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(-<span class="number">1</span> * (<span class="number">2</span> ** <span class="number">53</span>)));  <span class="comment">//-&gt;  false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(-<span class="number">1</span> * (<span class="number">2</span> ** <span class="number">53</span>) + <span class="number">1</span>));  <span class="comment">//-&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(<span class="number">2</span> ** <span class="number">53</span>)); <span class="comment">//-&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger((<span class="number">2</span> ** <span class="number">53</span>) - <span class="number">1</span>)); <span class="comment">//-&gt; true</span></span><br></pre></td></tr></table></figure>
<br>

<h3 id="5-3-3-String"><a href="#5-3-3-String" class="headerlink" title="5.3.3 String `"></a>5.3.3 String `</h3><p>String 是对应字符串的引用类型。要创建一个String对象，使用String构造函数并传入一个数值，如下例所示：</p>
<p><code>let stringobject = new String(hello wor1d&quot;);</code></p>
<p><strong>String对象的方法可以在所有字符串原始值上调用</strong>。3个继承的方法 <code>valueOf()</code>、<code>toLocaleString()</code>和<code>toString()</code>都返回对象的原始字符串值。每个String对象都有一个1ength属性，表示字符串中字符的数量。</p>
<h4 id="1-JavaScript字符"><a href="#1-JavaScript字符" class="headerlink" title="1. JavaScript字符"></a>1. JavaScript字符</h4><p>1）<strong>16位码元字符</strong></p>
<p>JavaScript字符串由<strong>16位码元</strong>(code unit)组成。对多数字符来说，每16位码元对应一个字符。换句话说，字符串的 <code>1ength</code>属性表示字符串包含多少16位码元；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message =<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.length); <span class="comment">//-&gt; 5</span></span><br></pre></td></tr></table></figure>
<p><code>charAt ()</code> 方法返回给定索引位置的字符，由传给方法的整数参数指定。具体来说，这个方法查找指定索引位置的16位码元，并返回该码元对应的字符。</p>
<p> <code>charCodeAt()</code>为法可以查看指定码元的字将编码码，这个方法返回指定索引位置的码元值，索引以整数指定：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&#x27;abcde&#x27;</span>;</span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter C&quot; 的编码是 U+0063</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">2</span>));  <span class="comment">//-&gt; 99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//十进制 99 等于十六进制 63</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">99</span> === <span class="number">0x63</span>); <span class="comment">//-&gt; true</span></span><br></pre></td></tr></table></figure>
<p><code>fromcharCode()</code>方法用于根据价定的UTF-16码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符申：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Unicode &quot;Latin small letter a&quot; 的编码是 U+0061</span></span><br><span class="line"><span class="comment">//Unicode &quot;Latin small letter b&quot; 的编码是 U+0062</span></span><br><span class="line"><span class="comment">//Unicode &quot;Latin small letter C&quot; 的编码是 U+0063</span></span><br><span class="line"><span class="comment">//Unicode &quot;Latin small letter d&quot; 的编码是 U+0064</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x61</span>,<span class="number">0x62</span>,<span class="number">0x63</span>,<span class="number">0x64</span>));  <span class="comment">//-&gt; abcd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//0x0061 === 97</span></span><br><span class="line"><span class="comment">//0x0062 === 98</span></span><br><span class="line"><span class="comment">//0x0063 === 99</span></span><br><span class="line"><span class="comment">//0x0064 === 100</span></span><br><span class="line"><span class="built_in">console</span>.log (<span class="built_in">String</span>.fromCharCode(<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>); <span class="comment">//-&gt; abcd</span></span><br></pre></td></tr></table></figure>
<p><em>JavaScript字符串使用了两种Unicode编码混合的策略：UCS-2和UTF-16。对于可以采用16位编码的字符(U+0000 ~ U+FFFF)，这两种编码实际上是一样的。</em></p>
<p>2）<strong>代理对</strong></p>
<p>对于U+0000-U+FFFF范围内的字符，<code>length</code>、 <code>charAt()</code>、<code>charCodeAt()</code>和 <code>fromCharCode()</code> 返回的结果都跟预期是一样的。这是因为在这个范围内，每个字符都是用16位表示的，而这几个方法也都基于16位码元完成操作。只要字符编码大小与码元大小一一对应，这些方法就能如期工作。</p>
<p>这个对应关系在扩展到 Unicode增补字符平面时就不成立了。问题很简单，即16位只能唯一表示<strong>65536</strong>个字符。这对于大多数语言字符集是足够了，在 Unicode中称为<strong>基本多语言平面</strong>(BMP)。为了表示更多的字符，Unicode采用了一个策略，即每个字符使用另外16位去选择一个<strong>增补平面</strong>。</p>
<p>这种<strong>每字符使用两个16位码元</strong>的策略称为<strong>代理对</strong>。</p>
<p>在涉及增补平面的字符时，前面讨论的字符串方法就会出问题。比如，下面的例子中使用了一个笑脸表情符号，也就是一个使用代理对编码的字符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&quot;smiling face with smiling eyes&quot;表情符号的編码是 U+1F60A</span></span><br><span class="line"><span class="comment">//0x1F60A === 128522</span></span><br><span class="line"><span class="keyword">let</span> message=<span class="string">&quot;ab☻de&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.length); <span class="comment">//-&gt; 6</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charAt(<span class="number">1</span>)); <span class="comment">//-&gt; b</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charAt(<span class="number">2</span>)); <span class="comment">//-&gt; &lt;?&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charAt(<span class="number">3</span>)); <span class="comment">//-&gt; &lt;?&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charAt(<span class="number">4</span>)); <span class="comment">//-&gt; d</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">1</span>)); <span class="comment">//-&gt; 98</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">2</span>)); <span class="comment">//-&gt; 55357</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">3</span>)); <span class="comment">//-&gt; 56842</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">4</span>)); <span class="comment">//-&gt; 100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">0x1F60A</span>));  <span class="comment">//-&gt; ☻</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">97</span>,<span class="number">98</span>,<span class="number">55357</span>,<span class="number">56842</span>,<span class="number">100</span>,<span class="number">101</span>)); <span class="comment">//-&gt; ab☻de</span></span><br></pre></td></tr></table></figure>
<p>这些方法仍然将16位码元当作一个字符，事实上<strong>索引2和索引3对应的码元应该被看成一个代理对，只对应一个字符</strong>。<code>fromCharCode()</code>方法仍然返回正确的结果，因为它实际上是基于提供的二进制表示直接组合成字符串。浏览器可以正确解析代理对(由两个码元构成)，并正确地将其识别为一个Unicode笑脸字符。</p>
<p>为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用 <code>codePointAt()</code> 来代替 <code>charCodeAt()</code> 。跟使用<code>charCodeAt()</code>时类似，<code>codePointAt()</code> 接收16位码元的索引并返回该索引位置上的码点(code point)。码点是Unicode中一个字符的完整标识。比如，“ c ”的码点是0x0063，而“ ☻ ”的码点是0x1F60A。码点可能是16位，也可能是32位，而 <code>codePointAt()</code>方法可以从指定码元位置识别完整的码点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;ab☻de&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.codePointAt(<span class="number">1</span>));  <span class="comment">//-&gt; 98</span></span><br><span class="line"><span class="built_in">console</span>.log(message.codePointAt(<span class="number">2</span>));  <span class="comment">//-&gt; 128522</span></span><br><span class="line"><span class="built_in">console</span>.log(measage.codePointAt(<span class="number">3</span>));  <span class="comment">//-&gt; 56842</span></span><br><span class="line"><span class="built_in">console</span>.log(message.codePointAt(<span class="number">4</span>));  <span class="comment">//-&gt; 100</span></span><br></pre></td></tr></table></figure>
<p>注意，如果传入的码元索引并非代理对的开头，就会返回错误的码点。这种错误只有检测单个字的时候才会出现，可以通过从左到右按正确的码元数遍历字符串来规避。迭代字符串可以智能地识别理对的码点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([...<span class="string">&quot;ab☻de&quot;</span>]);  <span class="comment">//-&gt; [&quot;a&quot;,&quot;b&quot;,&quot;☻&quot;,&quot;d&quot;,&quot;e&quot;]</span></span><br></pre></td></tr></table></figure>
<p><code>fromCharCode()</code>也有一个对应的 <code>fromcodePoint()</code>。 这个方法接收任意数量的码点，返回对应字符拼接起来的字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">97</span>,<span class="number">98</span>,<span class="number">55357</span>,<span class="number">56842</span>,<span class="number">100</span>,<span class="number">101</span>));  <span class="comment">//-&gt; ab☻de </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">97</span>,<span class="number">98</span>,<span class="number">128522</span>,<span class="number">100</span>,<span class="number">101</span>));  <span class="comment">//-&gt; ab☻de</span></span><br></pre></td></tr></table></figure>


<h4 id="2-normalize-方法"><a href="#2-normalize-方法" class="headerlink" title="2. normalize()方法"></a>2. normalize()方法</h4><p>某些 Unicode字符可以有多种编码方式。有的字符既可以通过一个BMP字符表示，也可以通过代理对表示。</p>
<blockquote>
<p>该方法主要是为字符串应用四种规范化形式：NFD、NFC，NFKD和NFKC。至于这四种形式具体含义和该方法的使用，因为应用情况的罕见这里不作总结。可以自行百度了解。</p>
</blockquote>
<h4 id="3-字符串操作方法"><a href="#3-字符串操作方法" class="headerlink" title="3. 字符串操作方法"></a>3. 字符串操作方法</h4><p><code>concat()</code> 用于将一个或多个字符串拼接成一个新字符串。</p>
<p><code>slice()</code>、<code>substr()</code>、<code>subString()</code> 用于从字符串中提取子字符串。</p>
<h4 id="4-字符串位置方法"><a href="#4-字符串位置方法" class="headerlink" title="4. 字符串位置方法"></a>4. 字符串位置方法</h4><p><code>indexOf()</code> 和 <code>lastIndexOf()</code> 用于在字符串中定位子字符串。</p>
<h4 id="5-字符串包含方法"><a href="#5-字符串包含方法" class="headerlink" title="5. 字符串包含方法 *"></a>5. 字符串包含方法 *</h4><p>ES6新增了3个用于判断字符串中是否包含另一个字符串的方法：<code>startsWith()</code> 、 <code>endWith()</code> 和 <code>includes()</code>。</p>
<h4 id="6-trim-方法"><a href="#6-trim-方法" class="headerlink" title="6. trim()方法"></a>6. trim()方法</h4><p>ECMAScript在所有字符串上都提供了 <code>trim()</code> 方法。这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果。原始字符串不会受影响。</p>
<p><code>trimLeft()</code> 和 <code>trimRight()</code> 方法分别用于从字符串开始和结尾清理空格符。</p>
<h4 id="7-repeat-方法"><a href="#7-repeat-方法" class="headerlink" title="7. repeat()方法"></a>7. repeat()方法</h4><p>ECMAScript在所有字符串上都提供了 <code>repeat()</code> 方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。</p>
<h4 id="8-padStart-和-padEnd-方法"><a href="#8-padStart-和-padEnd-方法" class="headerlink" title="8. padStart() 和 padEnd() 方法"></a>8. padStart() 和 padEnd() 方法</h4><p> <code>padStart()</code> 和 <code>padEnd()</code> 方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（U+0020）。</p>
<h4 id="9-字符串迭代与解构"><a href="#9-字符串迭代与解构" class="headerlink" title="9. 字符串迭代与解构"></a>9. 字符串迭代与解构</h4><p>字符中的原型上暴露了一个<code>@@iterator</code>方法，表示可以迭代字符串的每个字符。可以像下面这样手动使用迭代器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> stringIterator = message[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());  <span class="comment">//-&gt; (value:&quot;a&quot;, done:false)</span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());  <span class="comment">//-&gt; (value:&quot;b&quot;, done:false)</span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());  <span class="comment">//-&gt; (value:&quot;c&quot;, done:false)</span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());  <span class="comment">//-&gt; (value: undefined, done: true)</span></span><br></pre></td></tr></table></figure>

<p>在for-of循环中可以通过这个迭代器按序访问每个字符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="string">&quot;abcde&quot;</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-&gt; a</span></span><br><span class="line"><span class="comment">//-&gt; b</span></span><br><span class="line"><span class="comment">//-&gt; c</span></span><br><span class="line"><span class="comment">//-&gt; d</span></span><br><span class="line"><span class="comment">//-&gt; e</span></span><br></pre></td></tr></table></figure>

<p>有了这个迭代器之后，字符串就可以通过解构操作符来解构了。比如，可以更方便地把字符串分割为字符数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log([...message]); <span class="comment">//-&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]</span></span><br></pre></td></tr></table></figure>
<h4 id="10-字符串大小写转换"><a href="#10-字符串大小写转换" class="headerlink" title="10.字符串大小写转换"></a>10.字符串大小写转换</h4><p>下一组方法涉及大小写转换，包括4个方法：<code>toLowerCase()</code>、<code>tolocaleLowerCase()</code> 、<code>toUpperCase()</code> 和 <code>toLocaleCase()</code>。</p>
<h4 id="11-字符串模式匹配方法"><a href="#11-字符串模式匹配方法" class="headerlink" title="11. 字符串模式匹配方法"></a>11. 字符串模式匹配方法</h4><p>匹配字符串：<code>match()</code> 。本质上与RegExp对象的 <code>exec()</code> 方法相同。</p>
<p>查找字符串：<code>search()</code> 。</p>
<p>替换字符串：<code>replace()</code> 。</p>
<p>拆分字符串：<code>split()</code> 。</p>
<h4 id="12-localeCompare-方法"><a href="#12-localeCompare-方法" class="headerlink" title="12. localeCompare() 方法"></a>12. localeCompare() 方法</h4><h2 id="5-4-单例内置对象"><a href="#5-4-单例内置对象" class="headerlink" title="5.4 单例内置对象"></a>5.4 单例内置对象</h2><p>ECMA-262对内置对象的定义是“<strong>任何由ECMAScript实现提供、与宿主环境无关，并在ECMAScript程序开始执行时就存在的对象</strong>”。这就意味着，开发者不用显式地实例化内置对象，因为它们已经实例化好了。前面我们已经接触了大部分内置对象，包括Object、Array和String。本节介绍 ECMA-262定义的另外两个单例内置对象：G1obal和Math。</p>
<h3 id="5-4-1-Global"><a href="#5-4-1-Global" class="headerlink" title="5.4.1 Global"></a>5.4.1 Global</h3><p>G1obal对象是ECMAScript中最特别的对象，因为代码不会显式地访问它。ECMA-262规定G1obal对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。</p>
<p><strong>事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成G1obal对象的属性。</strong></p>
<p>本书前面介绍的函数，包括 <code>isNaN()</code>、<code>isFinite()</code>、<code>parseInt()</code>和 <code>parseFloat()</code>，实际上都是G1obal对象的方法。除了这些，G1obal对象上还有另外一些方法。</p>
<h4 id="1-URL编码方法"><a href="#1-URL编码方法" class="headerlink" title="1. URL编码方法"></a>1. URL编码方法</h4><p><code>encodeURI()</code>和 <code>encodeURIComponent()</code>方法用于编码统一资源标识符(URI)，以便传给浏览器。有效的URI不能包含某些字符，比如空格。使用URI编码方法来编码URI可以让浏览器能够理解它们，同时又以特殊的UTF-8编码替换掉所有无效字符。</p>
<p><code>ecnodeURI()</code>方法用于对整个URI进行编码，比如 “<a target="_blank" rel="noopener" href="http://www.wrox.com/illegal">www.wrox.com/illegal</a> value.js”。而<code>encodeURIComponent()</code>方法用于编码URI中单独的组件，比如前面URL中的 “i11egal value.js”。</p>
<h4 id="2-eval-方法"><a href="#2-eval-方法" class="headerlink" title="2. eval() 方法"></a>2. eval() 方法</h4><p>这个方法可能是整个ECMAScript语言中最强大的了。这个方法就是一个完整的ECMAScript解释器，它接收一个参数，即一个要执行的ECMAScript字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;alert(&#x27;hello&#x27;)&quot;</span><span class="string">&quot;);</span></span><br><span class="line"><span class="string">//等价于下面的语句</span></span><br><span class="line"><span class="string">alert(&quot;</span>hello<span class="string">&quot;);</span></span><br></pre></td></tr></table></figure>
<p>当解释器发现 <code>eval()</code> 调用时，会将参数解释为实际的ES语句，然后将其插入到该位置。通过 <code>eval()</code> 执行的代码属于该调用所在的上下文，被执行的代码与该上下文<strong>拥有相同的作用域链</strong>。这意味着定义在包含上下文中的变量可以在 <code>eval()</code> 调用内部被引用，比如下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(msg)&quot;</span>);  <span class="comment">//-&gt; &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>eval()</code> 定义的任何变量和函数都<strong>不会被提升</strong>，这是因为在解析代码的时候，它们是被包含在一个字符串中的。它们只是在 <code>eval()</code> 执行的时候才会被创建。</p>
<p>在严格模式下，在 <code>eval()</code> 内部创建的变量和函数无法被外部访问。</p>
<blockquote>
<p>注意：解释代码字符串的能力是非常强大的，但也非常危险。在使用 <code>eval()</code>的时候必须极为慎重，特别是在解释用户输入的内容时。因为这个方法会对XSS利用暴露出很大的攻击面。恶意用户可能插入会导致你网站或应用崩溃的代码。</p>
</blockquote>
<h4 id="3-Global对象属性"><a href="#3-Global对象属性" class="headerlink" title="3. Global对象属性"></a>3. Global对象属性</h4><blockquote>
<p>这里不再列出。</p>
</blockquote>
<h4 id="4-window对象"><a href="#4-window对象" class="headerlink" title="4. window对象"></a>4. window对象</h4><p>虽然ECMA-262没有规定直接访问Global对象的方式，但<strong>浏览器将window对象实现为Global对象的代理</strong>。因此，所有全局作用域中声明的变量和函数都变成了window的属性。</p>
<blockquote>
<p>window对象会在第12章更加详细的介绍。</p>
</blockquote>
<h3 id="5-4-2-Math"><a href="#5-4-2-Math" class="headerlink" title="5.4.2 Math"></a>5.4.2 Math</h3><blockquote>
<p>这里不再介绍。</p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2021/03/18/h%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%94%E7%AB%A0/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2021/03/18/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            JavaScript红宝书学习笔记（2）
          
        </div>
      </a>
    
    
      <a href="/2021/03/18/map%E4%B8%8Eobject%E7%9A%84%E5%B7%AE%E5%BC%82%E4%B8%8E%E9%80%89%E6%8B%A9/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">map与object的差异与选择</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "DxjdVENjKn4OPt6wHb07UtxP-gzGzoHsz",
    app_key: "J0hPK8lUjl1jMLcupB2S7Gws",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2021
        <i class="ri-heart-fill heart_icon"></i> Lu xiuyuan
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="路修远"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/photos">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2020/12/30/%E6%95%A3%E8%AF%97">诗集</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=28718313&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>