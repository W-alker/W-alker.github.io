<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>记录博客建站过程</title>
    <url>/2020/12/27/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%8B/</url>
    <content><![CDATA[<blockquote>
<p>很早就有建一个博客的想法，主要想记录一些学习过程、发布和分享一些文章什么的。2020年中开始花了大概两个半月学了前端，就尝试写一个博客，但是很麻烦，过程也相当曲折，写了大概三分之一还是发现自己的技术很差很差，后端也只是浅尝辄止，很多东西都无法实现，就停止了建博客。断了几个月的前端学习后，这几天突然看到收藏夹的Hexo博客教学视频，心血来潮就学着花了一天建立了一个博客。这里简单记录下建站过程和一些踩坑。</p>
</blockquote>
<h2 id="教程及主题"><a href="#教程及主题" class="headerlink" title="教程及主题"></a>教程及主题</h2><p>教程视频：<a href="https://www.bilibili.com/video/BV1Np4y1Y7SW">从零开始搭建个人博客 | 手把手教你使用Hexo框架4步完成个人博客搭建 </a></p>
<p>使用主题：<a href="https://shen-yu.gitee.io/">Ayer</a>  |  <a href="https://github.com/Shen-Yu/hexo-theme-ayer">Github地址</a>  |  <a href="https://shen-yu.gitee.io/2019/ayer/">ayer中文说明</a></p>
<p>Hexo文档：<a href="https://hexo.io/zh-cn/docs/">hexo中文文档</a></p>
<p><img src="https://pic.downk.cc/item/5fe9de223ffa7d37b33ed34f.jpg"></p>
<a id="more"></a>

<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong><em>注意，本篇文章仅作记录建站过程和解决一些问题的方法，如果你使用该主题也出现了些问题，可以略作参考。或者你是新手并且也想使用该主题，可以阅读本文。</em></strong></p>
<h2 id="过程及踩坑"><a href="#过程及踩坑" class="headerlink" title="过程及踩坑"></a>过程及踩坑</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Hexo的教学其实已经屡见不鲜了，但是我个人还是比较喜欢视频教学，找学习视频自然上B站。主要过程按照教学视频来就好。其实最主要修改的还是根目录和主题文件夹下的<font color="red"> _config.yml</font>文件，根目录下的<font color="red"> _config.yml</font>文件可以按照hexo的中文文档进行修改，主题文件夹中的最好参考该主题的中文说明（该主题的中文说明还是很简单易懂的）。最好还是阅读下hexo的中文文档，主题的中文说明更是必看。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果想更改本主题的配置，可以参考这篇文章：<a href="https://blog.csdn.net/qq_35982918/article/details/106728754">Hexo博客Ayer主题自定义配置</a></p>
<h3 id="页面404？"><a href="#页面404？" class="headerlink" title="页面404？"></a>页面404？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;最开始更换完ayer主题后，只有主页和归档能够显示，其他页面会报404，是因为这些页面都没有创建或者路径不正确。需要使用命令</p>
<p>​    <code>hexo new page 要创建的页面</code></p>
<p>注意命令应当是在根目录下运行，例如要创建分类页面，应当使用</p>
<p>​    <code>hexo new page categories</code></p>
<p>如果要标签页面就将页面名改为  tags：</p>
<p>​    <code>hexo new page tags</code></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果觉得侧边栏菜单页面过多，直接更改主题文件夹下的<font color="red">_config.yml</font>文件，直接在  <strong>#menu</strong>  选项下删除即可，侧边栏就不会显示。如果要添加菜单项，同样直接按模板格式添加就行，路径可以是相对地址路径，也可以是url地址。其实这里可以注意下， <strong>#menu</strong> 选项下的“链接”其实是和根目录  <font color="blue">/source</font> 文件夹下的页面名是一一对应的。例如：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这是主题文件夹下的<font color="red">_config.yml</font>文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 侧边栏菜单</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">主页:</span> <span class="string">/</span></span><br><span class="line">  <span class="string">归档:</span> <span class="string">/archives</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags</span></span><br><span class="line">  <span class="string">摄影:</span> <span class="string">/photos</span></span><br><span class="line">  <span class="string">友链:</span> <span class="string">/friends</span></span><br><span class="line">  <span class="string">关于我:</span> <span class="string">/about</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这是根目录<font color="blue"> /source</font> 文件夹下的文件：</p>
<p><img src="https://pic.downk.cc/item/5fe9ccd73ffa7d37b322cd6d.png" alt="演示图片"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;不难看出除了 <font color="blue">/_posts</font> 文件夹是用来保存文章的，其他的文件夹名和上面是相互对应的。<em>注意路径名不要出错。</em></p>
<h3 id="分类和标签页面"><a href="#分类和标签页面" class="headerlink" title="分类和标签页面"></a>分类和标签页面</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;百度了怎么添加分类和标签页面，可以参考：<a href="https://blog.csdn.net/weixin_33857230/article/details/91474562">Hexo 添加分类及标签</a>。一开始给markdown文章添加了tags和categories，在文章界面上确实显示了标签和分类，但是分类和标签页面却仍然是空白，苦恼了半天，最后终于可找到了解决办法：<a href="https://blog.csdn.net/weixin_42118981/article/details/109462491">解决hexo下分类和标签无法显示的问题</a>，将 <font color="blue">/tags</font>  和<font color="blue">  /categories </font>文件夹下的index.md文件改成如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Categories</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-12-28 10:17:01</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">categories</span>   <span class="comment">#这里是解决问题的核心</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span>   <span class="comment"># 这里是关闭评论</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-12-28 10:17:49</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">tags</span>   <span class="comment">#同上，必须加上此语句</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果友链等页面也出现该问题，解决办法一致。</p>
<h3 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;写文章使用markdown的文法还是很舒服的，如果不会可以参考一下教程，十几分钟就能学会：<a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟教程 | Markdown 教程</a>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;插入图片有点麻烦，有一篇参考文章说的比较全：<a href="https://www.5yun.org/20794.html">Hexo文章插入图片</a>。尝试了之后还是选择了使用图床：<a href="https://www.superbed.cn/">聚合图床</a>。图片上传后可以获得一个URL地址，插入图片时直接写上链接就好。</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;我的博客里用了一个网易云音乐的插件，是该主题中自带的，在主题文件夹下的<font color="red"> _config.yml  </font>里可以找到，将autoplay改为true即可，也可以更改默认音乐。这个插件局限性有点大，可以参考原开发者的博客，有播放器插件的页面。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;该主题已经集成了一些插件，比如字数统计，访问量统计，评论插件等。如果想要使用其他的插件，请参考hexo插件文档。</p>
<h3 id="Github部署"><a href="#Github部署" class="headerlink" title="Github部署"></a>Github部署</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;部署视频中已经有说明，如果想要上传更新记住以下命令：</p>
<p><code>hexo clean</code>     主要用来清除缓存等，建议每次有更新都使用该命令</p>
<p><code>hexo g</code>    </p>
<p><code>hexo s</code>    仅在本地开启一个预览，可以直观的看到变化</p>
<p><code>hexo d</code>    上传更新</p>
<h3 id="自定义页面"><a href="#自定义页面" class="headerlink" title="自定义页面"></a>自定义页面</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在观看GitHub上传后的文件后，根目录文件大致是这样：</p>
<p><img src="https://pic.downk.cc/item/5fe9f5f83ffa7d37b36711ce.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;再看到本地目录下的public文件夹中的文件，大致是这样的：</p>
<p><img src="https://pic.downk.cc/item/5fe9f67e3ffa7d37b3681943.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;并且about、archives、friends文件夹里都有一个index.html文件。再加上上面主题目录下 _config.yml 文件中 <strong>#menu</strong> 项下的“链接”，这才发现部署到github仓库根目录上的其实就是public文件夹中的所有文件，根目录的index.html作为主页面，菜单栏的链接直接指向其他页面的文件夹路径，因此里面的index.html文件自然就成为了相应页面。<em>这也就意味着如果想要自定义页面，可以直接修改public文件夹中的html文件。</em></p>
<h3 id="Valine评论系统"><a href="#Valine评论系统" class="headerlink" title="Valine评论系统"></a>Valine评论系统</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;该主题使用的评论系统是valine，当然还有其他的，在配置文件里可以看到，valine是默认开启的，页面里也可以看到，但是这时候的评论系统只有页面样式，无法发表评论。根据这篇文章：<a href="https://blog.csdn.net/blue_zy/article/details/79071414">为你的Hexo加上评论系统-Valine</a>，可以实现完整的评论功能。设置完之后别忘记重新部署。至于想管理评论的话，可以直接在  你创建的应用/存储/结构化数据/comment  中直接管理，当然也有其他方法，参考Valine官方文档：<a href="https://valine.js.org/">Valine - 一款快速、简洁且高效的无后端评论系统</a>。</p>
<h2 id="感谢原开发者"><a href="#感谢原开发者" class="headerlink" title="感谢原开发者"></a>感谢原开发者</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;大概就是这些，hexo创建博客还是很简单的，功能也相当强大，而且零成本，花点时间就可以做出来。最后感谢该主题的开发者：Shen-Yu。这是他的博客：<a href="https://shen-yu.gitee.io/">https://shen-yu.gitee.io/</a>，这是他的Github：<a href="https://github.com/Shen-Yu">https://github.com/Shen-Yu</a>。如果你也想使用该主题别忘了给开发者一个star。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果有问题可以在评论区留言。谢谢观看。</p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>记录大创（3）</title>
    <url>/2021/03/24/%E8%AE%B0%E5%BD%95%E5%A4%A7%E5%88%9B%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Express使用nodemailer完成邮箱验证功能详细流程（含封装，可作自定义模块）"><a href="#Express使用nodemailer完成邮箱验证功能详细流程（含封装，可作自定义模块）" class="headerlink" title="Express使用nodemailer完成邮箱验证功能详细流程（含封装，可作自定义模块）"></a>Express使用nodemailer完成邮箱验证功能详细流程（含封装，可作自定义模块）</h1><blockquote>
<p>在express中使用第三方模块nodemailer完成邮箱验证功能，含客户端请求验证邮件和服务端发送验证码和判断验证码。</p>
</blockquote>
<h2 id="1-安装和引入模块"><a href="#1-安装和引入模块" class="headerlink" title="1. 安装和引入模块"></a>1. 安装和引入模块</h2><p><strong>安装</strong>：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm i nodemailer -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>
<p><strong>引入</strong>：</p>
<p>我们先新建一个 <code>mail.js</code> 文件作为包含发送邮件功能的模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mail.js文件，发送邮件模块*/</span></span><br><span class="line"><span class="keyword">const</span> nodemailer = <span class="built_in">require</span>(<span class="string">&#x27;nodemailer&#x27;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; sendMail &#125;;  <span class="comment">//最后暴露一个sendMail方法，之后会进行这个方法的封装</span></span><br></pre></td></tr></table></figure>
<p>在其他的路由文件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> mail = <span class="built_in">require</span>(<span class="string">&quot;./mail&quot;</span>); <span class="comment">//引入我们的自定义模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = express.Router();   <span class="comment">//路由</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<br>

<h2 id="2-封装自定义模块"><a href="#2-封装自定义模块" class="headerlink" title="2. 封装自定义模块"></a>2. 封装自定义模块</h2><h3 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h3><p>使用 <code>nodemailer</code> 这个模块需要我们有一个能发送邮件的邮箱，使用QQ邮箱。此外，需要我们到邮箱中开启 <strong>POP3/SMTP</strong> 服务，开启方法如下：</p>
<blockquote>
<p>登录邮箱–&gt; 邮箱首页上方点击“设置” –&gt; 邮箱设置中点击“账户” –&gt; 下滑找到“开启服务” –&gt;点击POP3/SMTP服务，之后按提示完成开启。</p>
</blockquote>
<h3 id="模块中配置邮箱："><a href="#模块中配置邮箱：" class="headerlink" title="模块中配置邮箱："></a>模块中配置邮箱：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mail.js文件，发送邮件模块*/</span></span><br><span class="line"><span class="comment">//配置邮箱</span></span><br><span class="line"><span class="keyword">let</span> transporter = nodemailer.createTransport(&#123;</span><br><span class="line">  host: <span class="string">&quot;smtp.qq.com&quot;</span>,</span><br><span class="line">  secureConnection: <span class="literal">true</span>, <span class="comment">// use SSL</span></span><br><span class="line">  port: <span class="number">465</span>,</span><br><span class="line">  secure: <span class="literal">true</span>, <span class="comment">// secure:true for port 465, secure:false for port 587</span></span><br><span class="line">  auth: &#123;</span><br><span class="line">    user: <span class="string">&quot;XXXXXXX@qq.com&quot;</span>,   <span class="comment">//其他的不要动，更改邮箱</span></span><br><span class="line">    pass: <span class="string">&quot;XXXXXX&quot;</span>,    <span class="comment">// QQ邮箱需要使用的授权码</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="封装发送邮件方法sendMail"><a href="#封装发送邮件方法sendMail" class="headerlink" title="封装发送邮件方法sendMail()"></a>封装发送邮件方法sendMail()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数：mail：需要发送的邮件地址；code：验证码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMail</span>(<span class="params">mail, code</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 设置邮件内容（谁发送什么给谁）</span></span><br><span class="line">  <span class="keyword">let</span> mailOptions = &#123;</span><br><span class="line">    <span class="keyword">from</span>: <span class="string">&#x27;&quot; XXX &quot; &lt;XXXXXX@qq.com&gt;&#x27;</span>,   <span class="comment">// 发件人</span></span><br><span class="line">    to: mail,     <span class="comment">// 收件人</span></span><br><span class="line">    subject: <span class="string">&quot;邮箱验证&quot;</span>,    <span class="comment">// 主题</span></span><br><span class="line">    text: <span class="string">`您正在尝试修改密码,您的验证码是 <span class="subst">$&#123;code&#125;</span>,有效期5分钟。`</span>,   <span class="comment">// 直接发送文本</span></span><br><span class="line">    <span class="comment">//html: &quot;&lt;b&gt;验证功能&lt;/b&gt;&quot;,       // 也可以发送html格式文本</span></span><br><span class="line">    <span class="comment">// 下面是发送附件，不需要就注释掉</span></span><br><span class="line">    <span class="comment">/*     attachments: [</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        filename: &quot;test.md&quot;,</span></span><br><span class="line"><span class="comment">        path: &quot;./test.md&quot;,</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        filename: &quot;content&quot;,</span></span><br><span class="line"><span class="comment">        content: &quot;发送内容&quot;,</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">    ], */</span></span><br><span class="line">  &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里返回一个异步操作</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用先前创建的传输器的 sendMail 方法传递消息对象</span></span><br><span class="line">    transporter.sendMail(mailOptions, <span class="function">(<span class="params">error, info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(error) reject();      </span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Message: <span class="subst">$&#123;info.messageId&#125;</span>`</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`sent: <span class="subst">$&#123;info.response&#125;</span>`</span>);</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整的自定义模块："><a href="#完整的自定义模块：" class="headerlink" title="完整的自定义模块："></a>完整的自定义模块：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mail.js文件，发送邮件模块*/</span></span><br><span class="line"><span class="keyword">const</span> nodemailer = <span class="built_in">require</span>(<span class="string">&#x27;nodemailer&#x27;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* mail.js文件，发送邮件模块*/</span></span><br><span class="line"><span class="comment">//配置邮箱</span></span><br><span class="line"><span class="keyword">let</span> transporter = nodemailer.createTransport(&#123;</span><br><span class="line">  host: <span class="string">&quot;smtp.qq.com&quot;</span>,</span><br><span class="line">  secureConnection: <span class="literal">true</span>, <span class="comment">// use SSL</span></span><br><span class="line">  port: <span class="number">465</span>,</span><br><span class="line">  secure: <span class="literal">true</span>, <span class="comment">// secure:true for port 465, secure:false for port 587</span></span><br><span class="line">  auth: &#123;</span><br><span class="line">    user: <span class="string">&quot;XXXXXXX@qq.com&quot;</span>,   <span class="comment">//其他的不要动，更改邮箱</span></span><br><span class="line">    pass: <span class="string">&quot;XXXXXX&quot;</span>,    <span class="comment">// QQ邮箱需要使用的授权码</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数：mail：需要发送的邮件地址；code：验证码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMail</span>(<span class="params">mail, code</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 设置邮件内容（谁发送什么给谁）</span></span><br><span class="line">  <span class="keyword">let</span> mailOptions = &#123;</span><br><span class="line">    <span class="keyword">from</span>: <span class="string">&#x27;&quot; XXX &quot; &lt;XXXXXX@qq.com&gt;&#x27;</span>,   <span class="comment">// 发件人</span></span><br><span class="line">    to: mail,     <span class="comment">// 收件人</span></span><br><span class="line">    subject: <span class="string">&quot;邮箱验证&quot;</span>,    <span class="comment">// 主题</span></span><br><span class="line">    text: <span class="string">`您正在尝试修改密码,您的验证码是 <span class="subst">$&#123;code&#125;</span>,有效期5分钟。`</span>,   <span class="comment">// 直接发送文本</span></span><br><span class="line">    <span class="comment">//html: &quot;&lt;b&gt;验证功能&lt;/b&gt;&quot;,       // 也可以发送html格式文本</span></span><br><span class="line">    <span class="comment">// 下面是发送附件，不需要就注释掉</span></span><br><span class="line">    <span class="comment">/*     attachments: [</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        filename: &quot;test.md&quot;,</span></span><br><span class="line"><span class="comment">        path: &quot;./test.md&quot;,</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        filename: &quot;content&quot;,</span></span><br><span class="line"><span class="comment">        content: &quot;发送内容&quot;,</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">    ], */</span></span><br><span class="line">  &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里返回一个异步操作</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用先前创建的传输器的 sendMail 方法传递消息对象</span></span><br><span class="line">    transporter.sendMail(mailOptions, <span class="function">(<span class="params">error, info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(error) reject();      </span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Message: <span class="subst">$&#123;info.messageId&#125;</span>`</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`sent: <span class="subst">$&#123;info.response&#125;</span>`</span>);</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; sendMail &#125;;  <span class="comment">//最后暴露一个sendMail方法，之后会进行这个方法的封装</span></span><br></pre></td></tr></table></figure>
<br>

<h2 id="3-客户端请求获取验证码"><a href="#3-客户端请求获取验证码" class="headerlink" title="3. 客户端请求获取验证码"></a>3. 客户端请求获取验证码</h2><p>这里直接使用JQ的ajax发送请求了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    email: email,   <span class="comment">//这里直接在请求头中传递邮箱地址了</span></span><br><span class="line">  &#125;,</span><br><span class="line">  url: <span class="string">&quot;/get_verifyCode&quot;</span>,</span><br><span class="line">  type: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">  contentType: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    alert(data.msg);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<br>

<h2 id="4-服务端发送验证码"><a href="#4-服务端发送验证码" class="headerlink" title="4. 服务端发送验证码"></a>4. 服务端发送验证码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 路由文件 */</span></span><br><span class="line"><span class="comment">//发送验证码</span></span><br><span class="line">app.post(<span class="string">&quot;/get_verifyCode&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//请求头附带的邮箱地址</span></span><br><span class="line">  <span class="keyword">const</span> email = req.headers.email;   </span><br><span class="line">    <span class="comment">//随机生成一个验证码</span></span><br><span class="line">  <span class="keyword">let</span> code = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">10000</span>);</span><br><span class="line">    <span class="comment">//使用mail模块中的sendMail方法</span></span><br><span class="line">  mail</span><br><span class="line">    .sendMail(email, code)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      res.send(&#123; <span class="attr">err</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&quot;验证码已发送&quot;</span> &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      res.send(&#123; <span class="attr">err</span>: <span class="number">1</span>, <span class="attr">msg</span>: <span class="string">&quot;验证码发送失败&quot;</span> &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>到此为止，服务端已经可以成功发送验证码邮件了。</p>
<br>

<h2 id="5-服务端对验证码的验证"><a href="#5-服务端对验证码的验证" class="headerlink" title="5. 服务端对验证码的验证"></a>5. 服务端对验证码的验证</h2><p>前面是在发送验证码功能的路由中随机生成的验证码，那么如何在客户端发来的验证请求中验证我们之前生成的验证码呢？</p>
<p>我们需要一个全局变量，保存之前生成的验证码，并对应当时发送验证码的邮箱地址。发送验证码功能代码改动如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 路由文件 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> verify_codes = &#123;&#125;; <span class="comment">//保存验证码，用于后续验证</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送验证码</span></span><br><span class="line">app.post(<span class="string">&quot;/get_verifyCode&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//请求头附带的邮箱地址</span></span><br><span class="line">  <span class="keyword">const</span> email = req.headers.email;   </span><br><span class="line">    <span class="comment">//随机生成一个验证码</span></span><br><span class="line">  <span class="keyword">let</span> code = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">10000</span>);</span><br><span class="line">    <span class="comment">//保存验证码</span></span><br><span class="line">  verify_codes[email] = code;   </span><br><span class="line">    <span class="comment">//这样对象中就保存了一个 &#123;邮箱:验证码&#125; 格式的属性</span></span><br><span class="line">  <span class="built_in">console</span>.log(verify_codes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用mail模块中的sendMail方法</span></span><br><span class="line">  mail</span><br><span class="line">    .sendMail(email, code)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      res.send(&#123; <span class="attr">err</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&quot;验证码已发送&quot;</span> &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      res.send(&#123; <span class="attr">err</span>: <span class="number">1</span>, <span class="attr">msg</span>: <span class="string">&quot;验证码发送失败&quot;</span> &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>之后我们只需要判断用户传来的验证码参数 <code>code</code> 和邮箱参数 <code>email</code> 和服务端保存的对象变量是否一致：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( code === verify_codes[email] )   &#123; <span class="comment">//执行代码  &#125;</span></span><br></pre></td></tr></table></figure>
<p>至此，邮箱验证功能全部完成。</p>
]]></content>
      <categories>
        <category>大创</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>大创</tag>
      </tags>
  </entry>
  <entry>
    <title>记录大创（2）</title>
    <url>/2021/03/18/%E8%AE%B0%E5%BD%95%E5%A4%A7%E5%88%9B%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h1 id="express使用JWT和httpOnly-cookie进行登录和安全验证"><a href="#express使用JWT和httpOnly-cookie进行登录和安全验证" class="headerlink" title="express使用JWT和httpOnly cookie进行登录和安全验证"></a>express使用JWT和httpOnly cookie进行登录和安全验证</h1><blockquote>
<p>一般情况使用JWT作为身份验证的方式可以直接参考这篇文章：<a href="https://www.cnblogs.com/zkqiang/p/11810203.html">Node.js 使用 express-jwt 解析 JWT</a> 。这里主要针对httpOnly类型的cookie进行代码调整。</p>
</blockquote>
<a id="more"></a>

<h2 id="1-安装和引入"><a href="#1-安装和引入" class="headerlink" title="1. 安装和引入"></a>1. 安装和引入</h2><p>需要使用的模块：<code>express-jwt</code> ，用于解析token； <code>jsonwebtoken</code> ，用于生成token ； <code>cookie-parser</code>，用于解析cookie（据说express已经内置，但是为可能没有该模块导致避免取不到cookie，安装该模块）。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm i express<span class="literal">-jwt</span> jsonwebtoken cookie<span class="literal">-parser</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>
<p><strong>引入：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> expressJwt = <span class="built_in">require</span>(<span class="string">&#x27;express-jwt&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">&#x27;cookie-parser&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br></pre></td></tr></table></figure>
<h2 id="2-生成token，放入cookie"><a href="#2-生成token，放入cookie" class="headerlink" title="2. 生成token，放入cookie"></a>2. 生成token，放入cookie</h2><p><strong>封装一个生成token的方法：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置一个私钥</span></span><br><span class="line"><span class="keyword">const</span> scrict = <span class="string">&#x27;examplev8w9egf&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createToken</span> = <span class="title">palyload</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//给palyload添加一个生成时间戳的属性</span></span><br><span class="line">    palyload.curtime = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="comment">//这里添加Bearer是因为express-jwt模块默认获取到token的方法</span></span><br><span class="line">    <span class="comment">//当然这里也没必要添加，因为后续我们不会使用默认的解析方式</span></span><br><span class="line">    <span class="keyword">const</span> token = <span class="string">&#x27;Bearer &#x27;</span> +　jwt.sign(</span><br><span class="line">        palyload,</span><br><span class="line">        scrict, &#123; </span><br><span class="line">            expiresIn: <span class="number">3600</span> * <span class="number">24</span> * <span class="number">3</span>   <span class="comment">//过期时间</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在需要的位置生成和发送token到cookie：</strong></p>
<blockquote>
<p>如果不知道express中怎么使用cookie，可以参考：<a href="https://blog.csdn.net/cckevincyh/article/details/79815666">Express Cookie的使用</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> token = createToken(&#123;<span class="attr">login</span>:<span class="literal">true</span>,<span class="attr">name</span>:user&#125;)   <span class="comment">//这里的palyload参数可以自行设定</span></span><br><span class="line">    <span class="comment">//将token存入cookie，设置最大失效时间和httpOnly</span></span><br><span class="line">    res.cookie(<span class="string">&#x27;token&#x27;</span>,token,&#123; <span class="attr">maxAge</span>:<span class="number">1000</span>*<span class="number">3600</span>*<span class="number">24</span>, <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>, <span class="attr">httpOnly</span>:<span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="comment">//响应客户端</span></span><br><span class="line">    res.send(&#123;<span class="attr">msg</span>:<span class="string">&#x27;cookie设置成功&#x27;</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>客户端携带cookie请求：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里使用JQ封装的ajax，默认是会自动携带cookie的，无需单独设置：</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    <span class="comment">//一般情况携带token的方式。但这里设置的是httpOnly无法获取，交给服务端处理</span></span><br><span class="line"><span class="comment">/*     headers:&#123;</span></span><br><span class="line"><span class="comment">        Accept: &quot;application/json; charset=utf-8&quot;,</span></span><br><span class="line"><span class="comment">        Authorization:token</span></span><br><span class="line"><span class="comment">    &#125;, */</span></span><br><span class="line">    url: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    type: <span class="string">&#x27;put&#x27;</span>,</span><br><span class="line">    contentType: <span class="string">&quot;application/json&quot;</span>,  </span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//做一个响应401状态码的操作，返回登录界面</span></span><br><span class="line">    statusCode:&#123;</span><br><span class="line">        <span class="number">401</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="comment">//token验证失败 异常处理</span></span><br><span class="line">           alert(<span class="string">&#x27;token验证失败！&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>服务器端解析cookie中的token：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cookie-parser挂载                                                                         </span></span><br><span class="line">home.use(cookieParser());</span><br><span class="line"></span><br><span class="line"><span class="comment">//express-jwt挂载，验证token</span></span><br><span class="line">home.use(expressJwt(&#123;</span><br><span class="line">    secret:scrict,</span><br><span class="line">    algorithms: [<span class="string">&#x27;HS256&#x27;</span>],   <span class="comment">//解码方式建议加上，否则可能会报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*重要的是这里，需要改变express-jwt默认取得tokend的方式</span></span><br><span class="line"><span class="comment">      默认模块会从请求头的authorization中取得token，token以&#x27;Bearer&#x27;开头 */</span></span><br><span class="line">    getToken:<span class="function"><span class="keyword">function</span> <span class="title">fromCookie</span>(<span class="params">req</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//尝试从cookie读取token进行验证</span></span><br><span class="line">          <span class="keyword">if</span>(req.cookies.curToken)</span><br><span class="line">            <span class="keyword">return</span> req.cookies.curToken.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125;).unless(&#123;</span><br><span class="line">    path:[<span class="string">&#x27;/login&#x27;</span>,<span class="string">&#x27;logout&#x27;</span>]  <span class="comment">//白名单，该地址下的不会进行解析</span></span><br><span class="line">&#125;))</span><br><span class="line"><span class="comment">//token校验错误处理中间件</span></span><br><span class="line">home.use(<span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err.name === <span class="string">&#x27;UnauthorizedError&#x27;</span>) &#123;	</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">      res.status(<span class="number">401</span>).send(<span class="string">&#x27;invalid token...&#x27;</span>);   <span class="comment">//根据具体情况设置，这里返回401状态码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过解析后的处理</span></span><br><span class="line">app.use(<span class="string">&#x27;/user&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(&#123;<span class="attr">err</span>:<span class="number">0</span>,<span class="attr">msg</span>:<span class="string">&#x27;token通过解析验证&#x27;</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大创</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>大创</tag>
      </tags>
  </entry>
  <entry>
    <title>记录大创（1）</title>
    <url>/2021/03/18/%E8%AE%B0%E5%BD%95%E5%A4%A7%E5%88%9B%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h1 id="JQ中使用FormData-Ajax发送请求及使用express接收处理FormData数据"><a href="#JQ中使用FormData-Ajax发送请求及使用express接收处理FormData数据" class="headerlink" title="JQ中使用FormData+Ajax发送请求及使用express接收处理FormData数据"></a>JQ中使用FormData+Ajax发送请求及使用express接收处理FormData数据</h1><blockquote>
<p>最近写大创项目的时候，要做登录功能，考虑到之后还需要上传头像图片，因此决定使用FormData发送表单请求。项目中用的是JQ封装的ajax，配合FormData使用的时候出现了一些问题。</p>
</blockquote>
<p>首先这里就不再说明FormData的作用和用法，如果不清楚的可以看看这篇文章：<a href="https://www.cnblogs.com/crackedlove/p/10292867.html">FormData对象的使用</a>。</p>
<a id="more"></a>

<h2 id="1-可能出现的问题"><a href="#1-可能出现的问题" class="headerlink" title="1. 可能出现的问题"></a>1. 可能出现的问题</h2><ol>
<li><p>JQ中初始化FormData对象</p>
<p>在JQ中，如果想使用一个已经存在的表单初始化FormData对象，在选中这个表单DOM的时候，<strong>不能使用JQ自带的 <code>$(&#39;form&#39;)</code> 方法</strong>，而是应该使用JS原生写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误的写法：</span></span><br><span class="line"><span class="keyword">let</span> formData = <span class="keyword">new</span> FormData($(<span class="string">&#x27;form&#x27;</span>));</span><br><span class="line"><span class="comment">//正确的写法：</span></span><br><span class="line"><span class="keyword">let</span> formData = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.querySelector(<span class="string">&#x27;form&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>如果使用JQ的选择器写法，那么会报错，大致意思应该是FormData初始化的参数不正确。使用JS原生写法就没问题了。</p>
</li>
<li><p>配合ajax无法发送请求</p>
<p>如果在JQ封装的ajax中发送FormData数据，发生报错：<code>TypeError: &#39;append&#39; called on an object that does not implement interface FormData</code> 。加入这两行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">processData: <span class="literal">false</span>,</span><br><span class="line">contentType: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<br>

</li>
</ol>
<h2 id="2-完整的发送请求代码"><a href="#2-完整的发送请求代码" class="headerlink" title="2. 完整的发送请求代码"></a>2. 完整的发送请求代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用Formdata提交登录信息</span></span><br><span class="line"><span class="comment">//初始化表单</span></span><br><span class="line"><span class="keyword">let</span> formData = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.querySelector(<span class="string">&#x27;form&#x27;</span>));</span><br><span class="line"><span class="comment">//有需要的话可以修改formdata数据</span></span><br><span class="line"><span class="comment">//formdata.set(&#x27;identiy&#x27;, identiy);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送ajax请求</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">&#x27;./login&#x27;</span>,</span><br><span class="line">    type: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    data: formData,</span><br><span class="line">    processData: <span class="literal">false</span>,  <span class="comment">//不处理数据</span></span><br><span class="line">    contentType: <span class="literal">false</span>,  <span class="comment">//不设置内容类型</span></span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<br>

<h2 id="3-服务器端使用express接收处理FormData数据"><a href="#3-服务器端使用express接收处理FormData数据" class="headerlink" title="3. 服务器端使用express接收处理FormData数据"></a>3. 服务器端使用express接收处理FormData数据</h2><p>需要安装 <code>express-formidable</code> 模块：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm i express<span class="literal">-formidable</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入模块</span></span><br><span class="line"><span class="keyword">const</span> formidable = <span class="built_in">require</span>(<span class="string">&#x27;express-formidable&#x27;</span>);</span><br><span class="line"><span class="comment">//挂载</span></span><br><span class="line">app.use(formidable());</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收请求</span></span><br><span class="line">router.post(<span class="string">&#x27;/formdata&#x27;</span>,<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.fields);  <span class="comment">// formData中的参数</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.files);  <span class="comment">// formData中的文件</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<br>]]></content>
      <categories>
        <category>大创</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>大创</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript红宝书学习笔记（2）</title>
    <url>/2021/03/18/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第四章：变量、作用域与内存"><a href="#第四章：变量、作用域与内存" class="headerlink" title="第四章：变量、作用域与内存"></a>第四章：变量、作用域与内存</h1><h2 id="4-1-原始值与引用值"><a href="#4-1-原始值与引用值" class="headerlink" title="4.1 原始值与引用值"></a>4.1 原始值与引用值</h2><p>ECMAScript变量可以包含两种不同类型的数据：<strong>原始值</strong>和<strong>引用值</strong>。原始值(primitive value)就是最简单的数据，引用值(reference value)则是由多个值构成的对象。</p>
<p>在把一个值赋给变量时，JavaScript引擎必须确定这个值是原始值还是引用值。上一章讨论了6种原始值：Undefined、Nu11、Boolean、Number、String和Symbol。保存原始值的变量是<strong>按值</strong>(byvalue)访问的，因为我们操作的就是存储在变量中的实际值。</p>
<p>引用值是保存在内存中的对象。与其他语言不同，<strong>JavaScript不允许直接访问内存位置</strong>，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的<strong>引用</strong>(reference)而非实际的对象本身。为此，保存引用值的变量是<strong>按引用</strong>(by reference)访问的。</p>
<blockquote>
<p> 注意：在很多语言中，字符串是使用对象表示的，因此被认为是引用类型。ECMAScript打破了这个惯例。</p>
</blockquote>
<br>

<a id="more"></a>

<h3 id="4-1-1-动态属性"><a href="#4-1-1-动态属性" class="headerlink" title="4.1.1 动态属性"></a>4.1.1 动态属性</h3><p>原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什么，则大有不同。</p>
<ul>
<li><p><strong>对于引用值而言，可以随时添加、修改和删除其属性和方法</strong>。</p>
</li>
<li><p><strong>原始值不能有属性</strong>，尽管尝试给原始值添加属性不会报错。</p>
</li>
</ul>
<p>注意，原始类型的初始化可以只使用原始字面量形式。如果使用的是new关键字，则JavaScript会创建一个Object类型的实例，但其行为类似原始值，下面来看看这两种初始化方式的差异：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 <span class="string">&quot;Nicholas&quot;</span>:</span><br><span class="line"><span class="keyword">let</span> name2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Matt&quot;</span>);</span><br><span class="line">name1.age = <span class="number">27</span>;</span><br><span class="line">name2.age = <span class="number">26</span>:</span><br><span class="line"><span class="built_in">console</span>.log(name1.age):     <span class="comment">//-&gt; undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(name2.age);     <span class="comment">//-&gt; 26</span></span><br><span class="line"><span class="built_in">console</span>.10g(<span class="keyword">typeof</span> name1);  <span class="comment">//-&gt; string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name2);  <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<br>

<h3 id="4-1-2-复制值"><a href="#4-1-2-复制值" class="headerlink" title="4.1.2 复制值"></a>4.1.2 复制值</h3><p>除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。</p>
<p>1）在通过变量把一个原始值赋到另一个变量时，原始值会被复制到新变量的位置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>:</span><br><span class="line"><span class="keyword">let</span> num2 = num1;</span><br></pre></td></tr></table></figure>
<p>这里，num1包含数值5。当把num2初始化为num1时，num2也会得到数值5。这个值跟存储在numl 中的5是完全独立的，因为它是那个值的副本。<strong>这两个变量可以独立使用，互不干扰</strong>。这个过程如图4-1所示。</p>
<img src="https://img.imgdb.cn/item/600a950a3ffa7d37b31fb0f1.jpg" style="zoom: 33%;">

<p>2）在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，<strong>这里复制的值实际上是一个指针，它指向存储在堆内存中的对象</strong>。操作完成后，<strong>两个变量实际上指向同一个对象</strong>，因此一个对象上面的变化会在另一个对象上反映出来，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1:</span><br><span class="line">obj1.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name); <span class="comment">// “Nicholas&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，变量obj1保存了一个新对象的实例。然后，这个值被复制到obj2，此时两个变量都指向了同一个对象。在给obj1创建属性name并赋值后，通过obj2也可以访问这个属性，因为它们都指向同一个对象。图4-2展示了变量与堆内存中对象之间的关系：</p>
<img src="https://img.imgdb.cn/item/600a97143ffa7d37b3209b1e.jpg">

<br>

<h3 id="4-1-3-传递参数"><a href="#4-1-3-传递参数" class="headerlink" title="4.1.3 传递参数"></a>4.1.3 传递参数</h3><p>ECMAScript中所有函数的参数都是<strong>按值传递</strong>的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。</p>
<p>在<strong>按值</strong>传递参数时，值会被复制到一个局部变量（即一个命名参数，或者用ECMAScript的话说，就是arguments对象中的一个槽位）。在<strong>按引用</strong>传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着<em>对本地变量的修改会反映到函数外部</em>（这在ECMAScript中是不可能的）。</p>
<p>1）“Javascript中函数按值传参”这个性质在原始值上可以很明显的看到：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  num += <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> result = addTen(count);</span><br><span class="line"><span class="built_in">console</span>.log(count);   <span class="comment">//-&gt; 20，没有变化，原始值没有受到影响</span></span><br><span class="line">conaole.log(result);  <span class="comment">//-&gt; 30</span></span><br></pre></td></tr></table></figure>
<p>2）而对于引用值来说：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span> (<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName (person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">//-&gt; &quot;Nicholas&quot;   </span></span><br><span class="line"><span class="comment">//看的出来，传入person对象之后，person对象多了一个name属性</span></span><br></pre></td></tr></table></figure>
<p><strong>局部作用域中修改对象，这种变化反映到了全局作用域</strong>。但这是不是意味着对象的传参是<strong>按引用</strong>传参呢？再看下一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj.name =<span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">    <span class="comment">//添加两条语句：</span></span><br><span class="line">  obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  obj.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">    <span class="comment">//这里试图将obj重新定义为一个有着不同name属性的新对象</span></span><br><span class="line">    <span class="comment">//如果person是按引用传递的，那么person应该自动将指针改为指向  name为&#x27;Greg&#x27;的新对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">//-&gt; &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p>person对象的name属性值仍然是”Nicholas”，这意味着：<strong>函数中参数的值改变后，原始的引用仍然没变</strong>。当obj在函数内部被重写时，它变成了一个指向本地对象的指针。而那个对象在函数执行结束时就被销毁了。</p>
<blockquote>
<p>注意：ECMAScript中函数的参数就是局部变量。</p>
</blockquote>
<br>

<h3 id="4-1-4-确定类型"><a href="#4-1-4-确定类型" class="headerlink" title="4.1.4 确定类型"></a>4.1.4 确定类型</h3><p>前一章提到的<code>typeof</code>操作符<strong>最适合用来判断一个变量是否为原始类型</strong>。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或undefined的最好方式。如果值是对象或nu11，那么<code>typeof</code> 会返回”object”。</p>
<p>看的出来，<code>typeof</code>操作符对于引用值的用处不大。所以，ECMAScript提供了一个<code>instanceof</code>操作符：</p>
<p><code>result = variable instanceof constructor</code></p>
<p>如果变量是给定引用类型（由其原型链决定，将在第8章详细介绍）的实例，则 <code>instanceof</code> 操作符返回true。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log (person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);    <span class="comment">//变量person是Object 吗？</span></span><br><span class="line"><span class="built_in">console</span>.log (colors <span class="keyword">instanceof</span> <span class="built_in">Array</span>);     <span class="comment">//变量 colors是Array 吗？</span></span><br><span class="line"><span class="built_in">console</span>.log (pattern <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>);   <span class="comment">//变量 pattern是RegExp吗?</span></span><br></pre></td></tr></table></figure>
<p><code>instanceof</code> 检测任何引用值和Object构造函数都会返回true，因为所有引用值都是Object的实例。当然，对于原始值而言，<code>instanceof </code>则会返回false。</p>
<blockquote>
<p>注意：typeof 操作符在用于检测函数时也会返回“function”。当在 Safari（直到 SafariS)和 Chrome(直到 Chrome 7)中用于检测正则表达式时，由于实现细节的原因，typeof也会返回“function”。ECMA-262 规定，任何实现内部<code>[[Ca11]]</code>方法的对象都应该在typeof检测时返回“function”。因为上述浏览器中的正则表达式实现了这个方法，所以typeof 对正则表达式也返回“function”。在IE和Firefox中，typeof 对正则表达式返回”object”。</p>
</blockquote>
<br>

<h2 id="4-2-执行上下文与作用域"><a href="#4-2-执行上下文与作用域" class="headerlink" title="4.2 执行上下文与作用域 `"></a>4.2 执行上下文与作用域 `</h2><p><strong>执行上下文</strong>（以下简称“上下文”）的概念在JavaScript中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的<strong>变量对象</strong>（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。</p>
<p>1）<strong>全局上下文</strong>是最外层的上下文。根据 ECMAScript实现的宿主环境，表示全局上下文的对象可能不一样。</p>
<p><strong>在浏览器中，全局上下文就是我们常说的window对象</strong>（第12章会详细介绍）。<em>因此所有通过 <code>var </code>定义的全局变量和函数都会成为 window 对象的属性和方法。使用 <code>let</code> 和 <code>const</code> 的顶级声明不会定义在全局上下文中</em>，但在作用域链解析上效果是一样的。</p>
<p><strong>上下文在其所有代码都执行完毕后会被销毁</strong>，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。</p>
<p>2）每个函数调用都有自己的上下文，即<strong>函数上下文</strong>。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上，在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。</p>
<p>3）上下文中的代码在执行的时候，会创建变量对象的一个<strong>作用域链</strong>(scope chain)。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序，<em>代码正在执行的上下文的变量对象始终位于作用域链的最前端</em>。</p>
<p>如果上下文是函数，则其活动对象(activation object)用作变量对象。活动对象最初只有一个定义变量：arguments（全局上下文中没有这个变量）。作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；<em>全局上下文的变量对象始终是作用域链的最后一个变量对象</em>。</p>
<p>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。(如果没有找到标识符，那么通常会报错）</p>
<p>看一看下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(color === <span class="string">&quot;blue&quot;</span>)&#123;</span><br><span class="line">    color = <span class="string">&#x27;red&#x27;</span>;   </span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure>
<p>对这个例子而言，函数<code>changeColor()</code>的作用域链包含两个对象：一个是它自己的变量对象（就是定义arguments对象的那个），另一个是全局上下文的变量对象。这个函数内部之所以能够访问变量color，就是因为可以在作用域链中找到它。</p>
<p><strong>局部作用域中定义的变量可用于在局部上下文中替换全局变量。</strong></p>
<p><strong>内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西</strong>。上下文之间的连接是线性的、有序的。</p>
<blockquote>
<p>注意：函数参数被认为i是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同规则。</p>
<p>PS：上下文还是很好理解的，这里不再多讨论。</p>
</blockquote>
<br>

<h3 id="4-2-1-作用域链增强"><a href="#4-2-1-作用域链增强" class="headerlink" title="4.2.1 作用域链增强"></a>4.2.1 作用域链增强</h3><p>虽然执行上下文主要有全局上下文和函数上下文两种（<code>eva1()</code>调用内部存在第三种上下文），但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这个现象，即代码执行到下面任意一种情况时：</p>
<ul>
<li>try/catch 语句的catch块</li>
<li>with语句</li>
</ul>
<p>这两种情况下，都会在作用域链前端添加一个变量对象。对with语句来说，会向作用域链前端添加指定的对象；对catch语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>)(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">let</span> qs = <span class="string">&quot;?debug=true&quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">with</span>(location)&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">let</span> url = href + qs;   <span class="regexp">//</span>这里引用href实际是引用location.href</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="regexp">//</span>而引用qs时引用的其实是buildUrl()中定义的qs变量</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">return</span> url;    <span class="comment">//这里url没有定义，因为let声明被限制在了块级作用域</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>这里，with 语句将 location对象作为上下文，因此 location会被添加到作用域链前端。bui1dUrl() 函数中定义了一个变量qs。当 with 语句中的代码引用变量href 时，实际上引用的是<code>location.href</code>，也就是自己变量对象的属性。在引用qs时，引用的则是定义在 bui1dUrl() 中的那个变量，它定义在函数上下文的变量对象上。而在with语句中使用 var声明的变量url会成为函数上下文的一部分，可以作为函数的值被返回；但像这里使用let声明的变量ur1，因为被限制在块级作用域(稍后介绍)，所以在with块之外没有定义。</p>
<br>

<h3 id="4-2-2-变量声明"><a href="#4-2-2-变量声明" class="headerlink" title="4.2.2 变量声明 *"></a>4.2.2 变量声明 *</h3><p>ES6之后，JavaScript的变量声明经历了翻天覆地的变化。直到ECMAScript5.1，var都是声明变量的唯一关键字。ES6不仅增加了1et和const两个关键字，而且还让这两个关键字压倒性地超越var成为首选。</p>
<p>1）使用 var的函数作用域声明</p>
<p><strong>在使用var声明变量时，变量会被自动添加到最接近的上下文</strong>。在函数中，最接近的上下文就是函数的局部上下文。在with语句中，最接近的上下文也是函数上下文。<em>如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文</em>，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>, <span class="number">20</span>);   <span class="comment">//-&gt; 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum);   <span class="comment">//-&gt; 报错：sum 在这里不是有效变量  这里访问不到函数内部var声明的变量</span></span><br></pre></td></tr></table></figure>
<p>但如果省略上面例子中的关键字var，那么sum 在add()被调之后就变成可以访问的了，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">  sum = num1 + num2;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>, <span class="number">20</span>);   <span class="comment">//-&gt; 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum);   <span class="comment">//-&gt; 30  可以访问，因为sum未经声明就被初始化，它被直接添加到了全局上下文</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：未经声明而初始化变量是Javascript编程中一个常见的错误，会导致很多问题。务必注意。</p>
<p>严格模式下，未经声明而初始化变量会报错。</p>
</blockquote>
<blockquote>
<p>PS：变量提升这里不再提及。</p>
</blockquote>
<p>2）使用let的块级作用域声明</p>
<p><strong>块级作用域由最近的一对花括号界定</strong>。换言之，if块、while块、function块，甚至是单独的块（也就是仅仅只有两个花括号）也是let变量声明的作用域。</p>
<p>let和var的第二个不同是：在同一作用域不能声明两次。重复的var声明会被忽略，但重复的let声明会抛出SyntaxError。</p>
<p>严格来说，let在Javascript运行时也会被提升，但是由于“暂时性死区”的缘故，（上一章提到过）实际上不能在声明之前使用let变量。</p>
<p>3）使用const的变量声明</p>
<p>const声明只应用到顶级原语或者对象。换言之，赋值为对象的const变量不能再被重新赋值为其他引用值，但对象的键不受限制。如果想让整个对象都不能修改，可以使用<code>Object.freeze()</code>，这样再给属性赋值时虽然不会报错，但会静默失败：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;;</span><br><span class="line">o1 = &#123;&#125;;    <span class="comment">//TypeError:给常量赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o2 = &#123;&#125;;</span><br><span class="line">o2.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">alert(o2.name);    <span class="comment">//-&gt; Jake   //对象的键不受限制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o3 = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line">o3.name = <span class="string">&#x27;Jake&#x27;</span>;     <span class="comment">//这一步没有意义，因为整个对象都不可被修改了</span></span><br><span class="line">alert(o3.name);   <span class="comment">//-&gt; undefined  </span></span><br></pre></td></tr></table></figure>
<p>由于const声明暗示变量的值是单一类型且不可修改，JavaScript运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的V8引擎就执行这种优化。</p>
<blockquote>
<p>注意：开发实践表明，如果开发流程并不会因此而受很大影响，<strong>就应该尽可能地多使用const 声明</strong>，除非确实需要一个将来会重新赋值的变量。这样可以从根本上保证提前发现重新赋值导致的bug。</p>
</blockquote>
<p>4）标识符查找</p>
<p>当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。（注意，作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。</p>
<br>

<h2 id="4-3-垃圾回收"><a href="#4-3-垃圾回收" class="headerlink" title="4.3 垃圾回收 `"></a>4.3 垃圾回收 `</h2><p>JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。JavaScript通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：确定哪个变量不会使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一段时间就会自动运行。</p>
<p>浏览器发展史上，用到过两种标记策略：标记清理和引用技术。JavaScript最常用的垃圾回收策略是<strong>标记清理</strong>。</p>
<p><strong>内存管理：</strong></p>
<p>将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。<strong>如果数据不再必要，就把它设置成null</strong>，从而释放其引用。这也可以叫做<strong>释放引用</strong>。这个建议最适合全局变量和全局对象的属性。局部变量在超出作用域后会被自动解除引用。</p>
<p>不过要注意，解除对一个值得引用并不会导致相关内存被回收。解除引用的关键在于确保相关的值已经不在上下文中了，因此<strong>它在下次垃圾回收时会被回收</strong>。</p>
<p>1）<strong>通过<code>let</code>和<code>const</code>声明提升性能</strong></p>
<p>因为const和let都以块（而非函数）为作用域，所以这两个关键字可能会更早的让回收程序介入，尽早回收应该回收的内存。</p>
<p>2）<strong>隐藏类和删除操作</strong></p>
<p>根据Javascript所在的运行环境，有时候需要根据浏览器使用的JavaScript引擎来采取不同的性能优化策略。截至2017年，Chrome是最流行的浏览器，使用V8 JavaScript引擎。V8在将解释后的JavaScript代码编译为实际的机器码时会利用“隐藏类”。如果你的代码非常注重性能，那么这一点可能对你很重要。</p>
<p>运行期间，V8 会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。能够共享相同隐藏类的对象性能会更好，V8会针对这种情况进行优化，但不一定总能够做到。比如下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article();</span><br></pre></td></tr></table></figure>
<p>V8会在后台配置，让这两个类实例共享相同的隐藏类，因为这两个实例共享同一个构造函数和原型。假设之后又添加了下面这行代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a2.author =<span class="string">&#x27;Jake&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>此时两个Article实例就会对应两个不同的隐藏类。根据这种操作的频率和隐藏类的大小，这有可能对性能产生明显影响。</p>
<p>当然，解决方案就是<strong>避免JavaScript的“先创建再补充”</strong>(ready-fire-aim)式的动态属性赋值，并在构造函数中一次性声明所有属性，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params">opt_author</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Cerenony Features Kazoo Band&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.author = opt_author;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> al = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article(<span class="string">&#x27;Jake&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>这样，两个实例基本上就一样了（不考虑hasOwnProperty的返回值），因此可以共享一个隐藏类从而带来潜在的性能提升。不过要记住，使用<code>delete</code>关键字会导致生成相同的隐藏类片段。看一下这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.title= <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.author =<span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article():</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">delete</span> a1.author;</span><br></pre></td></tr></table></figure>

<p>在代码结束后，即使两个实例使用了同一个构造函数，它们也不再共享一个隐藏类。动态删除属与动态添加属性导致的后果一样。最佳实践是<strong>把不想要的属性设置为nu11</strong>。这样可以保持隐藏类不和继续共享，同时也能达到删除引用值供垃圾</p>
<p>3）<strong>内存泄漏</strong></p>
<ol>
<li><p>意外声明全局变量</p>
<p>也就是局部作用域中声明变量时缺少声明操作符，而导致该变量变成了全局变量。加上<code>var</code> / <code>const</code> / <code>let</code>即可。 </p>
</li>
<li><p>定时器</p>
<p>定时器的回调通过闭包引用外部变量时，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;,<span class="number">100</span>)</span><br><span class="line"><span class="comment">//定时器只要一直运行，回调函数中引用的name就会一直占用内存，垃圾回收程序自然不会清理外部变量</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用闭包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> outer = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//上述代码创建了一个内部闭包，只要outer函数存在就不能清理name，因为闭包一直在引用它。如果name的内容很大，就会出现很大的问题了</span></span><br></pre></td></tr></table></figure>
<p>4）<strong>静态分配与对象池</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>学习笔记</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>JavaScript</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript红宝书学习笔记（3）</title>
    <url>/2021/03/18/h%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="第五章：基本引用类型"><a href="#第五章：基本引用类型" class="headerlink" title="第五章：基本引用类型"></a>第五章：基本引用类型</h1><p>引用值（或者对象）是某个特定<strong>引用类型</strong>的<strong>实例</strong>。新对象通过使用new操作符后跟一个构造函数（constructor）来创建。</p>
<a id="more"></a>

<h2 id="5-1-Date"><a href="#5-1-Date" class="headerlink" title="5.1 Date"></a>5.1 Date</h2><blockquote>
<p>这里不对Date进行详细深入，仅基于书本列出一些常用方法。更多方法和用法请参考：<a href="https://www.runoob.com/jsref/jsref-obj-date.html%E3%80%82">https://www.runoob.com/jsref/jsref-obj-date.html。</a></p>
</blockquote>
<p>1）基于其他其他日期和时间创建日期对象：</p>
<p><code>Date.parse</code>  和  <code>Date.UTC</code></p>
<p><code>Date.now</code> 返回表示方法执行日期和时间的毫秒数。</p>
<p>2）继承的方法：</p>
<p>Date类型重写了 <code>toLocaleString()</code> 、<code>toString()</code> 、<code>valueOf()</code> 方法。</p>
<ul>
<li><p> <code>toLocaleString()</code> 方法返回与浏览器运行的本地环境一致的日期和时间。</p>
</li>
<li><p> <code>toString()</code> 方法通常返回带时区信息的日期和时间。</p>
</li>
<li><p> <code>valueOf</code> 被重写后返回的是日期的毫秒表示。</p>
</li>
</ul>
<p>3）日期格式化方法：</p>
<p>Date类型有几个专门用于格式化日期的方法，它们都会返回字符串：</p>
<ul>
<li><p><code>toDateString() </code>显示日期中的周几、月、日、年(格式特定于实现)；</p>
</li>
<li><p><code>toTimeString()</code> 显示日期中的时、分、秒和时区(格式特定于实现)；</p>
</li>
<li><p><code>toLocaleDateString()</code> 显示日期中的周几、月、日、年(格式特定于实现和地区)；tolocaleTimeString()显示日期中的时、分、秒(格式特定于实现)；</p>
</li>
<li><p><code>toUTCString()</code> 显示完整的UTC日期(格式特定于实现)。</p>
</li>
</ul>
<p>这些方法的输出与tolocaleString()和 tostring()一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。</p>
<blockquote>
<p>注意 还有一个方法叫 <code>toGMTString()</code>，这个方法跟 <code>toUTCString()</code> 是一样的，目的<br>是为了向后兼容。不过，规范建议新代码使用 <code>toUTCString()</code>。 </p>
</blockquote>
<p>4）日期/时间组件方法。</p>
<br>

<h2 id="5-2-RegExp"><a href="#5-2-RegExp" class="headerlink" title="5.2 RegExp `"></a>5.2 RegExp `</h2><p>ECMAScript通过RegExp类型支持正则表达式。正则表达式使用类似Perl的简洁语法来创建：</p>
<p><code>let expression = /pattern/flags;</code></p>
<p>这个正则表达式的pattern(模式)可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带零个或多个 flags(标记)，用于控制正则表达式的行为。下面给出了表示匹配模式的标记。</p>
<ul>
<li><p>g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。</p>
</li>
<li><p>i：不区分大小写，表示在查找匹配时忽略pattern和字符串的大小写。</p>
</li>
<li><p>m：多行模式，表示查找到一行文本末尾时会继续查找。</p>
</li>
<li><p>y：粘附模式，表示只查找从1astIndex开始及之后的字符串。</p>
</li>
<li><p>u：Unicode模式，启用Unicode匹配。</p>
</li>
<li><p>s：dotA11模式，表示元字符，匹配任何字符(包括\n或\r)。</p>
</li>
</ul>
<h3 id="5-2-1-RegExp实例属性"><a href="#5-2-1-RegExp实例属性" class="headerlink" title="5.2.1 RegExp实例属性"></a>5.2.1 RegExp实例属性</h3><p>每个RegExp实例都有下列属性，提供有关模式的各方面信息。</p>
<p>+　global：布尔值，表示是否设置了g标记。</p>
<p>+　ignoreCase：布尔值，表示是否设置了1标记。</p>
<p>+　unicode：布尔值，表示是否设置了u标记。</p>
<p>+　sticky：布尔值，表示是否设置了y标记</p>
<p>+　astIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。</p>
<p>+　multiline：布尔值，表示是否设置了m标记。</p>
<p>+　dotA11：布尔值，表示是否设置了。标记。</p>
<p>+　source：正则表达式的字面量字符串(不是传给构造函数的模式字符串)，没有开头和结尾的斜杠。</p>
<p>+　f1ags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回(没5有前后斜杠)。</p>
<p>通过这些属性可以全面了解正则表达式的信息，不过实际开发中用得并不多，因为模式声明中包含这些信息。</p>
<h3 id="5-2-2-实例方法"><a href="#5-2-2-实例方法" class="headerlink" title="5.2.2 实例方法"></a>5.2.2 实例方法</h3><p>1）<code>exex()</code></p>
<p>Regexp实例的主要方法是 <code>exec()</code> ，主要用于配合<strong>捕获组</strong>使用。</p>
<p>这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一不匹配信息的数组；如果没找到匹配项，则返回null。</p>
<p>返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。index是字符串中匹配模式的起始位置，input是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素。</p>
<blockquote>
<p>这里不再继续讨论 <code>exec()</code> 方法的使用，可以自行百度详细用法。或者这里我搜了两篇说的还不错的文章：</p>
<p><a href="https://blog.csdn.net/qq_35087256/article/details/79966865">https://blog.csdn.net/qq_35087256/article/details/79966865</a> | <a href="https://segmentfault.com/a/1190000018864720">https://segmentfault.com/a/1190000018864720</a></p>
</blockquote>
<p>2）<code>test()</code></p>
<p>正则表达式的另一个方法是 <code>test()</code>，接收一个字符串参数。如果输入的文本与模式匹配，则参数返回true，否则返回false。</p>
<p>这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。<code>test()</code> 经常用在if语句中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text =<span class="string">&quot;000-00-0000°;</span></span><br><span class="line"><span class="string">let pattern/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/；</span></span><br><span class="line"><span class="string">if (pattern.test(text))</span></span><br><span class="line"><span class="string">    console.log (&quot;</span>The pattern was matched.<span class="string">&quot;);</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，正达式用于测试特定的数值序列。如果输入的文本与模式匹配，则显示匹配成功的消息。这个用法常用于验证用户输入，此时我们只在乎输入是否有效，不关心为什么无效。</p>
<p>无论正则表达式是怎么创建的，继承的方法 <code>toLocaleString()</code> 和 <code>toString()</code>都返回正则表达式的字面量表示。</p>
<blockquote>
<p>注意：正则表达式的 <code>valueOf()</code>方法返回正则表达式本身。 </p>
</blockquote>
<h3 id="5-2-3-RegExp构造函数属性"><a href="#5-2-3-RegExp构造函数属性" class="headerlink" title="5.2.3 RegExp构造函数属性"></a>5.2.3 RegExp构造函数属性</h3><blockquote>
<p>这里不进行讨论。</p>
</blockquote>
<blockquote>
<p>注意：RegExp构造函数的所有属性都没有任何Web标准出处，因此不要在生成环境中使用它们。</p>
</blockquote>
<br>

<h2 id="5-3-原始值包装类型"><a href="#5-3-原始值包装类型" class="headerlink" title="5.3 原始值包装类型"></a>5.3 原始值包装类型</h2><p>为了方便操作原始值，ECMAScript提供了3种特殊的引用类型：Boolean、Number和String。</p>
<p>这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sl = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = sl.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>在这里，s1是一个包含字符串的变量，它是一个原始值。第二行紧接着在s1上调用了substring()方法，并把结果保存在s2中。我们知道，<strong>原始值本身不是对象，因此逻辑上不应该有方法</strong>。而实际上这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作。具体来说，当第二行访问s1时，是以读模式访问的，也就是要从内存中读取变量保存的值。</p>
<p>在以读模式访问字符串值的任何时候，后台都会执行以下3步：</p>
<ol>
<li><p><strong>创建一个string类型的实例；</strong></p>
</li>
<li><p><strong>调用实例上的特定方法；</strong></p>
</li>
<li><p><strong>销毁实例。</strong></p>
</li>
</ol>
<p>可以把这3步想象成执行了如下3行ECMAScript代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>这种行为可以<strong>让原始值拥有有对象的行为</strong>，对布尔值和数值而言，以上3步也会在后台发生，只不过使用的是Boolean和Number包装类型而已。</p>
<p><strong>引用类型与原始值包装类型的主要区别在于对象的生命周期</strong>，<strong>在通过new实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访同它的那行代码执行期间。</strong></p>
<p><strong>这意味着不能在运行时给原始值添加属性和方法</strong>。比如下面的倒子：</p>
<p>可以显式地使用Boolean、Number和string构造函数创建原始值包装对象。不过应该在确实必要时再这么做，否则容易让开发者疑惑，分不清它们到底是原始值还是引用值。在原始值包装类型的实例上调用 <code>typeof</code> 会返回object，<strong>所有原始值包装对象都会转换为布尔值true</strong>。</p>
<p>另外，Object 构透函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span> (<span class="string">&quot;sometext&quot;</span>)；</span><br><span class="line"><span class="built_in">console</span>.log(obj intanceof string); <span class="comment">//-&gt; true</span></span><br><span class="line"><span class="comment">//如果传给Object的是字符串，则会创建一个String的实例。如果是数值，则会创建Number的实例。布尔值则会得到Boolean的实例。</span></span><br></pre></td></tr></table></figure>
<p>注意，<strong>使用new调用原始值包装类型的构造函数，与调用同名的转型函数并不一样</strong>。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="string">&quot;25&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> number = <span class="built_in">Number</span>(value); <span class="comment">// 转型函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> number), <span class="comment">//-&gt; &quot;number”</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value); <span class="comment">// 构造函數</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj); <span class="comment">//-&gt; &quot;object&quot;</span></span><br></pre></td></tr></table></figure>
<p>虽然不推荐显式创建原始值包装类型的实例，但它们对于操作原始值的功能是很重要的。每个原值包装类型都有相应的一套方法来方便数据操作</p>
<h3 id="5-3-1-Boolean"><a href="#5-3-1-Boolean" class="headerlink" title="5.3.1 Boolean"></a>5.3.1 Boolean</h3><p>Boolean是对应布尔值的引用类型。要创建一个Boolean对象，就使用Boolean构造函数并传true或false，如下例所示：</p>
<p><code>let booleanobject = new Boolean(true);</code></p>
<p>Boolean 的实例会重写 <code>valueOf()</code>方法，返回一个原始值true 或 false。<code>toString()</code>方法被调用时也会被覆盖，返回字符串”true”或”false”。不过，Boolean对象在ECMAScript中用得很少。不仅如此，它们还容易引起误会，尤其是在布尔表达式中使用Boolean对象时。</p>
<p>除此之外，原始值和引用值(Boolean对象)还有几个区别。首先，<code>typeof</code>操作符对原始值返回“boolean”，但对引用值返回“object”。同样，Boolean对象是 Boolean 类型的实例，在使用 <code>instanceof</code> 操作符时返回true，但对原始值则返回false，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseObject); <span class="comment">//-&gt; object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseValue);  <span class="comment">//-&gt; boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(falseObject <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);  <span class="comment">//-&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(falseValue <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>): <span class="comment">//-&gt; false</span></span><br></pre></td></tr></table></figure>
<p><strong>理解原始布尔值和Boolean对象之间的区别非常重要，强烈建议永远不要使用后者</strong>。</p>
<h3 id="5-3-2-Number"><a href="#5-3-2-Number" class="headerlink" title="5.3.2 Number `"></a>5.3.2 Number `</h3><p>Number是对应数值的引用类型。要创建一个Number对象，就使用Number构造函数并传入一个数值，如下例所示：</p>
<p><code>let NumberObject = new Number(10);</code></p>
<h4 id="1）继承的方法："><a href="#1）继承的方法：" class="headerlink" title="1）继承的方法："></a>1）继承的方法：</h4><p>与Boolean 类型一样，Number 类型重写了 <code>valueOf()</code> 、<code>totocalestring()</code> 和<code> toString()</code> 方法。</p>
<p><code>valueOf()</code>方法返回Number对象表示的原始数值，另外两个方法返回数值字符串。</p>
<p><code>toString()</code> 方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串。</p>
<h4 id="2）将数值格式化为字符串的方法："><a href="#2）将数值格式化为字符串的方法：" class="headerlink" title="2）将数值格式化为字符串的方法："></a>2）将数值格式化为字符串的方法：</h4><p><code>toFixed()</code> 方法返回包含指定小数点位数的数值字符串，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>));  <span class="comment">//-&gt; &quot;10.00&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位。这个特点可以用于处理货币。但是要注意，多个浮点数值的数学计算不一定得到精确的结果。</p>
<blockquote>
<p> 注意：<code>toFixed()</code>方法可以表示有0-20个小数位的数值。某些浏览器可能支持更大的范围，但这是通常被支持的范围。</p>
</blockquote>
<p><code>toExponential()</code>，返回以科学记数法(也称为指数记数法)表示的数值字符串。与<code>toFixed()</code>一样，该方法也接收一个参数，表示结果中小数的位。</p>
<p><code>toPrecision()</code>方法会给根据情况返回最合理的验出结果。可能是固定长度，也可能是科学记数形式。这个方法接收一个参数，表示结果中数字的总位数(不包含指数)。来看几个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">99</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toprecision(<span class="number">1</span>));  <span class="comment">//-&gt; &quot;1e+2&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">2</span>));  <span class="comment">//-&gt; &quot;99&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">3</span>));  <span class="comment">//-&gt; &quot;99.0&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，首先要用1位数字表示数值99，得到“1e+2”，也就是100。因为99不能只用1数字来精确表示，所以这个方法就将它舍入为100，这样就可以只用1位数字（及其科学记数法形式）来表示了。</p>
<p>用2位数字表示99得到“99”，用3位数字则是“99.0”。本质上，<code>toPrecision()</code> 方法根据数值和精度来决定调用<code>toFixed()</code>还是<code>toExponentia1()</code>。为了以正确的小数位精确表示数值，这3个方法都会向上或向下s舍入。</p>
<blockquote>
<p>注意 <code>toprecisionl()</code>方法可以表示带1-21个小数位的数值。某些浏览器可能支持更大的范围，但这是通常被支持的范围。</p>
</blockquote>
<h4 id="3）-isInteger-方法与安全整数"><a href="#3）-isInteger-方法与安全整数" class="headerlink" title="3）**isInteger() 方法与安全整数** *"></a>3）**<code>isInteger()</code> 方法与安全整数** *</h4><p>ES6新增了 <code>Number.isInteger()</code> 方法，用于辨别一个数值是否保存为整数。</p>
<p>IEEE 754数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。这个数值范围从<code>Number.MIN_SAFE_INTEGER</code> (-2^53+1) 到 <code>Number.MAX_SAFE_INTEGER</code> (2^53-1)。对超出这个范围的数值，即使尝试保存为整数，IEEE754 编码格式也意味着二进制值可能会表示一个完全不同的数值。为了鉴别整数是否在这个范围内，可以使用 <code>Number.isSafeInteger()</code>方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(-<span class="number">1</span> * (<span class="number">2</span> ** <span class="number">53</span>)));  <span class="comment">//-&gt;  false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(-<span class="number">1</span> * (<span class="number">2</span> ** <span class="number">53</span>) + <span class="number">1</span>));  <span class="comment">//-&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(<span class="number">2</span> ** <span class="number">53</span>)); <span class="comment">//-&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger((<span class="number">2</span> ** <span class="number">53</span>) - <span class="number">1</span>)); <span class="comment">//-&gt; true</span></span><br></pre></td></tr></table></figure>
<br>

<h3 id="5-3-3-String"><a href="#5-3-3-String" class="headerlink" title="5.3.3 String `"></a>5.3.3 String `</h3><p>String 是对应字符串的引用类型。要创建一个String对象，使用String构造函数并传入一个数值，如下例所示：</p>
<p><code>let stringobject = new String(hello wor1d&quot;);</code></p>
<p><strong>String对象的方法可以在所有字符串原始值上调用</strong>。3个继承的方法 <code>valueOf()</code>、<code>toLocaleString()</code>和<code>toString()</code>都返回对象的原始字符串值。每个String对象都有一个1ength属性，表示字符串中字符的数量。</p>
<h4 id="1-JavaScript字符"><a href="#1-JavaScript字符" class="headerlink" title="1. JavaScript字符"></a>1. JavaScript字符</h4><p>1）<strong>16位码元字符</strong></p>
<p>JavaScript字符串由<strong>16位码元</strong>(code unit)组成。对多数字符来说，每16位码元对应一个字符。换句话说，字符串的 <code>1ength</code>属性表示字符串包含多少16位码元；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message =<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.length); <span class="comment">//-&gt; 5</span></span><br></pre></td></tr></table></figure>
<p><code>charAt ()</code> 方法返回给定索引位置的字符，由传给方法的整数参数指定。具体来说，这个方法查找指定索引位置的16位码元，并返回该码元对应的字符。</p>
<p> <code>charCodeAt()</code>为法可以查看指定码元的字将编码码，这个方法返回指定索引位置的码元值，索引以整数指定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&#x27;abcde&#x27;</span>;</span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter C&quot; 的编码是 U+0063</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">2</span>));  <span class="comment">//-&gt; 99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//十进制 99 等于十六进制 63</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">99</span> === <span class="number">0x63</span>); <span class="comment">//-&gt; true</span></span><br></pre></td></tr></table></figure>
<p><code>fromcharCode()</code>方法用于根据价定的UTF-16码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符申：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Unicode &quot;Latin small letter a&quot; 的编码是 U+0061</span></span><br><span class="line"><span class="comment">//Unicode &quot;Latin small letter b&quot; 的编码是 U+0062</span></span><br><span class="line"><span class="comment">//Unicode &quot;Latin small letter C&quot; 的编码是 U+0063</span></span><br><span class="line"><span class="comment">//Unicode &quot;Latin small letter d&quot; 的编码是 U+0064</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x61</span>,<span class="number">0x62</span>,<span class="number">0x63</span>,<span class="number">0x64</span>));  <span class="comment">//-&gt; abcd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//0x0061 === 97</span></span><br><span class="line"><span class="comment">//0x0062 === 98</span></span><br><span class="line"><span class="comment">//0x0063 === 99</span></span><br><span class="line"><span class="comment">//0x0064 === 100</span></span><br><span class="line"><span class="built_in">console</span>.log (<span class="built_in">String</span>.fromCharCode(<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>); <span class="comment">//-&gt; abcd</span></span><br></pre></td></tr></table></figure>
<p><em>JavaScript字符串使用了两种Unicode编码混合的策略：UCS-2和UTF-16。对于可以采用16位编码的字符(U+0000 ~ U+FFFF)，这两种编码实际上是一样的。</em></p>
<p>2）<strong>代理对</strong></p>
<p>对于U+0000-U+FFFF范围内的字符，<code>length</code>、 <code>charAt()</code>、<code>charCodeAt()</code>和 <code>fromCharCode()</code> 返回的结果都跟预期是一样的。这是因为在这个范围内，每个字符都是用16位表示的，而这几个方法也都基于16位码元完成操作。只要字符编码大小与码元大小一一对应，这些方法就能如期工作。</p>
<p>这个对应关系在扩展到 Unicode增补字符平面时就不成立了。问题很简单，即16位只能唯一表示<strong>65536</strong>个字符。这对于大多数语言字符集是足够了，在 Unicode中称为<strong>基本多语言平面</strong>(BMP)。为了表示更多的字符，Unicode采用了一个策略，即每个字符使用另外16位去选择一个<strong>增补平面</strong>。</p>
<p>这种<strong>每字符使用两个16位码元</strong>的策略称为<strong>代理对</strong>。</p>
<p>在涉及增补平面的字符时，前面讨论的字符串方法就会出问题。比如，下面的例子中使用了一个笑脸表情符号，也就是一个使用代理对编码的字符：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&quot;smiling face with smiling eyes&quot;表情符号的編码是 U+1F60A</span></span><br><span class="line"><span class="comment">//0x1F60A === 128522</span></span><br><span class="line"><span class="keyword">let</span> message=<span class="string">&quot;ab☻de&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.length); <span class="comment">//-&gt; 6</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charAt(<span class="number">1</span>)); <span class="comment">//-&gt; b</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charAt(<span class="number">2</span>)); <span class="comment">//-&gt; &lt;?&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charAt(<span class="number">3</span>)); <span class="comment">//-&gt; &lt;?&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charAt(<span class="number">4</span>)); <span class="comment">//-&gt; d</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">1</span>)); <span class="comment">//-&gt; 98</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">2</span>)); <span class="comment">//-&gt; 55357</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">3</span>)); <span class="comment">//-&gt; 56842</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">4</span>)); <span class="comment">//-&gt; 100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">0x1F60A</span>));  <span class="comment">//-&gt; ☻</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">97</span>,<span class="number">98</span>,<span class="number">55357</span>,<span class="number">56842</span>,<span class="number">100</span>,<span class="number">101</span>)); <span class="comment">//-&gt; ab☻de</span></span><br></pre></td></tr></table></figure>
<p>这些方法仍然将16位码元当作一个字符，事实上<strong>索引2和索引3对应的码元应该被看成一个代理对，只对应一个字符</strong>。<code>fromCharCode()</code>方法仍然返回正确的结果，因为它实际上是基于提供的二进制表示直接组合成字符串。浏览器可以正确解析代理对(由两个码元构成)，并正确地将其识别为一个Unicode笑脸字符。</p>
<p>为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用 <code>codePointAt()</code> 来代替 <code>charCodeAt()</code> 。跟使用<code>charCodeAt()</code>时类似，<code>codePointAt()</code> 接收16位码元的索引并返回该索引位置上的码点(code point)。码点是Unicode中一个字符的完整标识。比如，“ c ”的码点是0x0063，而“ ☻ ”的码点是0x1F60A。码点可能是16位，也可能是32位，而 <code>codePointAt()</code>方法可以从指定码元位置识别完整的码点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;ab☻de&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.codePointAt(<span class="number">1</span>));  <span class="comment">//-&gt; 98</span></span><br><span class="line"><span class="built_in">console</span>.log(message.codePointAt(<span class="number">2</span>));  <span class="comment">//-&gt; 128522</span></span><br><span class="line"><span class="built_in">console</span>.log(measage.codePointAt(<span class="number">3</span>));  <span class="comment">//-&gt; 56842</span></span><br><span class="line"><span class="built_in">console</span>.log(message.codePointAt(<span class="number">4</span>));  <span class="comment">//-&gt; 100</span></span><br></pre></td></tr></table></figure>
<p>注意，如果传入的码元索引并非代理对的开头，就会返回错误的码点。这种错误只有检测单个字的时候才会出现，可以通过从左到右按正确的码元数遍历字符串来规避。迭代字符串可以智能地识别理对的码点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([...<span class="string">&quot;ab☻de&quot;</span>]);  <span class="comment">//-&gt; [&quot;a&quot;,&quot;b&quot;,&quot;☻&quot;,&quot;d&quot;,&quot;e&quot;]</span></span><br></pre></td></tr></table></figure>
<p><code>fromCharCode()</code>也有一个对应的 <code>fromcodePoint()</code>。 这个方法接收任意数量的码点，返回对应字符拼接起来的字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">97</span>,<span class="number">98</span>,<span class="number">55357</span>,<span class="number">56842</span>,<span class="number">100</span>,<span class="number">101</span>));  <span class="comment">//-&gt; ab☻de </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">97</span>,<span class="number">98</span>,<span class="number">128522</span>,<span class="number">100</span>,<span class="number">101</span>));  <span class="comment">//-&gt; ab☻de</span></span><br></pre></td></tr></table></figure>


<h4 id="2-normalize-方法"><a href="#2-normalize-方法" class="headerlink" title="2. normalize()方法"></a>2. normalize()方法</h4><p>某些 Unicode字符可以有多种编码方式。有的字符既可以通过一个BMP字符表示，也可以通过代理对表示。</p>
<blockquote>
<p>该方法主要是为字符串应用四种规范化形式：NFD、NFC，NFKD和NFKC。至于这四种形式具体含义和该方法的使用，因为应用情况的罕见这里不作总结。可以自行百度了解。</p>
</blockquote>
<h4 id="3-字符串操作方法"><a href="#3-字符串操作方法" class="headerlink" title="3. 字符串操作方法"></a>3. 字符串操作方法</h4><p><code>concat()</code> 用于将一个或多个字符串拼接成一个新字符串。</p>
<p><code>slice()</code>、<code>substr()</code>、<code>subString()</code> 用于从字符串中提取子字符串。</p>
<h4 id="4-字符串位置方法"><a href="#4-字符串位置方法" class="headerlink" title="4. 字符串位置方法"></a>4. 字符串位置方法</h4><p><code>indexOf()</code> 和 <code>lastIndexOf()</code> 用于在字符串中定位子字符串。</p>
<h4 id="5-字符串包含方法"><a href="#5-字符串包含方法" class="headerlink" title="5. 字符串包含方法 *"></a>5. 字符串包含方法 *</h4><p>ES6新增了3个用于判断字符串中是否包含另一个字符串的方法：<code>startsWith()</code> 、 <code>endWith()</code> 和 <code>includes()</code>。</p>
<h4 id="6-trim-方法"><a href="#6-trim-方法" class="headerlink" title="6. trim()方法"></a>6. trim()方法</h4><p>ECMAScript在所有字符串上都提供了 <code>trim()</code> 方法。这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果。原始字符串不会受影响。</p>
<p><code>trimLeft()</code> 和 <code>trimRight()</code> 方法分别用于从字符串开始和结尾清理空格符。</p>
<h4 id="7-repeat-方法"><a href="#7-repeat-方法" class="headerlink" title="7. repeat()方法"></a>7. repeat()方法</h4><p>ECMAScript在所有字符串上都提供了 <code>repeat()</code> 方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。</p>
<h4 id="8-padStart-和-padEnd-方法"><a href="#8-padStart-和-padEnd-方法" class="headerlink" title="8. padStart() 和 padEnd() 方法"></a>8. padStart() 和 padEnd() 方法</h4><p> <code>padStart()</code> 和 <code>padEnd()</code> 方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（U+0020）。</p>
<h4 id="9-字符串迭代与解构"><a href="#9-字符串迭代与解构" class="headerlink" title="9. 字符串迭代与解构"></a>9. 字符串迭代与解构</h4><p>字符中的原型上暴露了一个<code>@@iterator</code>方法，表示可以迭代字符串的每个字符。可以像下面这样手动使用迭代器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> stringIterator = message[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());  <span class="comment">//-&gt; (value:&quot;a&quot;, done:false)</span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());  <span class="comment">//-&gt; (value:&quot;b&quot;, done:false)</span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());  <span class="comment">//-&gt; (value:&quot;c&quot;, done:false)</span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());  <span class="comment">//-&gt; (value: undefined, done: true)</span></span><br></pre></td></tr></table></figure>

<p>在for-of循环中可以通过这个迭代器按序访问每个字符：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="string">&quot;abcde&quot;</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-&gt; a</span></span><br><span class="line"><span class="comment">//-&gt; b</span></span><br><span class="line"><span class="comment">//-&gt; c</span></span><br><span class="line"><span class="comment">//-&gt; d</span></span><br><span class="line"><span class="comment">//-&gt; e</span></span><br></pre></td></tr></table></figure>

<p>有了这个迭代器之后，字符串就可以通过解构操作符来解构了。比如，可以更方便地把字符串分割为字符数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log([...message]); <span class="comment">//-&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]</span></span><br></pre></td></tr></table></figure>
<h4 id="10-字符串大小写转换"><a href="#10-字符串大小写转换" class="headerlink" title="10.字符串大小写转换"></a>10.字符串大小写转换</h4><p>下一组方法涉及大小写转换，包括4个方法：<code>toLowerCase()</code>、<code>tolocaleLowerCase()</code> 、<code>toUpperCase()</code> 和 <code>toLocaleCase()</code>。</p>
<h4 id="11-字符串模式匹配方法"><a href="#11-字符串模式匹配方法" class="headerlink" title="11. 字符串模式匹配方法"></a>11. 字符串模式匹配方法</h4><p>匹配字符串：<code>match()</code> 。本质上与RegExp对象的 <code>exec()</code> 方法相同。</p>
<p>查找字符串：<code>search()</code> 。</p>
<p>替换字符串：<code>replace()</code> 。</p>
<p>拆分字符串：<code>split()</code> 。</p>
<h4 id="12-localeCompare-方法"><a href="#12-localeCompare-方法" class="headerlink" title="12. localeCompare() 方法"></a>12. localeCompare() 方法</h4><h2 id="5-4-单例内置对象"><a href="#5-4-单例内置对象" class="headerlink" title="5.4 单例内置对象"></a>5.4 单例内置对象</h2><p>ECMA-262对内置对象的定义是“<strong>任何由ECMAScript实现提供、与宿主环境无关，并在ECMAScript程序开始执行时就存在的对象</strong>”。这就意味着，开发者不用显式地实例化内置对象，因为它们已经实例化好了。前面我们已经接触了大部分内置对象，包括Object、Array和String。本节介绍 ECMA-262定义的另外两个单例内置对象：G1obal和Math。</p>
<h3 id="5-4-1-Global"><a href="#5-4-1-Global" class="headerlink" title="5.4.1 Global"></a>5.4.1 Global</h3><p>G1obal对象是ECMAScript中最特别的对象，因为代码不会显式地访问它。ECMA-262规定G1obal对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。</p>
<p><strong>事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成G1obal对象的属性。</strong></p>
<p>本书前面介绍的函数，包括 <code>isNaN()</code>、<code>isFinite()</code>、<code>parseInt()</code>和 <code>parseFloat()</code>，实际上都是G1obal对象的方法。除了这些，G1obal对象上还有另外一些方法。</p>
<h4 id="1-URL编码方法"><a href="#1-URL编码方法" class="headerlink" title="1. URL编码方法"></a>1. URL编码方法</h4><p><code>encodeURI()</code>和 <code>encodeURIComponent()</code>方法用于编码统一资源标识符(URI)，以便传给浏览器。有效的URI不能包含某些字符，比如空格。使用URI编码方法来编码URI可以让浏览器能够理解它们，同时又以特殊的UTF-8编码替换掉所有无效字符。</p>
<p><code>ecnodeURI()</code>方法用于对整个URI进行编码，比如 “<a href="http://www.wrox.com/illegal">www.wrox.com/illegal</a> value.js”。而<code>encodeURIComponent()</code>方法用于编码URI中单独的组件，比如前面URL中的 “i11egal value.js”。</p>
<h4 id="2-eval-方法"><a href="#2-eval-方法" class="headerlink" title="2. eval() 方法"></a>2. eval() 方法</h4><p>这个方法可能是整个ECMAScript语言中最强大的了。这个方法就是一个完整的ECMAScript解释器，它接收一个参数，即一个要执行的ECMAScript字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;alert(&#x27;hello&#x27;)&quot;</span><span class="string">&quot;);</span></span><br><span class="line"><span class="string">//等价于下面的语句</span></span><br><span class="line"><span class="string">alert(&quot;</span>hello<span class="string">&quot;);</span></span><br></pre></td></tr></table></figure>
<p>当解释器发现 <code>eval()</code> 调用时，会将参数解释为实际的ES语句，然后将其插入到该位置。通过 <code>eval()</code> 执行的代码属于该调用所在的上下文，被执行的代码与该上下文<strong>拥有相同的作用域链</strong>。这意味着定义在包含上下文中的变量可以在 <code>eval()</code> 调用内部被引用，比如下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(msg)&quot;</span>);  <span class="comment">//-&gt; &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>eval()</code> 定义的任何变量和函数都<strong>不会被提升</strong>，这是因为在解析代码的时候，它们是被包含在一个字符串中的。它们只是在 <code>eval()</code> 执行的时候才会被创建。</p>
<p>在严格模式下，在 <code>eval()</code> 内部创建的变量和函数无法被外部访问。</p>
<blockquote>
<p>注意：解释代码字符串的能力是非常强大的，但也非常危险。在使用 <code>eval()</code>的时候必须极为慎重，特别是在解释用户输入的内容时。因为这个方法会对XSS利用暴露出很大的攻击面。恶意用户可能插入会导致你网站或应用崩溃的代码。</p>
</blockquote>
<h4 id="3-Global对象属性"><a href="#3-Global对象属性" class="headerlink" title="3. Global对象属性"></a>3. Global对象属性</h4><blockquote>
<p>这里不再列出。</p>
</blockquote>
<h4 id="4-window对象"><a href="#4-window对象" class="headerlink" title="4. window对象"></a>4. window对象</h4><p>虽然ECMA-262没有规定直接访问Global对象的方式，但<strong>浏览器将window对象实现为Global对象的代理</strong>。因此，所有全局作用域中声明的变量和函数都变成了window的属性。</p>
<blockquote>
<p>window对象会在第12章更加详细的介绍。</p>
</blockquote>
<h3 id="5-4-2-Math"><a href="#5-4-2-Math" class="headerlink" title="5.4.2 Math"></a>5.4.2 Math</h3><blockquote>
<p>这里不再介绍。</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>学习笔记</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>JavaScript</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>map与object的差异与选择</title>
    <url>/2021/03/18/map%E4%B8%8Eobject%E7%9A%84%E5%B7%AE%E5%BC%82%E4%B8%8E%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h1 id="Map与Object的差异与选择"><a href="#Map与Object的差异与选择" class="headerlink" title="Map与Object的差异与选择"></a>Map与Object的差异与选择</h1><p>ES6以前，我们可以使用Object方便高效地完成“键/值”式的存储，但是这种实现并非没有问题。因此，TC39委员会专门为“键/值”存储定义了一个规范，即Map。它是一种新的集合类型，为这门语言带来了真正地键/值存储机制。</p>
<a id="more"></a>

<h2 id="Object和Map的细微语法差异"><a href="#Object和Map的细微语法差异" class="headerlink" title="Object和Map的细微语法差异"></a>Object和Map的细微语法差异</h2><h3 id="1-键的数据类型"><a href="#1-键的数据类型" class="headerlink" title="1. 键的数据类型"></a>1. 键的数据类型</h3><p><strong>与Object只能使用数值、字符串或符号作为键不同，Map可以使用任何JS的数据类型作为键。</strong></p>
<p>Map内部使用<strong>严格对象相等</strong>的标准来检查键的匹配性。当然，与Object类似，映射的值是没有限制的。</p>
<br>
<!--more-->

<h3 id="2-顺序与迭代"><a href="#2-顺序与迭代" class="headerlink" title="2. 顺序与迭代"></a>2. 顺序与迭代</h3><p>与Object类型的一个主要差异是，Map实例会维护键值对的插入顺序，这也就意味着<strong>可以根据插入顺序进行迭代操作</strong>。</p>
<p><strong>迭代方式：</strong></p>
<p>1）映射实例可以提供一个迭代器（Iterator），能以插入顺序生成 [key,value] 形式的数组。可以通过<code>entries()</code>方法（或者<code>Symbol.iterator</code> 属性，它引用 <code>entries()</code> 方法）取得这个迭代器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;val1&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;val2&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;val3&quot;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Symbol.iterator引用entries()方法</span></span><br><span class="line">alert(m.entries === m[<span class="built_in">Symbol</span>.iterator]);  <span class="comment">//-&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代，使用m[Symbol.iterator]一样可以</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> pair <span class="keyword">of</span> m.entries())  alert(pair);</span><br><span class="line"><span class="comment">//-&gt; [key1,val1]</span></span><br><span class="line"><span class="comment">//-&gt; [key2,val2]</span></span><br><span class="line"><span class="comment">//-&gt; [key3,val3]</span></span><br></pre></td></tr></table></figure>
<p>因为<code>entries()</code>是默认迭代器，所以<strong>可以直接对映射实例使用扩展操作，把映射转化为数组</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;val1&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;val2&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;val3&quot;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([...m]);  <span class="comment">//-&gt; [[key1,val1],[ley2,val2],[key3,val3]]</span></span><br></pre></td></tr></table></figure>
<p>2）不使用迭代器，而是用回调方式的话，可以调用映射的<code>forEach()</code> 方法并传入回调，依次迭代每个键值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部this的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;val1&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;val2&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;val3&quot;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">m.forEach(<span class="function">(<span class="params">val,key</span>) =&gt;</span> alert(<span class="string">`<span class="subst">$&#123;key&#125;</span> -&gt; <span class="subst">$&#123;val&#125;</span>`</span>));</span><br><span class="line"><span class="comment">// key1 -&gt; val1</span></span><br><span class="line"><span class="comment">// key2 -&gt; val2</span></span><br><span class="line"><span class="comment">// key3 -&gt; val3</span></span><br></pre></td></tr></table></figure>
<p>3）<code>keys()</code> 和 <code>values()</code> 分别返回以插入顺序生成键和值的迭代器。</p>
<p>键和值在迭代器遍历时是可以修改的，但映射内部的引用无法修改。当然，这并不妨碍修改作为键或值的的对象内部的属性，因为这并不影响它们在映射实例中的身份。</p>
<br>

<h2 id="选择Object还是Map"><a href="#选择Object还是Map" class="headerlink" title="选择Object还是Map"></a>选择Object还是Map</h2><blockquote>
<p>以下内容直接采用红宝书原话。结论直接看加粗文本。</p>
</blockquote>
<p>对于多数 Web开发任务来说，选择Object还是Map只是个人偏好问题，影响不大。不过，对于在乎内存和性能的开发者来说，对象和映射之间确实存在显著的差别。</p>
<ol>
<li><p>内存占用</p>
<p>Object和Map的工程级实现在不同浏览器间存在明显差异，但<strong>存储单个键值对所占用的内存数都会随键的数量线性增加</strong>。批量添加或删除键/值对则取决于各浏览器对该类型内存分配的工程实现不同浏览器的情况不同，<strong>但给定固定大小的内存，Map大约可以比Object多存储50%的键/值对</strong>。</p>
</li>
<li><p>插入性能</p>
<p>向Object和Map中插入新键/值对的消耗大致相当，不过插入Map在所有浏览器中一般会稍微快一点儿。对这两个类型来说，插入速度并不会随着键/值对数量而线性增加。<strong>如果代码涉及大量插入操作，那么显然Map的性能更佳。</strong></p>
</li>
<li><p>查找速度</p>
<p>与插入不同，从大型Object和Map中查找键/值对的性能差异极小，但如果只包含少量键/值对，则Object有时候速度更快。在把object当成数组使用的情况下(比如使用连续整数作为属性)，浏览器引擎可以进行优化，在内存中使用更高效的布局。这对Map来说是不可能的。<strong>对这两个类型而言，查找速度不会随着键/值对数量增加而线性增加</strong>。如果<strong>代码涉及大量查找操作，那么某些情况下可能选择Object更好一些</strong>。</p>
</li>
<li><p>删除性能</p>
<p>使用delete删除Object属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此，出现了一些伪删除对象属性的操作，包括把属性值设置为undefined或null。但很多时候，这都是一种讨厌的或不适宜的折中。而对大多数浏览器引擎来说，Map的 delete() 操作都比插入和查找更快。<strong>如果代码涉及大量删除操作，那么毫无疑问应该选择Map</strong>。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>学习笔记</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>JavaScript</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ajax学习笔记(新)</title>
    <url>/2021/02/05/ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<h2 id="1-Ajax实现步骤"><a href="#1-Ajax实现步骤" class="headerlink" title="1. Ajax实现步骤"></a>1. Ajax实现步骤</h2><ol>
<li><p>创建ajax对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure></li>
<li><p>告诉ajax请求地址及请求方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;http://www.example.com&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>发送请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></li>
<li><p>获取服务器端与客户端的响应数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.onload = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xrh.responseText)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

</li>
</ol>
<blockquote>
<p>服务器端响应的数据格式</p>
<p>真实项目中，服务器端大多数情况下会以<strong>JSON对象</strong>作为响应数据的格式。当客户端拿到响应数据时，要将JSON数据和HTML字符串进行拼接，然后将拼接的结果展示在页面中。</p>
<p>在http请求与响应的过程中，无论是请求参数还是响应内容，如果是对象类型，最终都会被转换为对象字符串进行传输。</p>
<p>使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse();   <span class="comment">//将json字符串转化为json对象</span></span><br></pre></td></tr></table></figure>
<br>
</blockquote>
<h2 id="2-请求参数传递"><a href="#2-请求参数传递" class="headerlink" title="2. 请求参数传递"></a>2. 请求参数传递</h2><p>1）传统网站表单提交</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://www.example.com&quot;</span> <span class="attr">method</span>=<span class="string">&quot;GET&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uname&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 此时的请求地址：</span></span><br><span class="line"><span class="comment">     http://www.example.com?uname=jack&amp;pwd=1234  --&gt;</span></span><br></pre></td></tr></table></figure>
<p>2）GET请求方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;http://www.example.com?uname=jack&amp;pwd=1234&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>3）POST请求方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置请求参数格式的类型</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">xhr.send(<span class="string">&#x27;uname=jack&amp;pwd=1234&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="请求报文："><a href="#请求报文：" class="headerlink" title="请求报文："></a>请求报文：</h3><p><a href="https://img.imgdb.cn/item/601ced793ffa7d37b3d8c557.png"><img src="https://img.imgdb.cn/item/601ced793ffa7d37b3d8c557.png"></a></p>
<h3 id="请求参数的格式"><a href="#请求参数的格式" class="headerlink" title="请求参数的格式:"></a>请求参数的格式:</h3><p>1）application/x-www-form-urlencoded</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">uname=jack&amp;age=20</span><br></pre></td></tr></table></figure>
<p>2）application/json</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;name:&#x27;jack&#x27;,age:&#x27;20&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>在请求头中指定Content-type属性的值是application/json，告诉服务器端当前请求参数的格式是json。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringfy();   <span class="comment">//将json对象转化为json字符串</span></span><br></pre></td></tr></table></figure>
<br>

<h2 id="参考：Ajax对象的属性、方法"><a href="#参考：Ajax对象的属性、方法" class="headerlink" title="参考：Ajax对象的属性、方法"></a>参考：Ajax对象的属性、方法</h2><p>火狐开发者文档：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest</a> </p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><p>*<em>readyState： Ajax状态码  **<br>0：表示对象已建立，但未初始化，只是 new 成功获取了对象，但是未调用open方法<br>1：表示对象已初始化，但未发送，调用了open方法，但是未调用send方法<br>2：已调用send方法进行请求<br>3：正在接收数据（接收到一部分），客户端已经接收到了一部分返回的数据<br>**4：接收完成，客户端已经接收到了所有数据 * *</em></p>
</li>
<li><p>status ：http响应状态码<br>200代表成功获取服务器端数据<br>404未找到页面等等……</p>
</li>
<li><p>statusText ：http响应状态文本</p>
</li>
<li><p><strong>responseText：如果服务器端返回字符串，使用responseText进行接收</strong></p>
</li>
<li><p>responseXML ：如果服务器端返回XML数据，使用responseXML进行接收</p>
</li>
<li><p><strong>onreadystatechange：当 readyState 状态码发生改变时所触发的回调函数</strong></p>
</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p><strong>open(method,url,[aycs])：初始化Ajax对象 (打开)</strong><br>method:http请求方式，get/post<br>url:请求的服务器地址<br>aycs:同步与异步 </p>
</li>
<li><p><strong>setRequestHeader(header,value)：设置请求头信息</strong><br>header ：请求头名称<br>value ：请求头的值</p>
</li>
<li><p>xhr.getAllResponseHeaders() 获取全部响应头信息</p>
</li>
<li><p>xhr.getResponseHeader(‘key’) 获取指定头信息</p>
</li>
</ul>
<ul>
<li><p><strong>send([content]) ：发送Ajax请求</strong><br>content ：    如果是get请求时，此参数为null;</p>
<p>如果是post请求时，此参数就是要传递的数据</p>
</li>
</ul>
<p>  <strong>注意: 所有相关的事件绑定必须在调用send()方法之前进行.</strong></p>
  <br>

<h2 id="3-获取服务端响应"><a href="#3-获取服务端响应" class="headerlink" title="3. 获取服务端响应"></a>3. 获取服务端响应</h2><p><strong>onreadyStatechange事件</strong></p>
<p>当ajax状态码发发生变化时将自动触发该事件。readyState表示ajax状态码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="built_in">console</span>.log(xhr.readyState);</span><br><span class="line"><span class="comment">//-&gt; 0 已经创建了ajax对象，但是还没有对ajax对象进行配置</span></span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;localhost:3000/readystate&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(xhr.readyState);</span><br><span class="line"><span class="comment">//-&gt; 1 已经对ajax对象进行配置，但是还没有发送请求</span></span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.readyState);</span><br><span class="line">    <span class="comment">// 2 代表请求已经发送了</span></span><br><span class="line">    <span class="comment">// 3 代表以及接收到服务器端的部分数据了</span></span><br><span class="line">    <span class="comment">// 4 服务器端的响应数据已经接收完毕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://img.imgdb.cn/item/601cf2103ffa7d37b3dabfa8.png"><img src="https://img.imgdb.cn/item/601cf2103ffa7d37b3dabfa8.png"></a></p>
<br>

<h2 id="4-Ajax错误处理"><a href="#4-Ajax错误处理" class="headerlink" title="4. Ajax错误处理"></a>4. Ajax错误处理</h2><p>1）网络畅通，服务器端能接收到请求，服务器端返回的结果不是预期结果。</p>
<p><strong>可以判断服务器端返回的状态码，分别进行处理。<code>xhr.status</code> 获取http状态码。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.onload = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseText);  <span class="comment">//接收返回字符串</span></span><br><span class="line">    <span class="keyword">if</span>(xhr.status == <span class="number">400</span>)</span><br><span class="line">        alert(<span class="string">&#x27;请求出错&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）网络畅通，服务器端没有接收到请求，返回404状态码。</p>
<p><strong>检查请求地址是否错误。</strong></p>
<p>3）网络畅通，服务器能够接收到请求，服务器端返回500状态码。</p>
<p><strong>服务器端错误，找后端。</strong></p>
<p>4）网络中断，请求无法发送到服务器。</p>
<p><strong>会触发xhr对象下面的onerror事件，在onerror事件处理函数中对错误进行处理。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.onerror = ()=&#123;</span><br><span class="line">    alert(<span class="string">&#x27;网络中断，无法请求&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h2 id="低版本IE浏览器缓存问题"><a href="#低版本IE浏览器缓存问题" class="headerlink" title="低版本IE浏览器缓存问题"></a>低版本IE浏览器缓存问题</h2><h3 id="问题来源："><a href="#问题来源：" class="headerlink" title="问题来源："></a><strong>问题来源：</strong></h3><p>在Ajax的get请求中，如果运行在IE内核的浏览器下，其如果<strong>向同一个url发送多次请求</strong>时，只有<strong>第一次</strong>请求会真正发送到服务器端，<strong>后续的请求都会从浏览器的缓存中获取结果</strong>。即使服务器端的数据更新了，客户端拿到的依然是缓存中的旧数据。这就是所谓的缓存问题。</p>
<p>缓存问题最早设计初衷是为了加快应用程序的访问速度，但是其会影响Ajax实时的获取服务器端的数据。</p>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a><strong>解决方案：</strong></h3><p>产生缓存的问题就是 我们的客户端向同一个 url 发送了多次请求；<br>如果我们每次请求的url不同，那么，缓存问题就不会存在了；</p>
<p>我们可以在请求地址的后面加上一个<strong>无意义</strong>的参数，参数值使用随机数即可，<br>那么每次请求都会产生随机数，URL就会不同，缓存问题就被解决了；</p>
<p>**Math.random()**：返回 0-1 之间的随机数，包括 0 但不包括 1；</p>
<p>修改代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;03-1.php?names=&#x27;</span>+inp.value+<span class="string">&#x27;&amp;_=&#x27;</span> + <span class="built_in">Math</span>.random();</span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>,url);</span><br></pre></td></tr></table></figure>
<p>但是，随机数虽然解决了问题，但是，我们不能保证每次生成的随机数都不一样；<br>也就是说，使用随机数存在一定的隐患；</p>
<p><strong>new Date().getTime()</strong> ： 获取当前时间的毫秒时间戳<br>修改代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;03-1.php?names=&#x27;</span>+inp.value+<span class="string">&#x27;&amp;_=&#x27;</span>+<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>,url);</span><br></pre></td></tr></table></figure>
<h3 id="设置响应头禁用客户端缓存"><a href="#设置响应头禁用客户端缓存" class="headerlink" title="设置响应头禁用客户端缓存"></a>设置响应头禁用客户端缓存</h3><p>服务器端在相应客户端请求时，可以设置响应头信息，如：<br><code>header(&#39;Content-type:text/html; charset=utf-8&#39;)</code> ：告诉客户端浏览器，使用utf-8的编码格式解析html页面信息。</p>
<p>设置不缓存的响应头标识即可：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//告诉客户端浏览器不要缓存数据</span></span><br><span class="line">res.setHeader(<span class="string">&#x27;Cache-Control&#x27;</span>,<span class="string">&#x27;no-cache&#x27;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>学习笔记</category>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>ajax</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Express简单笔记</title>
    <url>/2021/02/05/Express%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>使用 <code> npm install express (--save)</code> 进行安装</p>
<br>

<h2 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2.基本使用"></a>2.基本使用</h2><p>1）开启服务器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express= <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>2）接收get请求</p>
<p>send()方法：</p>
<ol>
<li>send方法内部会检测响应内容的类型</li>
<li>send方法会自动设置http状态码</li>
<li>send方法会帮我们自动设置响应的内容类型及编码</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;hello,express!&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//send方法也可以直接传递一个对象：</span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(&#123;<span class="attr">name</span>:<span class="string">&#x27;Jack&#x27;</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<br>

<a id="more"></a>

<h2 id="3-中间件"><a href="#3-中间件" class="headerlink" title="3.中间件"></a>3.中间件</h2><h3 id="1）什么是中间件"><a href="#1）什么是中间件" class="headerlink" title="1）什么是中间件"></a>1）什么是中间件</h3><p>中间件就是一堆方法，可以接收客户端发来的请求，可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理。</p>
<p>中间件主要由两部分构成：<strong>中间件方法</strong>和<strong>请求处理函数</strong>。</p>
<p>中间件方法由Express提供，负责拦截请求，请求处理函数由开发人员提供，负责处理请求。</p>
<h3 id="2）中间件处理请求"><a href="#2）中间件处理请求" class="headerlink" title="2）中间件处理请求"></a>2）中间件处理请求</h3><p>可以针对同一个请求设置多个中间件，对同一个请求进行多次处理。</p>
<p>默认情况下，请求从上到下依次匹配中间件，一旦匹配成功，终止匹配。</p>
<p>可以调用next方法将请求的控制权交给下一个中间件，直到遇到结束请求的中间件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/request&#x27;</span>,<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    req.name=<span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">    next();  <span class="comment">//使用next继续向下执行</span></span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">&#x27;/request&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(req.name);  <span class="comment">//传回req.name，值是上一个中间件设置的</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="3）app-use中间件用法"><a href="#3）app-use中间件用法" class="headerlink" title="3）app.use中间件用法"></a>3）app.use中间件用法</h3><p><code>app.use</code> 匹配所有的请求方式，可以直接传入请求处理函数，代表接收所有的请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.url);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>app.use</code> 第一个参数也可以传入请求地址，代表不论什么请求方式，只要是这个请求地址就接收这个请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;/admin&#x27;</span>,<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.url);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="4）中间件的应用"><a href="#4）中间件的应用" class="headerlink" title="4）中间件的应用"></a>4）中间件的应用</h3><ol>
<li><p><strong>路由保护</strong>。客户端在访问需要登录的页面时，可以先使用中间判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;/admin&#x27;</span>,<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> isLogin=<span class="literal">false</span>;  </span><br><span class="line">    <span class="keyword">if</span>(isLogin)  <span class="comment">//如果登录状态正确，执行下一个请求</span></span><br><span class="line">        next();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        res.send(<span class="string">&#x27;您还没有登录，不能访问该页面&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">&#x27;/admin&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;您已登录，可以访问当前页面&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>网站维护公告</strong>。在所有路由的最上面定义接收所有请求的中间件，直接为客户端做出响应：网站正在维护中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//网站公告</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;当前网站正在维护...&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//因为没有next(),后续所有请求不会执行</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>自定义404页面</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//为客户端响应404状态码以及提示信息</span></span><br><span class="line">    res.status(<span class="number">404</span>).send(<span class="string">&#x27;当前访问的页面不存在&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="5）错误处理中间件"><a href="#5）错误处理中间件" class="headerlink" title="5）错误处理中间件"></a>5）错误处理中间件</h3></li>
</ol>
<p>在程序执行的过程中，不可避免地会出现一些无法预料的错误，比如文件读取失败，数据库链接失败。</p>
<p><strong>错误处理中间件是一个集中处理错误的地方</strong>。</p>
<p>简单的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/index&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;程序发生未知错误&#x27;</span>);</span><br><span class="line">    <span class="comment">//这里抛出一个错误</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误处理中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    res.status(<span class="number">500</span>).send(err.message);</span><br><span class="line">    <span class="comment">//err对象接收错误，message属性即抛出错误的信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>读取文件错误的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/index&#x27;</span>,<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;./demo.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="function">(<span class="params">err,res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">            next(err)   <span class="comment">//传入err参数，如果出错执行错误处理中间件</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            res.send(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误处理中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    res.status(<span class="number">500</span>).send(err.message);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="6）捕获错误"><a href="#6）捕获错误" class="headerlink" title="6）捕获错误"></a>6）捕获错误</h3><p>node.js中，异步API的错误信息都是通过回调函数获取的，支持Promise对象的异步API发生错误可以通过catch方法捕获。</p>
<p>异步函数执行如果发生错误要如何捕获呢？</p>
<p><code>try catch</code> 可以捕获异步函数以及其他同步代码在执行过程中发生的错误，但是不能捕获其他类型的API发生的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>,<span class="keyword">async</span>(req,res,next)=&gt;&#123; <span class="comment">//使用async定义异步函数</span></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">await</span> User.find(&#123;<span class="attr">name</span>:<span class="string">&#x27;Jack&#x27;</span>&#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span>(ex)&#123;</span><br><span class="line">      next(ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<br>

<h2 id="4-构建模块化路由"><a href="#4-构建模块化路由" class="headerlink" title="4. 构建模块化路由"></a>4. 构建模块化路由</h2><p>1）基础代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express =<span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">//创建服务器</span></span><br><span class="line"><span class="keyword">const</span> app =express();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> home = express.Router();</span><br><span class="line"><span class="comment">//将路由和请求路径进行匹配</span></span><br><span class="line">app.use(<span class="string">&#x27;/home&#x27;</span>,home);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在home路由下继续创建路由(二级路由)</span></span><br><span class="line">home.get(<span class="string">&#x27;/index&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// home/index</span></span><br><span class="line">    res.send(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//此时二级路由可以响应  /home/index </span></span><br></pre></td></tr></table></figure>
<p>2）多模块</p>
<p>home.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> home = express.Router();</span><br><span class="line">home.get(<span class="string">&#x27;/index&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;这是展示页面&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">module</span>.exports = home;</span><br></pre></td></tr></table></figure>
<p>admin.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> admin = express.Router();</span><br><span class="line">admin.get(<span class="string">&#x27;/index&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;这是管理页面&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">module</span>.exports = admin;</span><br></pre></td></tr></table></figure>
<p>app.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">&#x27;./route/home.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> admin = <span class="built_in">require</span>(<span class="string">&#x27;./route/admin.js&#x27;</span>);</span><br><span class="line">app.use(<span class="string">&#x27;/home&#x27;</span>,home);</span><br><span class="line">app.use(<span class="string">&#x27;/admin&#x27;</span>,admin);</span><br></pre></td></tr></table></figure>
<br>

<h2 id="5-express请求处理"><a href="#5-express请求处理" class="headerlink" title="5.express请求处理"></a>5.express请求处理</h2><h3 id="1）GET参数的获取"><a href="#1）GET参数的获取" class="headerlink" title="1）GET参数的获取"></a>1）GET参数的获取</h3><p>Express框架中使用<code>req.query</code>即可获取GET参数，框架内部会将GET参数转化为对象并返回。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收地址栏中问号后面的参数</span></span><br><span class="line"><span class="comment">//例如： http://localhost:3000/?name=Jack&amp;age=20</span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.query);</span><br><span class="line">    <span class="comment">//-&gt; &#123;&quot;name&quot;:&quot;Jack&quot;,&quot;age&quot;:&quot;20&quot;&#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="2）POST参数的获取"><a href="#2）POST参数的获取" class="headerlink" title="2）POST参数的获取"></a>2）POST参数的获取</h3><p>Express中接收post请求参数需要第三方包 body-parser。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入body-parser模块</span></span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>);</span><br><span class="line"><span class="comment">//配置body-parse模块</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>:<span class="literal">false</span> &#125;));</span><br><span class="line"><span class="comment">//extended:false 方法内部使用querystring模块处理请求参数的格式</span></span><br><span class="line"><span class="comment">//extended:true  方法内部使用第三方模块qs处理请求参数的格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接收请求</span></span><br><span class="line">app.post(<span class="string">&#x27;/add&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//接收参数</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.body);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="3）Express路由参数"><a href="#3）Express路由参数" class="headerlink" title="3）Express路由参数"></a>3）Express路由参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在请求的路径上使用  :id  表示接收一个参数，是一个对象，对象名为id</span></span><br><span class="line">app.get(<span class="string">&#x27;/find/:id&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.params);   </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//访问localhost/find/123</span></span><br><span class="line"><span class="comment">//-&gt;  &#123;id:123&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用多个参数：</span></span><br><span class="line">app.get(<span class="string">&#x27;/find/:id/:name/:age&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;&#125;);   </span><br></pre></td></tr></table></figure>
<h3 id="4）静态资源处理"><a href="#4）静态资源处理" class="headerlink" title="4）静态资源处理"></a>4）静态资源处理</h3><p>通过Express内置的 <code>express.static</code> 可以方便地托管静态文件，例如img，css，JavaScript文件等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(express.static(<span class="string">&#x27;public&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>则此时就可以访问public文件夹下的各种文件。</p>
<br>

]]></content>
      <categories>
        <category>前端</category>
        <category>node.js</category>
        <category>express</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node.js</tag>
        <tag>学习笔记</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title>《JavaScript高级程序设计》红宝书学习笔记（1）</title>
    <url>/2021/01/21/Javascript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>个人对第四版红宝书的学习笔记。不适合小白阅读。这是part1。</p>
<p>（记  * 的表示是ES6新增的知识点，记 ` 表示包含新知识点。）</p>
<p>新增内容如下：</p>
<p>let声明、const声明、模板字面量（字符串）、Symbol数据类型、for-of循环语句。</p>
</blockquote>
<a id="more"></a>

<h2 id="第二章：HTML中的Javascript"><a href="#第二章：HTML中的Javascript" class="headerlink" title="第二章：HTML中的Javascript"></a>第二章：HTML中的Javascript</h2><hr>

<h3 id="2-1-lt-script-gt-元素"><a href="#2-1-lt-script-gt-元素" class="headerlink" title="2.1 &lt;script&gt;元素"></a>2.1 &lt;script&gt;元素</h3><p><strong>&lt;script&gt;标签的八个属性</strong></p>
<ul>
<li><p><code>async</code>：可选。表示应该立即开始下载脚本，但不能阻止其它页面动作，比如下载资源或等待其他脚本加载。<strong>使用该属性可以异步执行脚本</strong>。<em>只对外部脚本文件有效。</em></p>
</li>
<li><p><code>charset</code>：可选。使用src属性指定的代码字符集。基本不会使用。</p>
</li>
<li><p><code>crossorigin</code>：可选。配置相关的CORS（跨资源共享）设置。默认不使用CORS。<code>corssorigin=&quot;anonymous&quot;</code>配置文件请求不必设置凭据标志。<code>corssorigin=&quot;use-credentials&quot;</code>设置凭据标志，意味着出战请求会包含凭据。</p>
</li>
<li><p><code>defer</code>：可选。表示在文档解析和显示完成后再执行脚本是没有问题的。<em>只对外部脚本文件有效</em>。IE7及以前可以对行内脚本指定该属性。<strong>使用该属性推迟执行脚本</strong>。</p>
</li>
<li><p><code>integrity</code>：可选。允许对比接收到的资源和指定的加密签名以验证子资源完整性（SRI）。如果接收到资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。该属性可以用于<em>确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容</em>。</p>
</li>
<li><p><code>language</code>：已废弃。</p>
</li>
<li><p><code>src</code>：可选。表示包含要执行的代码的外部文件。</p>
</li>
<li><p><code>type</code>：可选。代替language，表示代码块中脚本语言的内容类型（也称MIME类型）。按惯例始终都会是<code>text/javascript</code>。Javascript文件的MIME类型通常是<code>&quot;application/x-javascript&quot;</code>，不过给type属性这个值有可能导致脚本被忽略。在非IE浏览器有效的其他值还有<code>&quot;application/javascript&quot;</code>和<code>&quot;application/ecmascript&quot;</code>。<em>如果这个值是module，则代码会被当成ES6模块，且只有这时候代码中才能出现import和export关键字。</em></p>
</li>
</ul>
<p><strong>三个注意点</strong>：</p>
<ol>
<li><p>使用&lt;script&gt;标签写行内代码时不要出现这种情况：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;);  <span class="comment">&lt;!--这里&lt;/script&gt;会被当作结束标签，甚至你会发现写在注释中也会被当作结束标签无法解析，因此我这里用了html的注释法--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以使用转义字符解决这一问题：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;&lt;\/script&gt;&quot;</span>);  <span class="comment">//这里可以正常使用，注释里这样使用：&lt;\/script&gt; 也可以，从代码没有高亮可以看出来</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>该元素最为强大同时也备受争议的特性是：它可以包含来自外部域的Javascript文件。它的src属性可以是一个完整的url，而且这个url指向的资源可以跟包含它的HTML页面不再同一个域中。例如：</p>
<p><code>&lt;script src=&quot;http://www.somewhere.com/afile.js&quot;&gt;&lt;/script&gt;</code></p>
<p>浏览器解析时会向src属性指定的路径发送一个GET请求，以取得相应资源。这个初始的请求不受浏览器同源策略限制，但返回的Javascript受限。（当然，该请求仍然受HTTP/HTTPS）协议的限制。</p>
<p>来自外部的代码会被当成加载他它的页面的一部分来加载和解析。<strong>这个能力可以让我们通过不同的域分发JavaScript。</strong>不过同时，引用他人服务器的文件时必须格外小心，因为可能会有恶意的程序员替换这个文件。<em>integrity属性可以防范，但不是所有浏览器都支持。</em></p>
</li>
<li><p>一般浏览器会按照&lt;script&gt;在页面中的顺序依次解释它们，只要没有使用defer和async属性的话。另<strong>外最好将标签位置放在页面底部（&lt;body&gt;之后）</strong>。</p>
</li>
</ol>
<h3 id="2-2-行内代码与外部文件"><a href="#2-2-行内代码与外部文件" class="headerlink" title="2.2 行内代码与外部文件"></a>2.2 行内代码与外部文件</h3><p>虽然不是明确的强制性规则，但通常认为最佳实践是<strong>尽可能将Javascript代码放在外部文件</strong>中。原因如下：</p>
<ul>
<li><strong>可维护性</strong>。使用一个目录保存所有的JavaScript文件总会比分散在很多HTML页面容易维护。</li>
<li><strong>缓存</strong>。浏览器会根据特点的设置缓存所有外部链接的JavaScript文件，这意味着如果两个页面都用到同一个文件，则该文件只需被下载依次。</li>
<li><strong>适应未来</strong>。</li>
</ul>
<h3 id="2-3-文档模式"><a href="#2-3-文档模式" class="headerlink" title="2.3 文档模式"></a>2.3 文档模式</h3><p>IE5.5发明了文档模式的概念，即可以通过doctype切换文档模式。最初的文档模式有两种：<strong>混杂模式</strong>（quirks mode）和<strong>标准模式</strong>（standards mode）。后来出现了第三种文档模式：准文档模式（almost standards mode）。只作了解。</p>
<h3 id="2-4-lt-noscript-gt-元素"><a href="#2-4-lt-noscript-gt-元素" class="headerlink" title="2.4 &lt;noscript&gt;元素"></a>2.4 &lt;noscript&gt;元素</h3><p>针对早期浏览器不支持JavaScript的问题，提出的一个页面优雅降级的处理方案：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>该页面不支持JavaScript，请更换浏览器。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>&lt;noscript&gt;元素可以包含任何出现在&lt;body&gt;中的HTML元素，&lt;script&gt;除外。出现下列两种情况下，浏览器将显示包含在该元素中的内容：</p>
<ul>
<li>浏览器不支持脚本；</li>
<li>浏览器对脚本的支持被关闭。</li>
</ul>
<br>

<h2 id="第三章：语言基础"><a href="#第三章：语言基础" class="headerlink" title="第三章：语言基础"></a>第三章：语言基础</h2><hr>

<h3 id="3-1-变量声明"><a href="#3-1-变量声明" class="headerlink" title="3.1 变量声明"></a>3.1 变量声明</h3><h4 id="3-1-1-var声明"><a href="#3-1-1-var声明" class="headerlink" title="3.1.1 var声明"></a>3.1.1 var声明</h4><p>var声明的变量不初始化的情况下，该变量会保存特殊的值undefined。</p>
<p>var声明厨初始化后的变量，后续可以改变类型。</p>
<p>1）var声明作用域</p>
<p>使用var操作符定义的变量会成为包含它的函数的局部变量，该变量在函数退出时被销毁。而在局部作用域中省略var操作符声明，该变量会作为全局变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m1=<span class="string">&quot;hi&quot;</span>;</span><br><span class="line">    m2=<span class="string">&quot;hi&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(m1);     <span class="comment">//-&gt; 出错!</span></span><br><span class="line"><span class="built_in">console</span>.log(m2);     <span class="comment">//-&gt; hi</span></span><br></pre></td></tr></table></figure>
<p>2）var声明提升</p>
<p>使用var关键字时，声明的变量会自动提升（hoist）到函数作用域顶部。此外，<em>反复多次使用var声明同一个变量也没有问题</em>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">    <span class="keyword">var</span> age=<span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*上述代码在ECMAScript中运行时会看成等价如下代码：*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age；</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">    age=<span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因此调用该方法，结果会如下：</span></span><br><span class="line">test();  <span class="comment">//-&gt;  undefined</span></span><br></pre></td></tr></table></figure>


<h4 id="3-1-2-let声明"><a href="#3-1-2-let声明" class="headerlink" title="3.1.2 let声明  *"></a>3.1.2 let声明  *</h4><p>let和var差不多，但有着很大的区别，最明显的区别是：let声明的范围是<strong>块作用域</strong>，而var是函数作用域。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> name1=<span class="string">&#x27;matt&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name1);  <span class="comment">//-&gt; matt</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> name2=<span class="string">&#x27;mat&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name2);   <span class="comment">//-&gt; ReferenceError:name没有定义</span></span><br></pre></td></tr></table></figure>
<p>这里name2之所以不能再if块外部被引用，是因为它的作用域仅限于该块内部。块作用域是函数作用域的子集，因此适用于var的作用域限制同样适用于let。</p>
<p>let也不允许同一个块作用域中出现冗余声明。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age;</span><br><span class="line"><span class="keyword">var</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">let</span> age;   <span class="comment">//-&gt; SyntaxError;  标识符age已经声明过了</span></span><br></pre></td></tr></table></figure>
<p>对声明冗余报错不会因混用let和var而受影响。它们声明的不是不同类型的变量，只是指出变量在相关作用域如今存在。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">let</span> name;   <span class="comment">//-&gt; SyntaxError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">var</span> age;    <span class="comment">//-&gt; SyntaxError</span></span><br></pre></td></tr></table></figure>
<p>1）暂时性死区</p>
<p>let和var另一个重要的区别，就是<strong>let声明的变量不会再作用域中被提升</strong>。</p>
<p>在let声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出ReferenceError。</p>
<p>2）全局声明</p>
<p>let在全局作用域中声明的变量<strong>不会成为window 对象的属性</strong>（var声明的变量则会）。不过let声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">&#x27;matt&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name);    <span class="comment">//-&gt; &#x27;matt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age=<span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age);    <span class="comment">//-&gt; undefined</span></span><br></pre></td></tr></table></figure>
<p>3）条件声明</p>
<p>使用var声明时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。<strong>因为let的作用域是块，所以不可能检查前面是否已经使用let声明过同名变量，同时也就不可能在没有声明的情况下声明它</strong>。</p>
<p>4）for循环中的let声明</p>
<p>在let出现之前，for循环定义的迭代变量会渗透到循环体外部：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);   <span class="comment">//-&gt; 5</span></span><br></pre></td></tr></table></figure>
<p>而let就解决了这一问题，因为迭代遍历的作用域仅限于for循环块内部。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);   <span class="comment">//-&gt; ReferenceError：i没有定义</span></span><br></pre></td></tr></table></figure>
<p>另外在使用var的时候，最常见的问题就是对迭代变量的奇特声明和修改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i),<span class="number">0</span>);   <span class="comment">//-&gt; 5、5、5、5、5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为在退出循环时，迭代变量保存的都是导致循环退出的值：5。之后执行超时逻辑时，所有的i都是同一个变量。</span></span><br></pre></td></tr></table></figure>
<p>而在使用let声明迭代变量时，JavaScript引擎在后台会为每个迭代循环声明一个新的迭代变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i),<span class="number">0</span>);   <span class="comment">//-&gt; 1、2、3、4、5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种行为适用于于所有风格的for循环，包括for-in和for-of循环。</p>
<h4 id="3-1-3-const声明"><a href="#3-1-3-const声明" class="headerlink" title="3.1.3 const声明  *"></a>3.1.3 const声明  *</h4><p>const的行为与let基本相同，唯一一个重要的区别是用它声明变量是时必须同时初始化变量，且后续尝试修改const变量会报错。</p>
<p><strong>const声明的限制只适用于它指向的变量的引用</strong>。换言之，如果const变量引用的是一个对象，那么修改这个对象内部的属性并不违反const的限制。</p>
<p>另外const不能用来声明迭代变量（因为迭代变量会自增或自减）。但const可以用来声明一个不会被修改的for循环变量，也就是说，每次迭代只是创建一个新变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> j=<span class="number">7</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j);    <span class="comment">//-&gt; 7,7,7,7,7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);   <span class="comment">//-&gt; a,b</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> value <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);    <span class="comment">//-&gt; 1,2,3,4,5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以看出，这对for-of和for-in循环特别有意义</span></span><br></pre></td></tr></table></figure>
<br>

<h3 id="3-2-数据类型"><a href="#3-2-数据类型" class="headerlink" title="3.2 数据类型"></a>3.2 数据类型</h3><h4 id="3-2-1-typeof操作符"><a href="#3-2-1-typeof操作符" class="headerlink" title="3.2.1 typeof操作符"></a>3.2.1 typeof操作符</h4><p>使用typeof操作符检验数据类型。可以用来区分函数和对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="keyword">typeof</span> <span class="number">95</span>);</span><br><span class="line">alert(<span class="keyword">typeof</span>(<span class="number">95</span>));    <span class="comment">//看的出来typeof操作符也可以使用参数</span></span><br><span class="line">alert(<span class="keyword">typeof</span> <span class="literal">null</span>);   <span class="comment">//会返回object，因为特殊值null被认为是一个对空对象的引用</span></span><br></pre></td></tr></table></figure>
<h4 id="3-2-2-Undefined类型"><a href="#3-2-2-Undefined类型" class="headerlink" title="3.2.2 Undefined类型"></a>3.2.2 Undefined类型</h4><p>在声明变量但未对其加以初始化时，这个变量的值就是undefined。</p>
<p>而当使用typeof操作符检验一个未声明的变量时，返回的值也是undefined。</p>
<h4 id="3-2-3-Null类型"><a href="#3-2-3-Null类型" class="headerlink" title="3.2.3 Null类型"></a>3.2.3 Null类型</h4><p>逻辑上，null值表示一个空对象指针。所以使用typeof检验null会返回object。</p>
<p>ECMA-262规定  undefined==null  返回 true。</p>
<p>无论什么情况都不需要将变量值显式地设置undefined，但对null不适用。换言之，只要意在保存的对象还没有真正保存对象，就应该明确地让该变量保存null。</p>
<h4 id="3-2-4-Boolean类型"><a href="#3-2-4-Boolean类型" class="headerlink" title="3.2.4 Boolean类型"></a>3.2.4 Boolean类型</h4><p>​    <strong>true、false是区分大小写的</strong>。</p>
<p><strong>布尔类型转换Boolean()</strong></p>
<p>​    使用**Boolean()**函数将对应的值转化为布尔值。下面是转化规则：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">转化为true的值</th>
<th align="left">转化为false的值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Boolean</td>
<td align="left">true</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">任何非空字符串</td>
<td align="left">空字符串</td>
</tr>
<tr>
<td align="left">Number</td>
<td align="left">任何非零数字值（包括无穷值）</td>
<td align="left">0和NaN</td>
</tr>
<tr>
<td align="left">Object</td>
<td align="left">任何对象</td>
<td align="left">null</td>
</tr>
<tr>
<td align="left">Undefined</td>
<td align="left">n/a（不适用）</td>
<td align="left">undefined</td>
</tr>
</tbody></table>
<h4 id="3-2-5-Numer类型"><a href="#3-2-5-Numer类型" class="headerlink" title="3.2.5 Numer类型"></a>3.2.5 Numer类型</h4><p> 除了<strong>十进制</strong>表示以外，整数还可以通过<strong>八进制</strong>或<strong>十六进制</strong>的字面值表示。</p>
<p>其中，八进制字面值的第一位必须是零（0）。如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。注意，<strong>八进制字面量在严格模式下是无效的</strong>，会导致支持的Js引擎抛出错误。</p>
<p>十六进制字面值的前两位必须是0x，后跟任何十六进制数（0<del>9及A</del>F）。其中，字母A~F可以大写，也可以小写。</p>
<p><strong>进行算术计算时，所有的八进制和十六进制数最终都将被转化为十进制数。</strong></p>
<h5 id="1）浮点数"><a href="#1）浮点数" class="headerlink" title="1）浮点数"></a>1）浮点数</h5><p>由于保存浮点数值需要的内存空间是整数的两倍，因此<strong>ECMAScript会不失时机地将浮点数值转化为整数值</strong>。如果小数点后没有跟任何数字（如 1.）或浮点数值本身表示的就是一个整数（如1.0），就会将其转化为整数。</p>
<p><em>默认情况下，ECMAScript会将那些小数点后面带有6个0以上的浮点数值转化为以e表示法表示的数值</em>。</p>
<p>浮点数值的最高精度是<strong>17</strong>位小数，但在进行算术计算时其精确度远不如整数。例如，0.1+0.2的结果不是0.3，而是0.30000000000000004（小数点后一共17位）。这个舍入误差会导致无法测试指定的浮点数值。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a + b == <span class="number">0.3</span>)&#123;          <span class="comment">//不要做这样的测试！</span></span><br><span class="line">  alert(<span class="string">&quot;You get 0.3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这个例子中，我们测试的是两个数的和是不是等于0.3。若这两个数是0.05和0.25，或者是0.15和0.15都不会有问题。因此，永远不要测试某个特定的浮点数</span></span><br></pre></td></tr></table></figure>
<h5 id="2）数值范围"><a href="#2）数值范围" class="headerlink" title="2）数值范围"></a>2）数值范围</h5><p>由于内存限制，ECMAScript无法保存世界上所有数据。ECMAScript能够表示的最小数值保存在<code>Number.MIN_VALUE</code>中——在大多数浏览器中，这个值是5e-324；能够表示的最大数值保存在<code>Number.MAX_VALUE</code>中——在大多数浏览器中，这个值是1.7976931348623157e+308。如果这个数值是正数，则会转化为**<code>Infinity</code>**。</p>
<p>要想确定一个数值是不是有穷的（换言之，是不是位于最小和最大数值之间），可以使用<code>isFinite()</code>函数。<strong>这个函数在参数位于最小与最大数值之间会返回true</strong>。</p>
<h5 id="3）NaN"><a href="#3）NaN" class="headerlink" title="3）NaN"></a>3）NaN</h5><p>​    NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样不会抛出错误）。例如在其他编程语言中，任何数除以0都会导致错误，但在ECMAScript中会返回NaN，因此不会影响其他代码执行。</p>
<p>​    NaN有两个特点。<strong>首先，任何涉及NaN的操作都会返回NaN。其次，NaN与任何值都不相等，包括NaN本身。</strong></p>
<p>​    针对NaN，ECMAScript定义了一个函数<code>isNaN()</code>函数。这个函数接受一个参数（可以是任意类型），函数会帮我们确定该参数是否“不是数值”。函数在接受到值后，会尝试将该值转化为数值，某些不是数值的值会直接转化为数值，例如字符串”10”或Boolean值。任何不能被转化为数值的值都会导致函数返回true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>));    <span class="comment">//true</span></span><br><span class="line">alert(isNan(<span class="number">10</span>));     <span class="comment">//false(10是一个数值)</span></span><br><span class="line">alert(isNan(<span class="string">&quot;10&quot;</span>));    <span class="comment">//false(会转化为数值10)</span></span><br><span class="line">alert(isNan(<span class="string">&quot;blue&quot;</span>));    <span class="comment">//true(无法转化为数值)</span></span><br><span class="line">alert(isNan(<span class="literal">true</span>));    <span class="comment">//false(可以被转化为数值1)</span></span><br></pre></td></tr></table></figure>
<p>​    而对于<code>isNaN()</code>，<em>它也适用于对象</em>。在基于对象调用该函数时，会首先调用对象的<code>valueOf()</code>方法，然后确定该方法返回的值是否可以转化为数值。如果不能，则基于这个返回值再调用 <code>toString()</code> 方法，再测试返回值。</p>
<h5 id="4）数值转换"><a href="#4）数值转换" class="headerlink" title="4）数值转换"></a>4）数值转换</h5><p>​    有三个函数可以将非数值转化为数值：<code>Number()</code>、<code>parseInt()</code>和<code>parseFloat()</code>。第一个转型函数<code>Number()</code>可以用于任何数据类型，而另两个函数则专门用于将字符串转换成数值。</p>
<p><strong>Number()函数</strong></p>
<ul>
<li><p>如果是布尔值，true和false将分别转换为1和0。</p>
</li>
<li><p>如果数字值，只是简单的传入与返回。</p>
</li>
<li><p>如果是null，返回0。</p>
</li>
<li><p>如果是undefined，返回NaN。</p>
</li>
<li><p>如果是字符串，遵循下列规则：</p>
<ul>
<li>如果字符串中只包含数字，则将其转化为十进制，如”12”会转化为12，”0123”转化为123（注意，前导的零被忽略了）。</li>
<li>如果字符串中包含有效的浮点格式，如”1.1”，则将其转化为对应的浮点数值（同样会忽略前导零）</li>
<li>如果字符串中包含有效的十六进制格式，则将其转化为相同大小的十进制整数；</li>
<li>如果为空字符串，转化为0；</li>
<li>如果字符串包含上述格式之外的字符，则转换为NaN。</li>
</ul>
</li>
<li><p>如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。</p>
</li>
</ul>
<p><strong>ParseInt()函数</strong></p>
<p>由于<code>Number()</code>函数在转化时比较复杂且不够合理，因此在处理整数的时候更常用的是<code>parseInt()</code>函数。该函数会忽略字符串前的空格，直至找到第一个非空格字符。如果第一个字符不是数字或者负号，函数就会返回NaN；也就是说，<strong>parseInt()函数对空字符串会返回NaN（而Number()函数会返回0）</strong>。如果第一个字符是数字字符，则会继续解析第二个字符直到全部解析完毕或者遇到了第一个非数字字符。</p>
<p>如果字符串中的第一个字符是数字字符，<strong>parseInt()也能识别各种整数格式</strong>。也就是说，如果字符串以”0x”开头且后跟数字字符，就会将其当作十六进制整数，如果字符串以”0”开头且后跟数字字符，则会将其解析为八进制数。</p>
<p>【注】对于八进制数如  070  ，ES3和ES5存在分歧，ES3会解析为56，而ES5会解析为0。在ES5 JS引擎中，parseInt()函数已不再具备解析八进制的能力，因此前导零无效，解析为0。严格模式下同样如此。</p>
<p>【续】为消除可能产生的困惑，可以为这个函数提供第二个参数：转换时使用的基数（即多少进制）。例如： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="built_in">parseInt</span>(<span class="string">&quot;0xAF&quot;</span>,<span class="number">16</span>);     <span class="comment">//175</span></span><br><span class="line"><span class="comment">//而实际上如果指定了16进制，字符串可以不带前面的0x。</span></span><br><span class="line"> <span class="keyword">var</span> num=<span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>);     <span class="comment">//NaN </span></span><br><span class="line"> <span class="keyword">var</span> num=<span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>，<span class="number">16</span>);     <span class="comment">//175 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定基数会影响转换的输出结果</span></span><br><span class="line"><span class="keyword">var</span> num1=<span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>,<span class="number">2</span>);    <span class="comment">//2</span></span><br><span class="line"><span class="keyword">var</span> num2=<span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>,<span class="number">8</span>);    <span class="comment">//8</span></span><br></pre></td></tr></table></figure>
<p><strong>为了避免解析的错误，建议无论在什么情况下都明确指定基数。</strong></p>
<p><strong>parseFloat()函数</strong></p>
<p>该函数同<code>parseInt()</code>函数类似，也是从第一个字符位置开始解析每个字符，同样解析到字符串结尾，或者解析到遇见一个无效的浮点数字符为止。<strong>也就是说，字符串中的第一个小数点是有效的，而第二个小数点就无效了。</strong></p>
<p>除第一个小数点有效之外，<code>parseFloat()</code>函数与<code>parseInt()</code>的第二个区别在于<strong>它始终都会忽略前导的零</strong>。parseFloat()函数对于十<em>六进制格式字符串则始终会转换成0</em>。parseFloat()没有指定进制第二参数的用法。且<em>若字符串包含的是一个可解析为整数的数（没有小数点或者小数点后都为0），则会返回整数</em>。</p>
<h4 id="3-2-6-String类型"><a href="#3-2-6-String类型" class="headerlink" title="3.2.6 String类型"></a>3.2.6 String类型</h4><p><strong>字符串的表达方式</strong>：可以使用双引号（””）、单引号（’’）和反引号（``）表示。</p>
<h5 id="1）字符字面量（转义序列）"><a href="#1）字符字面量（转义序列）" class="headerlink" title="1）字符字面量（转义序列）"></a>1）字符字面量（转义序列）</h5><table>
<thead>
<tr>
<th>字面量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\t</td>
<td>制表</td>
</tr>
<tr>
<td>\b</td>
<td>空格</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
</tr>
<tr>
<td>\`    \“   \‘</td>
<td>字符串标志符号</td>
</tr>
<tr>
<td>\xnn</td>
<td>以十六进制编码nn表示的一个字符（其中n为0~F)</td>
</tr>
<tr>
<td>\unnnn</td>
<td>以十六进制编码nnnn表示的一个Unicode字符</td>
</tr>
</tbody></table>
<p><strong>一个转义序列表示一个字符。</strong>字符串的长度可以使用length属性获取。</p>
<blockquote>
<p>如果字符串中包含双字节字符，那么length属性返回的值可能不是准确的字符数。第五章会具体讨论如何解决这个问题。</p>
</blockquote>
<h5 id="2）字符串的特点"><a href="#2）字符串的特点" class="headerlink" title="2）字符串的特点"></a>2）字符串的特点</h5><p><strong>ES中的字符串不可变</strong>。字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充改变量。</p>
<h5 id="3）转换为字符串"><a href="#3）转换为字符串" class="headerlink" title="3）转换为字符串"></a>3）转换为字符串</h5><p><strong>toString()</strong></p>
<p>要将一个值转换为字符串有两种方式。第一种是使用几乎每个值都有的<code>toString()</code>方法。<strong>数值、布尔值、对象和字符串值</strong>（字符串调用该方法返回字符串的一个副本）都有该方法。<em>但null和undefined值没有该方法</em>。</p>
<p>多数情况下，调用<code>toString()</code>方法不必传递参数。但是，<strong>在调用数值的toString()方式时，可以传递一个参数：输出数值的基数</strong>。默认情况，该方法以十进制格式返回数值的字符串表示。通过传递基数，可以输出其他任意有效进制格式的表示。</p>
<p><strong>String()</strong></p>
<p>在不知道要转换的值是不是null或undefined的情况下，可以使用<code>String()</code>方法，这个函数能够将任何类型的值转化为字符串。该方法遵循下列转换规则：</p>
<ul>
<li>如果值有toString()方法，则调用该方法（无参数）并返回相应结果；</li>
<li>如果值为null，则返回”null”；</li>
<li>如果值为undefined，则返回”undefined”。</li>
</ul>
<h5 id="4）模板字面量"><a href="#4）模板字面量" class="headerlink" title="4）模板字面量  *"></a>4）模板字面量  *</h5><p>ES6新增了使用模板字面量定义字符串的能力。与使用单引号和双引号不同，<strong>模板字面量保留换行字符，可以跨行定义字符串</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1=<span class="string">&#x27;first line\nsecond line&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> str2=<span class="string">`first line</span></span><br><span class="line"><span class="string">second line`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str1);</span><br><span class="line"><span class="comment">/*-&gt; first line</span></span><br><span class="line"><span class="comment">     second line  */</span></span><br><span class="line"><span class="built_in">console</span>.log(str2);</span><br><span class="line"><span class="comment">/*-&gt; first line</span></span><br><span class="line"><span class="comment">     second line  */</span></span><br><span class="line"><span class="built_in">console</span>.log(str1===str2);    <span class="comment">//-&gt; true</span></span><br></pre></td></tr></table></figure>
<p>顾名思义，<strong>模板字面量在定义模板时特别有用</strong>。如下html模板：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pageHTML=<span class="string">`           </span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">  &lt;a href=&quot;#&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;Jake&lt;/span&gt;</span></span><br><span class="line"><span class="string">  &lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="comment">//这里可以注意，这里字符串其实是以换行符开始的。如果打印</span></span><br><span class="line"><span class="built_in">console</span>.log(pageHTML[<span class="number">0</span>]===<span class="string">&#x27;\n&#x27;</span>);    <span class="comment">//-&gt; 结果会是true</span></span><br></pre></td></tr></table></figure>
<p>但同时，因为<strong>模板字面量会保持反引号内部的空格</strong>，因此使用时需格外小心。（这些空格也算一个字符）</p>
<h5 id="5）字符串插值"><a href="#5）字符串插值" class="headerlink" title="5）字符串插值  *"></a>5）字符串插值  *</h5><p>模板字面量最常用的一个特性是<strong>支持字符串插值</strong>，也就是可以在一个连续定义中插入一个或多个值。技术上来说，模板字面量不是字符串，而是一种特殊的Javascript句法表达式，只不过求值之后得到的是字符串。模板字面量在定义时立即求值并转化为字符串实例，任何插入的变量也会从它们最近的作用域中取值。</p>
<p>使用<code>$&#123;&#125;</code>实现字符串插值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name=<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    age=<span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> str=<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>, I&#x27;m <span class="subst">$&#123;age&#125;</span> years old`</span>;</span><br></pre></td></tr></table></figure>
<p>所有插入的值都会使用<code>toString()</code>强制转型为字符串，<strong>任何JS表达式都可以用于插值</strong>（也就是说函数和方法也可以）。嵌套的模板字符串无需转义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hello, $&#123;&#x27;</span>world<span class="string">&#x27;&#125; !&#x27;</span>);   <span class="comment">//-&gt; Hello, world!</span></span><br></pre></td></tr></table></figure>
<p>此外，模板也可以插入自己之前的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> val=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    val=<span class="string">`<span class="subst">$&#123;val&#125;</span>abc`</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;</span><br><span class="line">append();    <span class="comment">//-&gt; abc</span></span><br><span class="line">append();    <span class="comment">//-&gt; abcabc</span></span><br><span class="line">append();    <span class="comment">//-&gt; abcabcabc</span></span><br></pre></td></tr></table></figure>
<h5 id="6）模板字面量标签函数"><a href="#6）模板字面量标签函数" class="headerlink" title="6）模板字面量标签函数 *"></a>6）模板字面量标签函数 *</h5><p>模板字面量也支持定义<strong>标签函数</strong>（tag function），通过标签函数可以自定义插值行为。标签函数会接受被插值记号分隔后的模板和对每个表达式求值的结果。</p>
<p>标签函数本身是一个常规函数，通过前缀到字面量来应用自定义行为，如下所示。标签函数接收到的参数依次是<strong>原始字符串数组</strong>和<strong>对每个表达式求值的结果</strong>。这个函数的返回值是<strong>对模板字面量求值得到的字符串</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">6</span>,</span><br><span class="line">    b=<span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleTag</span>(<span class="params">strings,aValExression,bValExression,sumValExpression</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(strings);</span><br><span class="line">    <span class="built_in">console</span>.log(aValExression);</span><br><span class="line">    <span class="built_in">console</span>.log(bValExression);</span><br><span class="line">    <span class="built_in">console</span>.log(sumValExpression);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> untaggedResult=<span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a+b&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">let</span> taggedResult=simpleTag<span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a+b&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;]     这里是插值未生效的原始字符串数组</span></span><br><span class="line"><span class="comment">// 6      这里是第一个插值表达式的结果，也就是 a = 6</span></span><br><span class="line"><span class="comment">//9       第二个插值表达式的结果，也就是 b = 9</span></span><br><span class="line"><span class="comment">//15     第三个插值表达式的结果，也就是  a+b = 15</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(untaggedResult);   <span class="comment">//-&gt; &quot;6 + 9 = 15&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(taggedResult);   <span class="comment">//-&gt; &quot;foobar&quot;</span></span><br></pre></td></tr></table></figure>
<p>因为表达式的参数的数量是可变的，所以通常应该使用<strong>剩余操作符</strong>（rest operator）将它们收集到数组中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">6</span>,</span><br><span class="line">    b=<span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleTag</span>(<span class="params">strings,...expressions</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(strings);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> exp <span class="keyword">of</span> expressions)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(exp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用结果同上，不赘述</span></span><br></pre></td></tr></table></figure>
<p>对于有n个插值的模板字面量。传给标签函数的表达式参数个数始终是n，加上第一个参数则传给标签函数的参数始终是n+1。因此，如果想把这些字符串和对表达式求值的结果拼接起来作为默认返回的字符串，可以这样做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">6</span>,</span><br><span class="line">    b=<span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">zipTag</span>(<span class="params">strings,...expressions</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> strings[<span class="number">0</span>] + </span><br><span class="line">           expressions.map(<span class="function">(<span class="params">e,i</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;e&#125;</span><span class="subst">$&#123;strings[i+<span class="number">1</span>]&#125;</span>`</span>)</span><br><span class="line">                      .join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="comment">//map()：参数1表示当前元素的值；参数2表示当前元素的索引值</span></span><br><span class="line">    <span class="comment">//join()：按照给定的字符串作为分隔符拼接整个数组</span></span><br><span class="line">    <span class="comment">//拼接思路：先将原始字符串数组的第一个元素单独拿出来；将保存插值表达式结果的数组用map遍历，返回的值为 “当前插值表达式结果” + “对应的下一个原始数组字符串” 所产生的表达式，最后用join拼接。</span></span><br><span class="line">    <span class="comment">/*例子的拼接：第一个原始字符串元素：&quot;&quot; ;</span></span><br><span class="line"><span class="comment">      插值表达式数组：第一次遍历：6 + &quot; + &quot;; -&gt; 返回 &quot;6 + &quot;</span></span><br><span class="line"><span class="comment">                   第二次遍历：9 + &quot; = &quot;; -&gt; 返回 &quot;9 = &quot;</span></span><br><span class="line"><span class="comment">                   第三次遍历：15 + &quot;&quot;;  -&gt; 返回 &quot;15&quot;</span></span><br><span class="line"><span class="comment">                   join拼接：&quot;6 + 9 = 15&quot;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> untaggedResult=<span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a+b&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">let</span> taggedResult=zipTag<span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a+b&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(untaggedResult);   <span class="comment">//-&gt; &quot;6 + 9 = 15&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(taggedResult);   <span class="comment">//-&gt; &quot;6 + 9 = 15&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="7）原始字符串"><a href="#7）原始字符串" class="headerlink" title="7）原始字符串 *"></a>7）原始字符串 *</h5><p>使用模板字面量也可以<strong>直接获取原始的模板字面量内容</strong>（如换行符和Unicode字符），而不是被转换后的字符表示。为此，可以使用默认的String.raw标签函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`\u00A9`</span>);   <span class="comment">//-&gt; ©   对应的Unicode字符：版权符</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`\u00A9`</span>);   <span class="comment">//-&gt; \u00A9</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：原字符串中自带转义序列如换行符，可以直接获取到。但是对实际的换行行为无用，它们不会被转换成转义序列的形式。</p>
</blockquote>
<p>另外，可以通过标签函数的第一个参数（即字符串数组）的**.raw属性**取得每个字符串的原始内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printRaw</span>(<span class="params">strings</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> rawStr <span class="keyword">of</span> strings.raw)</span><br><span class="line">        <span class="built_in">console</span>.log(rawStr);</span><br><span class="line">&#125;</span><br><span class="line">printRaw<span class="string">`\u00A9 <span class="subst">$&#123;<span class="string">&#x27;and&#x27;</span>&#125;</span> \n`</span>;</span><br><span class="line"><span class="comment">//-&gt; \u00A9   返回的是原始内容，而非对应的Unicode字符</span></span><br><span class="line"><span class="comment">//-&gt; \n</span></span><br></pre></td></tr></table></figure>
<h4 id="3-2-7-symbol类型"><a href="#3-2-7-symbol类型" class="headerlink" title="3.2.7 symbol类型 *"></a>3.2.7 symbol类型 *</h4><p>Symbol（符号）是ES6新增的数据类型。<strong>符号是原始值，且符号实例是唯一、不可变的</strong>。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。</p>
<h5 id="1）符号的基本用法"><a href="#1）符号的基本用法" class="headerlink" title="1）符号的基本用法 *"></a>1）符号的基本用法 *</h5><p>符号需要使用<code>Symbol()</code>函数初始化。<code>typeof</code>操作符返回symobol：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym=<span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> sym);  <span class="comment">//-&gt; symbol </span></span><br></pre></td></tr></table></figure>
<p>可以传入一个字符串参数作为对符号的描述。符号没有字面量语法。</p>
<p><code>Symbol()</code>函数<strong>不能用作构造函数</strong>，与new关键字一起使用。这样避免创建符号包装对象，像使用Boolean、String、Number一样。如果确实想使用符号包装对象，可以借用Object函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym=<span class="keyword">new</span> <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(sym);<span class="comment">//-&gt; TypeError: Symbol is not a constructor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySym=<span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> myWrappedSym=<span class="built_in">Object</span>(mySym);  <span class="comment">//使用Object()创建符号包装对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myWrappedSym);    <span class="comment">//-&gt; object</span></span><br></pre></td></tr></table></figure>
<h5 id="2）使用全局符号注册表"><a href="#2）使用全局符号注册表" class="headerlink" title="2）使用全局符号注册表 *"></a>2）使用全局符号注册表 *</h5><p>如果运行时的不同部分<strong>需要共享和重用符号实例</strong>，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。使用<code>Symbol.for()</code>函数。</p>
<p><code>Symbol.for()</code>对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查<strong>全局运行时注册表</strong>，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同的字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol=<span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);    <span class="comment">//创建新符号</span></span><br><span class="line"><span class="keyword">let</span> otherFooGlobalSymbol=symbol.for(<span class="string">&#x27;foo&#x27;</span>);    <span class="comment">//重用已有符号</span></span><br><span class="line"><span class="built_in">console</span>.log(fooGlobalSymbol===otherFooGlobalSymbol);<span class="comment">//-&gt;true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是要注意，即便采用相同的符号描述，在全局注册表中定义的符号和使用SYmbol()定义的符号也并不等同：</span></span><br><span class="line"><span class="keyword">let</span> localSymbol=<span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(localSymbol===fooGlobalSymbol);  <span class="comment">//-&gt; false</span></span><br></pre></td></tr></table></figure>
<p>全局注册表中的符号<strong>必须使用字符串键</strong>来创建，因此传给<code>Symbol.for()</code>的任何值都会被转换为字符串。注册表中使用的键也会同时被用作符号描述。</p>
<p>还可以使用<code>Symbol.keyFor()</code>来<strong>查询全局注册表</strong>，这个方法接收符号，返回该全局符号对应的字符串键。若查询的不是全局符号，则返回undefined。若查询的不是符号，则会抛出TypeError。</p>
<h5 id="3）使用符号作为属性"><a href="#3）使用符号作为属性" class="headerlink" title="3）使用符号作为属性 *"></a>3）使用符号作为属性 *</h5><p>凡是可以<strong>使用字符串或数值作为属性</strong>的地方，都可以使用符号。这就包括了对象字面量属性和<code>Object.defineProperty()</code> / <code>object.definedProperties()</code>定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>),</span><br><span class="line">    s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>),</span><br><span class="line">    s3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;baz&#x27;</span>),</span><br><span class="line">    s4 = <span class="built_in">Symbol</span>(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  [s1]:<span class="string">&#x27;foo val&#x27;</span></span><br><span class="line">&#125;    <span class="comment">//也可以这样写：o[s1]=‘foo val&#x27;;</span></span><br><span class="line"><span class="built_in">console</span>.log(o);    <span class="comment">//-&gt; &#123; Symbol(foo): foo val &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, s2, &#123;<span class="attr">value</span>: <span class="string">&#x27;bar val&#x27;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">//-&gt; &#123;Symbol(foo): foo val, Symbol(bar): bar val&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>,defineProperties(o,&#123;</span><br><span class="line">  [s3]:&#123;<span class="attr">value</span>:<span class="string">&#x27;baz val&#x27;</span>&#125;,</span><br><span class="line">  [s4):&#123;<span class="attr">value</span>:<span class="string">&#x27;qux val&#x27;</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log (o):</span><br><span class="line"><span class="comment">/* -&gt; &#123;Symbol(foo): foo val, Symbol(bar): bar val,</span></span><br><span class="line"><span class="comment">       Symbol(baz): baz val, Symbol(qux): qux val&#125;  */</span></span><br></pre></td></tr></table></figure>
<p><code>object.getOwnPropertyNames()</code>返回对象实例的<strong>常规属性数组</strong>，而<code>Object.getOwnPropertySymbols()</code>返回对象实例的<strong>符号属性数组</strong>。这两个方法的返回值<strong>彼此互斥</strong>。<code>Object.getOwnPropertyDescriptors()</code>会返回<strong>同时包含常规和符号属性描述符</strong>的对象。<code>Reflect.ownKeys()</code>会返回两种类型的键：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>),</span><br><span class="line">    s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span>  o = &#123;</span><br><span class="line">    [s1]: <span class="string">&#x27;foo val&#x27;</span>,</span><br><span class="line">    [s2]: <span class="string">&#x27;bar val&#x27;</span>,</span><br><span class="line">    baz: <span class="string">&#x27;baz val&#x27;</span>,</span><br><span class="line">    qux: <span class="string">&#x27;qux val&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log (<span class="built_in">Object</span>.getOwnPropertySymbols(o))；</span><br><span class="line"><span class="comment">//-&gt; [symbol(foo),Symbol(bar)]   只返回符号属性数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(o));</span><br><span class="line"><span class="comment">//-&gt; [&quot;baz&quot;,&quot;qux&quot;]   只返回常规属性数组，与上互斥</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors (o));</span><br><span class="line"><span class="comment">//-&gt; &#123;baz: (...), qux: (...), Symbol(foo): (...), Symbol (bar):(...)&#125;    常规属性和符号属性都返回了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownkeys(o));</span><br><span class="line"><span class="comment">//-&gt; [&quot;baz&quot;,“qux”,Symbol(foo),Symbol (bar)]   返回的是常规属性和符号属性两种的键</span></span><br></pre></td></tr></table></figure>
<p>因为符号属性是对内存中符号的一个引用，所以<strong>直接创建并用作属性的符号不会丢失</strong>。但是，如果没有<strong>显式地保存对这些属性的引用</strong>，那么必须遍历对象的所有符号属性才能找到相应的属性键：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//和上面不同，这里直接在对象中使用Symbol()创建了符号实例作为属性，而没有显式的保存这些实例</span></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)]: <span class="string">&#x27;foo val&#x27;</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>)]: <span class="string">&#x27;bar val&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">//-&gt; (Symbol(foo):&#x27;foo val&#x27;, Symbol(bar): &#x27;bar val&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> barSymbol = <span class="built_in">Object</span>.getOwnPropertySymbols(o)</span><br><span class="line">          .find(<span class="function">(<span class="params">symbol</span>) =&gt;</span> symbol.tostring().match(<span class="regexp">/bar/</span>));</span><br><span class="line">congole.log(barSymbol);    <span class="comment">//-&gt; Symbol(bar)</span></span><br></pre></td></tr></table></figure>
<h5 id="4）常用内置符号"><a href="#4）常用内置符号" class="headerlink" title="4）常用内置符号 *"></a>4）常用内置符号 *</h5><p>ECMAScript 6 也引入了一批<strong>常用内置符号</strong>(well-known symbol )，用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以Symbol工厂函数字符串属性的形式存在。</p>
<p>这些内置符号最重要的用途之一是<strong>重新定义它们，从而改变原生结构的行为</strong>。比如，我们知道for-of 循环会在相关对象上使用<code>Symbol.iterator</code>属性，那么就可以通过在自定义对象上重新定义<code>Symbol.iterator</code>的值，来改变for-of在迭代该对象时的行为。</p>
<p>这些内置符号也没有什么特别之处，它们就是全局函数symbol的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。</p>
<blockquote>
<p>注意：在提到ECMAScript规范时，经常会引用符号在规范中的名称，前缀为@@。比如，@@giterator 指的就是Symbol.iterator。 </p>
</blockquote>
<blockquote>
<p>PS：后续一些ES6内置的Symbol值，也即是常用内置符号，将不在此提及。这里有篇CSDN上简单的总结：<a href="https://blog.csdn.net/c__dreamer/article/details/81873087">JavaScriptES6内置的Symbol值</a>。（文章缺少书中提及的另一个内置符号：Symbol.asyncIterator。但是由于该属性是ES2018规范的，因此只有版本非常新的浏览器才支持，所以也没必要全了解。用到的话就百度吧。）</p>
</blockquote>
<h4 id="3-2-8-Obejct类型"><a href="#3-2-8-Obejct类型" class="headerlink" title="3.2.8 Obejct类型"></a>3.2.8 Obejct类型</h4><p>使用  <code>new Object()</code>  新建一个对象。（可以省略括号，但不推荐）</p>
<p> Obeject类型的每个实例都具有下列属性和方法：</p>
<ul>
<li><code>constructor</code>：用于创建当前对象的函数。</li>
<li><code>hasOwnProperty(propertyName)</code>：用于判断当前对象实例中（不是原型）是否存在给定的属性。其中，作为参数的属性名必须以字符串形式存在（例如： <code>o.hasOwnProperty(&quot;name&quot;)</code>）。</li>
<li><code>isPrototypeOf(object)</code>：用于检查传入的对象是否是另一个对象的原型。</li>
<li><code>propertyIsEnumerable(*propertyName*)</code>：用于检查给定的属性是否能够使用for-in语句来枚举。参数必须以字符串形式存在。</li>
<li><code>toLocalString()</code>：返回对象的字符串表示，该字符串与执行环境的地区对应。</li>
<li><code>toString()</code>:返回对象的字符串表示。</li>
<li><code>valueOf()</code>：返回对象的字符串、数值或布尔值表示。通常与<code>toString()</code>方法的返回值相同。</li>
</ul>
<br>

<h3 id="3-3-操作符"><a href="#3-3-操作符" class="headerlink" title="3.3 操作符"></a>3.3 操作符</h3><h4 id="3-3-1-一元操作符"><a href="#3-3-1-一元操作符" class="headerlink" title="3.3.1 一元操作符"></a>3.3.1 一元操作符</h4><p><strong>1）递增递减操作符 ++  /  –</strong></p>
<p>递增递减操作符直接照搬自C语言，且分为前置型和后置型。</p>
<p>使用前置型时，变量的值都是在语句被求值以前改变的**。且由于前置递增和递减操作与执行语句的优先级相等，因此整个语句会从左至右被求值。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> num3 = --num1 + num2;      <span class="comment">//21</span></span><br><span class="line"><span class="keyword">var</span> num4 = num1 + num2;    <span class="comment">//21</span></span><br></pre></td></tr></table></figure>
<p><strong>后置型递增和递减操作都是在包含它们的语句被求值后才执行的</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> num3 = num1-- + num2;      <span class="comment">//22,此时--还未执行</span></span><br><span class="line"><span class="keyword">var</span> num4 = num1 + num2;       <span class="comment">//21，使用了num1递减后的值</span></span><br></pre></td></tr></table></figure>
<p>这些<strong>操作符适用任何类型的值</strong>。在应用不同的值时，遵循下列规则：</p>
<ul>
<li>应用一个<strong>包含有效数字字符的字符串</strong>时，先将其转化为<strong>数字值</strong>，再执行加减1的操作。字符串变量变成数值变量。</li>
<li>应用一个<strong>不包含有效数字的字符串</strong>时，将变量的值设置为<strong>NaN</strong>。字符串变量变为数值变量。</li>
<li>应用布尔值<strong>false</strong>时，先将其转化为0再执行加减1的操作。布尔值变量变为数值变量。</li>
<li>应用布尔值<strong>true</strong>时，先将其转化为1再执行加减1的操作。布尔值变量变为数值变量。</li>
<li>应用于对象时，（后面第5章会详细介绍）先调用对象的<code>valueOf()</code>方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是NaN，则调用<code>toString()</code>方法后再应用前述规则。对象变量变成数值变量。</li>
</ul>
<p><strong>2）一元加减操作符  +  /  -</strong></p>
<p>一元加操作符以一个加号表示，放在数值前不会产生任何影响。但应用在非数值时，该操作符会像<code>Number()</code>转型函数一样对这个值进行转换。</p>
<p>一元减操作符应用于数值时，该值会变成负数。应用于非数值时，遵循与一元加操作符相同的规则，最后将值转化为负数。</p>
<h4 id="3-3-2-位操作符"><a href="#3-3-2-位操作符" class="headerlink" title="3.3.2 位操作符"></a>3.3.2 位操作符</h4><p>位操作符用于数值的底层操作，即按内存中表示数值的位来操作数值。位操作符并不直接操作64位的值，而是先将64位转化为32位的整数，然后执行操作，最后再将结果转换回64位。</p>
<p>对于有符号的整数，<strong>32位中的前31位表示整数的值</strong>。<strong>第三十二位（即符号位）表示数值的符号</strong>：0表示正数，1表示负数。正数以纯二进制格式存储。</p>
<p>负数同样以二进制码存储，但使用的格式是二进制补码。计算补码步骤：</p>
<ol>
<li><em>求这个数值绝对值的二进制码；</em></li>
<li><em>求二进制反码，即0替换为1，1替换为0；</em></li>
<li><em>得到的二进制反码加1。</em></li>
</ol>
<p><strong>1）按位非（NOT）</strong></p>
<p>按位非操作符由一个波浪线（**~**）表示，执行按位非的结果就是返回数值的反码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">25</span>;    <span class="comment">//二进制00000000000000000000000000011001</span></span><br><span class="line"><span class="keyword">var</span> num2 = ~num1;  <span class="comment">//二进制1111111111111111111111111100110</span></span><br><span class="line">alert(num2);    <span class="comment">//-26</span></span><br></pre></td></tr></table></figure>
<p>按位非操作的本质：操作数的负值减1。但相比负值减1的操作，由于按位非是在数值表示的最底层执行操作，因此操作速度更快。</p>
<p><strong>2）按位与（AND）</strong></p>
<p>按位与操作符由一个和号字符（*<em>&amp;<strong>）表示，它有两个操作符数。从本质上讲，</strong>按位与操作就是将两个数值的每一位对齐<strong>，然后根据</strong></em>对应位都是1时才返回1，任何一位是0，结果都是0***的规则，对相同位置上的两个数执行AND操作。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">25</span> &amp; <span class="number">3</span>;</span><br><span class="line">alert(result);      <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//底层操作：</span></span><br><span class="line"> <span class="number">25</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line">  <span class="number">3</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">---------------------------------------------</span><br><span class="line">AND = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span></span><br></pre></td></tr></table></figure>
<p><strong>3）按位或（OR）</strong></p>
<p>按位或操作符由一个竖线符号（*<em>|<strong>）表示。同样也有两个操作数。根据</strong></em>有一个位是1的情况下就返回1，只有两个都是0的情况下才返回0***的规则执行OR操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">25</span> | <span class="number">3</span>;</span><br><span class="line">alert(result);    <span class="comment">//27</span></span><br></pre></td></tr></table></figure>
<p><strong>4）按位异或（XOR）</strong></p>
<p>按位异或由一个插入符号（<strong>^</strong>）表示。也有两个操作数。遵循两个数值**<em>对应位上只有一个1时才返回1，如果对应的两位都是1或都是0，则返回0**</em>的规则。</p>
<p><strong>5）左移</strong></p>
<p>左移操作符由两个小于号（**&lt;&lt;**）表示，这个操作符会将数值的所有位向左移动指定的位数。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oldValue = <span class="number">2</span>;      <span class="comment">//二进制码10</span></span><br><span class="line"><span class="keyword">var</span> newValue = oldValue &lt;&lt; <span class="number">5</span>;    <span class="comment">//二进制码1000000</span></span><br><span class="line"><span class="comment">//向左位移后，原数值的右侧多出了5个空位，左移操作会以0填充这些空位。</span></span><br></pre></td></tr></table></figure>
<p> 注意：左移不会影响操作数的符号位。换言之，-2左移5位的结果是-64而非64。</p>
<p><strong>6）右移</strong></p>
<p>有符号的右移操作符由两个大于号（**&gt;&gt;**）表示。这个操作符会将数值向右移动5位，但保留符号位（即正负号标记）。</p>
<p>同样，在移位过程中，原数值也会出现空位，而这次的空位出现在原数值的左侧、<strong>符号位的右侧</strong>。而此时ECMAScript会用<strong>符号位的值来填充所有的空位</strong>。</p>
<p><strong>7）无符号右移</strong></p>
<p>无符号右移操作符以三个大于号（**&gt;&gt;&gt;**）表示。这个操作符会将数值的所有32位都向右移动。对正数来说，无符号右移与有符号右移相同。</p>
<p>对于负数，无符号右移是<strong>以0填充空位</strong>而非以符号位的值。其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。由于负数以其绝对值的二进制补码形式表示，因此会导致无符号右移后的结果非常大。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oldValue = -<span class="number">64</span>;<span class="comment">//等于二进制111111111111111111111111000000</span></span><br><span class="line"><span class="keyword">var</span> newValue = oldValue &gt;&gt;&gt; <span class="number">5</span>;  <span class="comment">//等于十进制134217726</span></span><br><span class="line"><span class="comment">//这里无符号右移操作符会将这个二进制码当成正数的二进制码，换算成十进制就是4294967232，将其右移5位，结果就变成了000001111111111111111111111110,即十进制的134217726。</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-3-布尔操作符"><a href="#3-3-3-布尔操作符" class="headerlink" title="3.3.3 布尔操作符"></a>3.3.3 布尔操作符</h4><p><strong>1）逻辑非</strong></p>
<p>逻辑非操作符由一个感叹号（**!**）表示。无论这个值是什么数据类型，这个操作符都会返回一个布尔值然后对其求反。</p>
<p><strong>同时使用两个逻辑非操作符，实际上就会模拟Boolean()转型函数的行为</strong>。</p>
<p><strong>2）逻辑与</strong></p>
<p>逻辑与操作符由两个和号（**&amp;&amp;**）表示。逻辑与可以应用在任何类型的操作数，在有一个操作数不是布尔值的情况下，遵循下列规则：</p>
<ul>
<li>第一个操作数是对象，此时返回第二个操作数；</li>
<li>第二个操作数是对象，则只有在第一个操作数的求值结果位是true的情况下才会返回该对象；</li>
<li>如果两个操作数都是对象，则返回第二个操作数；</li>
<li>如果有一个操作数是null / NaN / undefined ，则返回null / NaN / undefined 。</li>
</ul>
<p><strong>逻辑与操作属于短路操作</strong>。即若第一个操作数求值结果为false，就不会对第二个数进行求值了。</p>
<p><strong>3）逻辑或</strong></p>
<p>逻辑或操作符由两个竖线符号（**||**）表示。逻辑或在有一个操作数不是布尔值的情况下遵循下列规则：</p>
<ul>
<li>第一个操作数是对象，则返回第一个操作数；</li>
<li>第一个操作数的求值结果为false，则返回第二个操作数；</li>
<li>如果两个操作数都是对象，则返回第一个对象</li>
<li>如果两个操作数都是null / NaN / undefined ，则返回null / NaN / undefined 。</li>
</ul>
<p><strong>逻辑或同属短路操作。</strong>即若第一个操作数求值结果为true，就不会对第二个数进行求值了。</p>
<p>我们可以利用逻辑或这一行为来避免为变量赋null或undefined值。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = preferredObject || backupObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在这个例子中，变量myObject将被赋予等号后面两个值中一个。变量preferredObject中包含优先赋给变量myObject的值，变量backupObject负责在preferredObject中不包含有效值的情况下提供后备值。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS：后面还有乘性操作符、加性操作符、关系操作符、相等操作符、赋值操作符、逗号操作符，就不再赘述。只要知道：</p>
<ol>
<li><p>乘性操作符、加性操作符、关系操作符在操作数为非数值的情况下，执行运算时都可以在后台转换不同的数据类型。</p>
</li>
<li><p>相等操作符：相等（==）和不相等（ !=）操作符在操作数类型不同时会先转换再比较；而全等（===）和全不等（ !==）仅作比较而不会转换。</p>
</li>
<li><p>在赋值时使用逗号操作符分隔值，最终会返回表达式中的最后一个值（这种使用场景并不多见，但确实存在）：</p>
<p><code>let num = (5,1,2,3,0);   //-&gt;  num的值会是0</code></p>
</li>
</ol>
</blockquote>
<br>

<h3 id="3-4-语句"><a href="#3-4-语句" class="headerlink" title="3.4 语句"></a>3.4 语句</h3><blockquote>
<p> if、for、while、do-while、break、continue、switch语句这里不再提及。</p>
<p> 因为不推荐with语句，所以这里也不再提及。with语句在严格模式下会报错。</p>
</blockquote>
<h4 id="3-4-1-循环语句"><a href="#3-4-1-循环语句" class="headerlink" title="3.4.1 循环语句 `"></a>3.4.1 循环语句 `</h4><p><strong>for-in语句</strong></p>
<p>语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(property <span class="keyword">in</span> expression) statement</span><br></pre></td></tr></table></figure>
<ul>
<li><p>定义迭代变量时推荐使用const（就如之前使用一样）；</p>
</li>
<li><p>for-in不能保证返回对象属性的顺序；</p>
</li>
<li><p>如果要迭代的变量是null和undefined。则不执行循环体。</p>
</li>
</ul>
<p><strong>for-of语句</strong></p>
<p>语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(property <span class="keyword">of</span> expression) statement</span><br></pre></td></tr></table></figure>
<ul>
<li>定义迭代变量推荐使用const；</li>
<li>for-of循环会按照可迭代对象的<code>next()</code>方法产生值得顺序迭代元素。可迭代对象会在第7章介绍。</li>
<li>若尝试迭代变量的不支持迭代，则语句会抛出错误。</li>
</ul>
<blockquote>
<p>注：ES2018对for-of语句，增加了for-await-of 循环，以支持生成期约（promise）的异步可迭代对象。（这个新增循环和前面提到的常用内置符号<code>Symbol.asyncIterator</code>有关系，可以自行了解）</p>
</blockquote>
<h4 id="3-4-2-标签语句"><a href="#3-4-2-标签语句" class="headerlink" title="3.4.2 标签语句"></a>3.4.2 标签语句</h4><p>使用label语句可以在代码中添加标签，以便将来使用。语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">label : statement</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例：</span></span><br><span class="line">start : <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">    alert(i);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//该例子中定义的start标签可以在将来由break或continue语句引用。加标签的语句一般都要与for语句等循环语句配合使用。</span></span><br></pre></td></tr></table></figure>
<br>

<h3 id="3-5-函数"><a href="#3-5-函数" class="headerlink" title="3.5 函数"></a>3.5 函数</h3><p>函数体中语句碰到return语句会立即停止执行并退出，后续代码不会被执行。<strong>return语句也可以不带返回值</strong>。这时候，函数会立即停止并返回undefined。这种用法最常用于<strong>提前终止函数执行</strong>。</p>
<p>严格模式下对函数有一些限制，若发生以下情况，会发生语法错误：</p>
<ul>
<li>不能把函数命名为eval或arguments；</li>
<li>不能把函数的参数命名为eval或arguments；</li>
<li>不能出现两个命名参数同名的情况。</li>
</ul>
<blockquote>
<p>第10章会更详细的介绍函数。</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>学习笔记</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数据结构与算法（下）</title>
    <url>/2021/01/19/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>注意：原教学视频：<a href="https://www.bilibili.com/video/BV1a5411t7vZ">JavaScript(ES6)数据结构和算法</a>  |  <a href="https://www.bilibili.com/video/BV1r7411n7Pw">JavaScript数据结构与算法</a> (都是CoderWhy老师的教学)</p>
<p>原作者（笔记）链接：<a href="https://github.com/XPoet/JS-Data-Structures-and-Algorithms">JavaScript 数据结构与算法</a>  |  <a href="https://www.cnblogs.com/AhuntSun-blog/p/12636718.html">JavaScript数据结构与算法博客目录</a></p>
<p>PS：本文仅在学习过程中，对两篇笔记进行整合及总结（包含少量补充），以作学习之用。侵权立删。</p>
<p>Part2: 集合、字典、哈希表、树、二叉树、二叉搜索树（红黑树这里不作整合，因为我也还没看懂）、图。</p>
</blockquote>
<a id="more"></a>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><hr>

<p>几乎每种编程语言中，都有集合结构。集合比较常见的实现方式是哈希表，这里使用 JavaScript 的 Object 进行封装。</p>
<h3 id="集合特点"><a href="#集合特点" class="headerlink" title="集合特点"></a>集合特点</h3><ul>
<li>集合通常是由一组<strong>无序的</strong>、<strong>不能重复的</strong>元素构成。<ul>
<li>数学中常指的集合中的元素是可以重复的，但是计算机中集合的元素不能重复。</li>
</ul>
</li>
<li>集合是特殊的数组：<ul>
<li>特殊之处在于里面的元素<strong>没有顺序</strong>，<strong>也不能重复</strong>。</li>
<li>没有顺序意味着<strong>不能通过下标值进行访问</strong>，不能重复意味着<strong>相同的对象</strong>在集合中<strong>只会存在一份</strong>。</li>
</ul>
</li>
</ul>
<h3 id="集合常见的操作"><a href="#集合常见的操作" class="headerlink" title="集合常见的操作"></a>集合常见的操作</h3><ul>
<li><code>add(value)</code>：向集合添加一个新的项；</li>
<li><code>remove(value)</code>：从集合中移除一个值；</li>
<li><code>has(value)</code>：如果值在集合中，返回<code>true</code>，否则返回<code>false</code>；</li>
<li><code>clear()</code>：移除集合中的所有项；</li>
<li><code>size()</code>：返回集合所包含元素的数量，与数组的<code>length</code>属性相似；</li>
<li><code>values()</code>：返回一个包含集合中所有值的数组；</li>
</ul>
<ul>
<li>还有其他的方法，用的不多这里不做封装。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>实现集合类</strong></p>
<ul>
<li>在ES6中的<strong>Set</strong>类就是一个集合类，这里我们重新封装一个Set类，了解集合的底层实现。</li>
<li>JavaScript中的<strong>Object</strong>类中的<strong>key</strong>就是一个集合，可以使用它来封装集合类Set。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装集合类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//属性</span></span><br><span class="line">  <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法</span></span><br><span class="line">  <span class="comment">//一.has方法</span></span><br><span class="line">  <span class="built_in">Set</span>.prototype.has = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.hasOwnProperty(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//二.add方法</span></span><br><span class="line">  <span class="built_in">Set</span>.prototype.add = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//判断集合中是否已经包含该元素</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.has(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将元素添加到集合中</span></span><br><span class="line">    <span class="built_in">this</span>.items[value] = value;<span class="comment">//表示该属性键和值都为value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//表示添加成功</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//三.remove方法</span></span><br><span class="line">  <span class="built_in">Set</span>.prototype.remove = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//1.判断集合中是否包含该元素</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.has(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.将元素从属性中删除</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.items[value];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//四.clear方法</span></span><br><span class="line">  <span class="built_in">Set</span>.prototype.clear = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//原来的对象没有引用指向，会被自动回收</span></span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//五.size方法</span></span><br><span class="line">  <span class="built_in">Set</span>.prototype.size = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items).length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取集合中所有的值</span></span><br><span class="line">  <span class="comment">//六.values方法</span></span><br><span class="line">  <span class="built_in">Set</span>.prototype.values = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码测试</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试集合类</span></span><br><span class="line"><span class="comment">//1.创建Set类对象</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="comment">//2.测试add方法</span></span><br><span class="line"><span class="built_in">console</span>.log(set.add(<span class="string">&#x27;a&#x27;</span>));										<span class="comment">//67</span></span><br><span class="line"><span class="built_in">console</span>.log(set.add(<span class="string">&#x27;a&#x27;</span>));										<span class="comment">//68</span></span><br><span class="line"><span class="built_in">console</span>.log(set.add(<span class="string">&#x27;b&#x27;</span>));										<span class="comment">//69</span></span><br><span class="line"><span class="built_in">console</span>.log(set.add(<span class="string">&#x27;c&#x27;</span>));										<span class="comment">//70</span></span><br><span class="line"><span class="built_in">console</span>.log(set.add(<span class="string">&#x27;d&#x27;</span>));										<span class="comment">//71</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试values方法</span></span><br><span class="line"><span class="built_in">console</span>.log(set.values());										<span class="comment">//74</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="comment">//4.测试remove方法</span></span><br><span class="line"><span class="built_in">console</span>.log(set.remove(<span class="string">&#x27;a&#x27;</span>));									<span class="comment">//78</span></span><br><span class="line"><span class="built_in">console</span>.log(set.remove(<span class="string">&#x27;a&#x27;</span>));									<span class="comment">//79</span></span><br><span class="line"><span class="built_in">console</span>.log(set.values());										<span class="comment">//80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.测试has方法</span></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="string">&#x27;b&#x27;</span>));										<span class="comment">//83</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.测试size方法和clear方法</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size());										<span class="comment">//86</span></span><br><span class="line">set.clear();</span><br><span class="line"><span class="comment">// 由于clear方法的实现原理为指向另外一个空对象，所以不影响原来的对象</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size());										<span class="comment">//89</span></span><br><span class="line"><span class="built_in">console</span>.log(set.values());										<span class="comment">//90</span></span><br></pre></td></tr></table></figure>
<p><strong>测试结果</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9B%86%E5%90%88%E5%92%8C%E5%AD%97%E5%85%B8/1.png"></p>
<h3 id="集合间的操作"><a href="#集合间的操作" class="headerlink" title="集合间的操作"></a>集合间的操作</h3><p><strong>集合间操作：</strong></p>
<ul>
<li><strong>并集</strong>：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合；</li>
<li><strong>交集</strong>：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合；</li>
<li><strong>差集</strong>：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合；</li>
<li><strong>子集</strong>：验证一个给定集合是否是另一个集合的子集；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9B%86%E5%90%88%E5%92%8C%E5%AD%97%E5%85%B8/2.png" alt="image-20200228210239984"></p>
<h4 id="并集的实现："><a href="#并集的实现：" class="headerlink" title="并集的实现："></a>并集的实现：</h4><p>实现思路：创建集合C代表集合A和集合B的并集，先将集合<code>A</code>中的所有元素添加到集合<code>C</code>中，再遍历集合<code>B</code>，如果是集合<code>C</code>所没有的元素就把它添加到集合<code>C</code>中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.union = <span class="function">(<span class="params">otherSet</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// this:集合对象A</span></span><br><span class="line">     <span class="comment">// otherSet:集合对象B</span></span><br><span class="line">     <span class="comment">//1.创建一个新的集合</span></span><br><span class="line">     <span class="keyword">let</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//2.将A集合中的所有元素添加到新集合中</span></span><br><span class="line">     <span class="keyword">let</span> values = <span class="built_in">this</span>.values();</span><br><span class="line">     <span class="comment">// for(let i of values)&#123;</span></span><br><span class="line">     <span class="comment">//   unionSet.add(i)</span></span><br><span class="line">     <span class="comment">// &#125;</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; values.length;i++)&#123;</span><br><span class="line">       unionSet.add(values[i]);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//3.取出B集合中的元素,判断是否需要加到新集合中</span></span><br><span class="line">     values = otherSet.values();</span><br><span class="line">     <span class="comment">// for(let i of values)&#123;</span></span><br><span class="line">     <span class="comment">//   //由于集合的add方法已经对重复的元素进行了判断,所以这里可以直接添加</span></span><br><span class="line">     <span class="comment">//   unionSet.add(i)</span></span><br><span class="line">     <span class="comment">// &#125;</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; values.length;i++)&#123;</span><br><span class="line">       unionSet.add(values[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> unionSet;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="交集的实现："><a href="#交集的实现：" class="headerlink" title="交集的实现："></a>交集的实现：</h4><p>实现思路：遍历集合A，当取得的元素也存在于集合B时，就把该元素添加到另一个集合C中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.intersection = <span class="function">(<span class="params">otherSet</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// this:集合A</span></span><br><span class="line">     <span class="comment">// otherSet:集合B</span></span><br><span class="line">     <span class="comment">//1.创建新的集合</span></span><br><span class="line">     <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//2.从A中取出一个元素，判断是否同时存在于集合B中，是则放入新集合中</span></span><br><span class="line">     <span class="keyword">let</span> values = <span class="built_in">this</span>.values();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span> ; i &lt; values.length; i++)&#123;</span><br><span class="line">       <span class="keyword">let</span> item = values[i];</span><br><span class="line">       <span class="keyword">if</span> (otherSet.has(item)) &#123;</span><br><span class="line">         intersectionSet.add(item);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> intersectionSet;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="差集的实现："><a href="#差集的实现：" class="headerlink" title="差集的实现："></a>差集的实现：</h4><p>实现思路：遍历集合A，当取得的元素不存在于集合B时，就把该元素添加到另一个集合C中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.diffrence = <span class="function">(<span class="params">otherSet</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//this:集合A</span></span><br><span class="line">        <span class="comment">//otherSet:集合B</span></span><br><span class="line">        <span class="comment">//1.创建新的集合</span></span><br><span class="line">        <span class="keyword">var</span> diffrenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.取出A集合中的每一个元素，判断是否同时存在于B中，不存在则添加到新集合中</span></span><br><span class="line">        <span class="keyword">var</span> values = <span class="built_in">this</span>.values();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; values.length; i++)&#123;</span><br><span class="line">          <span class="keyword">var</span> item = values[i];</span><br><span class="line">          <span class="keyword">if</span> (!otherSet.has(item)) &#123;</span><br><span class="line">            diffrenceSet.add(item);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diffrenceSet;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="子集的实现："><a href="#子集的实现：" class="headerlink" title="子集的实现："></a>子集的实现：</h4><p>实现思路：遍历集合A，当取得的元素中有一个不存在于集合B时，就说明集合A不是集合B的子集，返回false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.subset = <span class="function">(<span class="params">otherSet</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">//this:集合A</span></span><br><span class="line">       <span class="comment">//otherSet：集合B</span></span><br><span class="line">       <span class="comment">//遍历集合A中的所有元素，如果发现，集合A中的元素，在集合B中不存在，那么放回false，如果遍历完整个集合A没有返回false，就返回true</span></span><br><span class="line">       <span class="keyword">let</span> values = <span class="built_in">this</span>.values();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++)&#123;</span><br><span class="line">         <span class="keyword">let</span> item = values[i];</span><br><span class="line">         <span class="keyword">if</span>(!otherSet.has(item))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>


<h3 id="使用Class的完整实现"><a href="#使用Class的完整实现" class="headerlink" title="使用Class的完整实现"></a>使用Class的完整实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 集合结构的封装</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// has(value) 判断集合中是否存在 value 值，存在返回 true，否则返回 false</span></span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.hasOwnProperty(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add(value) 往集合中添加 value</span></span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.has(value)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.items[value] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove(value) 删除集合中指定的 value</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果集合不存在该 value，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.has(value)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.items[value];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// clear() 清空集合中所有 value</span></span><br><span class="line">  <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// size() 获取集合中的 value 个数</span></span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items).length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// values() 获取集合中所有的 value</span></span><br><span class="line">  <span class="function"><span class="title">values</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ------- 集合间的操作 ------- //</span></span><br><span class="line">  <span class="comment">// union() 求两个集合的并集</span></span><br><span class="line">  <span class="function"><span class="title">union</span>(<span class="params">otherSet</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、创建一个新集合</span></span><br><span class="line">    <span class="keyword">let</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、将当前集合（this）的所有 value，添加到新集合（unionSet）中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="built_in">this</span>.values()) &#123;</span><br><span class="line">      unionSet.add(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、将 otherSet 集合的所有 value，添加到新集合（unionSet）中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> otherSet.values()) &#123;</span><br><span class="line">      unionSet.add(value); <span class="comment">// add() 已经有重复判断</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unionSet;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// intersection() 求两个集合的交集</span></span><br><span class="line">  <span class="function"><span class="title">intersection</span>(<span class="params">otherSet</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建一个新集合</span></span><br><span class="line">    <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="built_in">this</span>.values()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (otherSet.has(value)) &#123;</span><br><span class="line">        intersectionSet.add(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intersectionSet;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// difference() 差集</span></span><br><span class="line">  <span class="function"><span class="title">difference</span>(<span class="params">otherSet</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建一个新集合</span></span><br><span class="line">    <span class="keyword">let</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在，不存在的即为差集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="built_in">this</span>.values()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!otherSet.has(value)) &#123;</span><br><span class="line">        differenceSet.add(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> differenceSet;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// subset() 子集</span></span><br><span class="line">  <span class="function"><span class="title">subset</span>(<span class="params">otherSet</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在，有不存在的返回 false</span></span><br><span class="line">    <span class="comment">// 遍历完所有的，返回 true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="built_in">this</span>.values()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!otherSet.has(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><hr>

<blockquote>
<p>一般会用哈希表实现，这里只作简单讲解。</p>
</blockquote>
<h3 id="字典特点"><a href="#字典特点" class="headerlink" title="字典特点"></a>字典特点</h3><ul>
<li>字典存储的是<strong>键值对</strong>，主要特点是<strong>一一对应</strong>。</li>
<li>比如保存一个人的信息<ul>
<li>数组形式：<code>[19，‘Tom’，1.65]</code>，可通过下标值取出信息。</li>
<li>字典形式：<code>&#123;&quot;age&quot;：19，&quot;name&quot;：&quot;Tom&quot;，&quot;height&quot;：165&#125;</code>，可以通过 <code>key</code> 取出 <code>value</code>。</li>
</ul>
</li>
<li>此外，在字典中 key 是不能重复且无序的，而 Value 可以重复。</li>
</ul>
<h3 id="字典和映射的关系"><a href="#字典和映射的关系" class="headerlink" title="字典和映射的关系"></a>字典和映射的关系</h3><ul>
<li>有些编程语言中称这种映射关系为<strong>字典</strong>，如 Swift 中的 Dictonary，Python 中的 dict。</li>
<li>有些编程语言中称这种映射关系为 <strong>Map</strong>，比如 Java 中的 HashMap 和 TreeMap 等。</li>
</ul>
<h3 id="字典和对象"><a href="#字典和对象" class="headerlink" title="字典和对象"></a>字典和对象</h3><ul>
<li>很多编程语言（如Java）中对字典和对象区分比较明显，对象通常是一种在编译期就确定下来的结构，不可以动态的添加或者删除属性。而字典通常会使用类似于哈希表和数据结构去实现一种可以动态的添加数据的结构。</li>
<li>但是在JavaScript中，似乎对象本身就是一种字典。所以在早期的Javascript中，没有字典这种数据类型，因为你完全可以使用对象去代替。</li>
</ul>
<h3 id="字典常见的操作"><a href="#字典常见的操作" class="headerlink" title="字典常见的操作"></a>字典常见的操作</h3><ul>
<li><code>set(key,value)</code> 向字典中添加新元素。</li>
<li><code>remove(key)</code> 通过使用键值来从字典中移除键值对应的数据值。</li>
<li><code>has(key)</code> 如果某个键值存在于这个字典中，则返回 <code>true</code>，反之则返回 <code>false</code>。</li>
<li><code>get(key)</code> 通过键值查找特定的数值并返回。</li>
<li><code>clear()</code> 将这个字典中的所有元素全部删除。</li>
<li><code>size()</code> 返回字典所包含元素的数量。与数组的 <code>length</code> 属性类似。</li>
<li><code>keys()</code> 将字典所包含的所有键名以数组形式返回。</li>
<li><code>values()</code> 将字典所包含的所有数值以数组形式返回。</li>
</ul>
<h3 id="字典封装"><a href="#字典封装" class="headerlink" title="字典封装"></a>字典封装</h3><p><strong>代码实现</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装字典类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dictionary</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//字典属性</span></span><br><span class="line">  <span class="built_in">this</span>.items = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//字典操作方法</span></span><br><span class="line">  <span class="comment">//一.在字典中添加键值对</span></span><br><span class="line">  Dictionary.prototype.set = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.items[key] = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//二.判断字典中是否有某个key</span></span><br><span class="line">  Dictionary.prototype.has = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.hasOwnProperty(key)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//三.从字典中移除元素</span></span><br><span class="line">  Dictionary.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1.判断字典中是否有这个key</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.has(key)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.从字典中删除key</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.items[key]</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//四.根据key获取value</span></span><br><span class="line">  Dictionary.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.has(key) ? <span class="built_in">this</span>.items[key] : <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//五.获取所有keys</span></span><br><span class="line">  Dictionary.prototype.keys = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//六.size方法</span></span><br><span class="line">  Dictionary.prototype.keys = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.keys().length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//七.clear方法</span></span><br><span class="line">  Dictionary.prototype.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*使用class实现*/</span></span><br><span class="line"><span class="comment">// 字典结构的封装</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Map</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// has(key) 判断字典中是否存在某个 key</span></span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.hasOwnProperty(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set(key, value) 在字典中添加键值对</span></span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove(key) 在字典中删除指定的 key</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果集合不存在该 key，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.has(key)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.items[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get(key) 获取指定 key 的 value，如果没有，返回 undefined</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.has(key) ? <span class="built_in">this</span>.items[key] : <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取所有的 key</span></span><br><span class="line">  <span class="function"><span class="title">keys</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取所有的 value</span></span><br><span class="line">  <span class="function"><span class="title">values</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.values(<span class="built_in">this</span>.items);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// size() 获取字典中的键值对个数</span></span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.keys().length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// clear() 清空字典中所有的键值对</span></span><br><span class="line">  <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码测试</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// set() 测试</span></span><br><span class="line">map.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;XPoet&quot;</span>);</span><br><span class="line">map.set(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line">map.set(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;i@xpoet.cn&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// &#123;items: &#123;name: &quot;XPoet&quot;, age: 18, email: &quot;i@xpoet.cn&quot;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// has() 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">&quot;name&quot;</span>)); <span class="comment">//--&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">&quot;address&quot;</span>)); <span class="comment">//--&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// remove() 测试</span></span><br><span class="line">map.remove(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// &#123;age: 18, email: &quot;i@xpoet.cn&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get() 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">&quot;age&quot;</span>)); <span class="comment">//--&gt; 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// keys() 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(map.keys()); <span class="comment">//--&gt; [&quot;age&quot;, &quot;email&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// values() 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(map.values()); <span class="comment">//--&gt; [18, &quot;i@xpoet.cn&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// size() 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size()); <span class="comment">//--&gt; 2</span></span><br></pre></td></tr></table></figure>
<br>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><hr>

<h3 id="认识哈希表"><a href="#认识哈希表" class="headerlink" title="认识哈希表"></a>认识哈希表</h3><p>哈希表是一种非常重要的数据结构，几乎所有的编程语言都直接或者间接应用这种数据结构。</p>
<p>哈希表通常是<strong>基于数组</strong>实现的，但是相对于数组，它存在更多<strong>优势</strong>：</p>
<ul>
<li>哈希表可以提供非常快速的<strong>插入-删除-查找</strong>操作。</li>
<li>无论多少数据，插入和删除值都只需接近常量的时间，即 <strong>O(1)</strong> 的时间复杂度。实际上，只需要几个机器指令即可完成。</li>
<li>哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。</li>
<li>哈希表相对于树来说编码要简单得多。</li>
</ul>
<p>哈希表同样存在<strong>不足之处</strong>：</p>
<ul>
<li>哈希表中的数据是<strong>没有顺序</strong>的，所以不能以一种固定的方式（比如从小到大 ）来遍历其中的元素。</li>
<li>通常情况下，哈希表中的 key 是<strong>不允许重复</strong>的，不能放置相同的 key，用于保存不同的元素。</li>
</ul>
<p><strong>哈希表是什么？</strong></p>
<ul>
<li>哈希表并不好理解，不像数组、链表和树等可通过图形的形式表示其结构和原理。</li>
<li>哈希表的结构就是数组，但它<strong>神奇之处在于对下标值的一种变换</strong>，这种变换我们可以称之为<strong>哈希函数</strong>，通过哈希函数可以获取 <strong>HashCode</strong>。</li>
</ul>
<p>通过以下案例了解哈希表：</p>
<ul>
<li>案例一：公司想要存储 1000 个人的信息，每一个工号对应一个员工的信息。若使用数组，增删数据时比较麻烦；使用链表，获取数据时比较麻烦。有没有一种数据结构，能把某一员工的姓名转换为它对应的工号，再根据工号查找该员工的完整信息呢？没错此时就可以使用哈希表的哈希函数来实现。</li>
<li>案例二：存储联系人和对应的电话号码：当要查找张三（比如）的号码时，若使用数组：由于不知道存储张三数据对象的下标值，所以查找起来十分麻烦，使用链表时也同样麻烦。而使用哈希表就能通过哈希函数把张三这个名称转换为它对应的下标值，再通过下标值查找效率就非常高了。</li>
</ul>
<p>也就是说：哈希表最后还是基于数据来实现的，只不过哈希表能够通过哈希函数把字符串转化为对应的<strong>下标值</strong>，建立字符串和下标值的映射关系。</p>
<h3 id="认识哈希化"><a href="#认识哈希化" class="headerlink" title="认识哈希化"></a>认识哈希化</h3><p>为了把字符串转化为对应的下标值，需要有一套编码系统，为了方便理解我们创建这样一套编码系统：比如 a 为 1，b 为 2，c 为 3，以此类推 z 为 26，空格为 27（不考虑大写情况）。</p>
<p>有了编码系统后，将字母转化为数字也有很多种方案：</p>
<ul>
<li>方案一：数字相加。</li>
</ul>
<p>例如 cats 转化为数字：<code>3 + 1 + 20 + 19 = 43</code>，那么就把 43 作为 cats 单词的下标值储存在数组中；</p>
<p>但是这种方式会存在这样的问题：很多的单词按照该方式转化为数字后都是 43，比如 was。而在数组中一个下标值只能储存一个数据，所以该方式不合理。</p>
<ul>
<li>方案二：幂的连乘。</li>
</ul>
<p>我们平时使用的大于 10 的数字，就是用幂的连乘来表示它的唯一性的。 比如： <code>6543 = 6 * 10^3 + 5 * 10^2 + 4 * 10 + 3</code>；这样单词也可以用该种方式来表示：<code>cats = 3 * 27^3 + 1 * 27^2 + 20 * 27 + 17 = 60337</code>。</p>
<p>虽然该方式可以保证字符的唯一性，但是如果是较长的字符（如 aaaaaaaaaa）所表示的数字就非常大，此时要求很大容量的数组，然而其中却有许多下标值指向的是无效的数据（比如不存在 zxcvvv 这样的单词），造成了数组空间的浪费。</p>
<p>两种方案总结：</p>
<ul>
<li>第一种方案（让数字相加求和）产生的数组下标太少。</li>
<li>第二种方案（与 27 的幂相乘求和）产生的数组下标又太多。</li>
</ul>
<p>现在需要一种压缩方法，把幂的连乘方案系统中得到的<strong>巨大整数范围压缩到可接受的数组范围中</strong>。可以通过<strong>取余</strong>操作来实现。虽然取余操作得到的结构也有可能重复，但是可以通过其他方式解决。</p>
<p>现在需要一种<strong>压缩方法</strong>，把幂的连乘方案系统中得到的<strong>巨大整数范围</strong>压缩到<strong>可接受的数组范围</strong>中。可以通过取余操作来实现。虽然取余操作得到的结构也有可能重复，但是可以通过其他方式解决。</p>
<h3 id="哈希表的一些概念"><a href="#哈希表的一些概念" class="headerlink" title="哈希表的一些概念"></a>哈希表的一些概念</h3><ul>
<li><strong>哈希化：</strong>将<strong>大数字</strong>转化成<strong>数组范围内下标</strong>的过程，称之为<strong>哈希化</strong>；</li>
<li><strong>哈希函数：</strong>我们通常会将<strong>单词</strong>转化成<strong>大数字</strong>，把<strong>大数字</strong>进行<strong>哈希化</strong>的代码实现放在一个函数中，该函数就称为<strong>哈希函数</strong>；</li>
<li><strong>哈希表：</strong>对最终将数据插入的<strong>数组</strong>进行整个<strong>结构的封装</strong>，得到的就是<strong>哈希表</strong>。</li>
</ul>
<h3 id="地址的冲突"><a href="#地址的冲突" class="headerlink" title="地址的冲突"></a>地址的冲突</h3><p>在实际中，经过哈希函数哈希化过后得到的下标值可能<strong>有重复</strong>，这种情况称为<strong>冲突</strong>，冲突是不可避免的，我们只能解决冲突。</p>
<p>解决冲突常见的两种方案：<strong>链地址法</strong>（拉链法）和<strong>开放地址法</strong>。</p>
<h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>如下图所示，我们将每一个数字都对<strong>10</strong>进行取余操作，则余数的范围<strong>0~9</strong>作为数组的下标值。并且，数组每一个下标值对应的位置存储的不再是一个数字了，而是存储由经过取余操作后得到相同余数的数字组成的<strong>数组</strong>或<strong>链表</strong>。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/1.png"></p>
<p>这样可以根据下标值获取到整个数组或链表，之后继续在数组或链表中查找就可以了。而且，产生冲突的元素一般不会太多。</p>
<p><strong>总结：</strong>链地址法解决冲突的办法是<strong>每个数组单元</strong>中存储的不再是<strong>单个数据</strong>，而是一条<strong>链条</strong>，这条链条常使用的数据结构为<strong>数组或链表</strong>，两种数据结构查找的效率相当（因为链条的元素一般不会太多）。</p>
<h4 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h4><p>开放地址法的主要工作方式是<strong>寻找空白的单元格</strong>来放置<strong>冲突</strong>的数据项。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/2.png"></p>
<p>根据探测空白单元格位置方式的不同，可分为三种方法：</p>
<ul>
<li><strong>线性探测</strong></li>
<li><strong>二次探测</strong></li>
<li><strong>再哈希法</strong></li>
</ul>
<h5 id="寻找空白单元格的方式"><a href="#寻找空白单元格的方式" class="headerlink" title="寻找空白单元格的方式"></a>寻找空白单元格的方式</h5><h6 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h6><p>线性探测很好理解：<strong>线性地查找空白的单元</strong>。</p>
<p><strong>当插入13时</strong>：</p>
<ul>
<li>经过哈希化（对10取余）之后得到的下标值index=3，但是该位置已经放置了数据33。而线性探测就是从<strong>index位置+1</strong>开始向后一个一个来查找<strong>合适的位置</strong>来放置13，所谓合适的位置指的是<strong>空的位置</strong>，如上图中index=4的位置就是合适的位置。</li>
</ul>
<p><strong>当查询13时</strong>：</p>
<ul>
<li>首先13经过哈希化得到index=3，如果index=3的位置存放的数据与需要查询的数据13相同，就直接返回；</li>
<li>不相同时，则线性查找，从<strong>index+1</strong>位置开始一个一个位置地查找数据13；</li>
<li>查询过程中不会遍历整个哈希表，只要查询到<strong>空位置，就停止</strong>，因为插入13时不会跳过空位置去插入其他位置。</li>
</ul>
<p><strong>当删除13时</strong>：</p>
<ul>
<li>删除操作和上述两种情况类似，但需要注意的是，删除一个数据项时，<strong>不能</strong>将该位置下标的内容<strong>设置为null</strong>，否则会<strong>影响到之后其他的查询操作</strong>，因为一遇到为null的位置就会停止查找。</li>
<li>通常<strong>删除一个位置的数据项</strong>时，我们可以<strong>将它进行特殊处理</strong>（比如设置为-1），这样在查找时遇到-1就知道要<strong>继续查找</strong>。</li>
</ul>
<p><strong>线性探测存在的问题</strong>：</p>
<ul>
<li>线性探测存在一个比较严重的问题，就是<strong>聚集</strong>；</li>
<li>如哈希表中还没插入任何元素时，插入23、24、25、26、27，这就意味着下标值为3、4、5、6、7的位置都放置了数据，这种<strong>一连串填充单元</strong>就称为<strong>聚集</strong>；</li>
<li>聚集会影响哈希表的<strong>性能</strong>，无论是插入/查询/删除都会影响；</li>
<li>比如插入13时就会发现，连续的单元3~7都不允许插入数据，并且在插入的过程中需要经历多次这种情况。二次探测法可以解决该问题。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/3.png"></p>
<h6 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h6><p>上文所说的<strong>线性探测存在的问题</strong>：</p>
<ul>
<li><p>如果之前的数据是<strong>连续插入</strong>的，那么新插入的一个数据可能需要<strong>探测很长的距离</strong>；</p>
<p>二次探测是在线性探测的基础上进行了<strong>优化</strong>：</p>
</li>
<li><p><strong>线性探测</strong>：我们可以看成是<strong>步长为1</strong>的探测，比如从下表值x开始，那么线性探测就是按照下标值：x+1、x+2、x+3等依次探测；</p>
</li>
<li><p><strong>二次探测</strong>：对步长进行了优化，比如从下标值x开始探测：x+1<sup>2</sup>、x+2<sup>2</sup>、x+3<sup>2</sup>。这样<strong>一次性探测比较长的距离</strong>，避免了数据聚集带来的影响。</p>
</li>
</ul>
<p><strong>二次探测存在的问题</strong>：</p>
<ul>
<li>当插入数据分布性较大的一组数据时，比如：13-163-63-3-213，这种情况会造成<strong>步长不一的一种聚集</strong>（虽然这种情况出现的概率较线性探测的聚集要小），同样会影响性能。</li>
</ul>
<h6 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h6><p>在开放地址法中寻找空白单元格的最好的解决方式为<strong>再哈希化</strong>：</p>
<ul>
<li>二次探测的步长是固定的：1，4，9，16依次类推；</li>
<li>现在需要一种方法：产生一种<strong>依赖关键字(数据)的探测序列</strong>，而不是每个关键字探测步长都一样；</li>
<li>这样，<strong>不同的关键字</strong>即使映射到<strong>相同的数组下标</strong>，也可以使用<strong>不同的探测序列</strong>；</li>
<li>再哈希法的做法为：把关键字用<strong>另一个</strong>哈希函数，<strong>再做一次哈希化</strong>，用这次哈希化的<strong>结果作为该关键字的步长</strong>；</li>
</ul>
<p>第二次哈希化需要满足以下两点：</p>
<ul>
<li>和<strong>第一个哈希函数不同</strong>，不然哈希化后的结果仍是原来位置；</li>
<li><strong>不能输出为0</strong>，否则每次探测都是原地踏步的死循环；</li>
</ul>
<p><strong>优秀的哈希函数</strong>：</p>
<ul>
<li><strong>stepSize = constant - （key % constant）</strong>；</li>
<li>其中constant是<strong>质数</strong>，且小于数组的容量；</li>
<li>例如：stepSize = 5 - （key % 5），满足需求，并且结果不可能为0；</li>
</ul>
<p><strong>哈希化的效率</strong></p>
<p>哈希表中执行插入和搜索操作效率是非常高的。</p>
<ul>
<li>如果没有<strong>发生冲突</strong>，那么效率就会更高；</li>
<li>如果<strong>发生冲突</strong>，存取时间就依赖后来的探测长度；</li>
<li>平均探测长度以及平均存取时间，取决于<strong>填装因子</strong>，随着填装因子变大，探测长度会越来越长。</li>
</ul>
<p>理解概念<strong>装填因子</strong>：</p>
<ul>
<li>装填因子表示当前哈希表中已经<strong>包含的数据项</strong>和<strong>整个哈希表长度</strong>的<strong>比值</strong>；</li>
<li><strong>装填因子 = 总数据项 / 哈希表长度</strong>；</li>
<li><strong>开放地址法的装填因子</strong>最大为<strong>1</strong>，因为只有空白的单元才能放入元素；</li>
<li><strong>链地址法的装填因子</strong>可以<strong>大于1</strong>，因为只要愿意，拉链法可以无限延伸下去；</li>
</ul>
<h6 id="不同探测方式性能的比较"><a href="#不同探测方式性能的比较" class="headerlink" title="不同探测方式性能的比较"></a>不同探测方式性能的比较</h6><blockquote>
<p>推算来自于Knuth（算法分析领域的专家，现代计算机的先驱人物）。这里不再给出推导过程和公式，仅根据公式模型说明它的效率。</p>
</blockquote>
<ul>
<li><strong>线性探测：</strong></li>
</ul>
<p>可以看到，随着装填因子的增大，平均探测长度呈指数形式增长，性能较差。实际情况中，最好的装填因子取决于存储效率和速度之间的平衡，随着装填因子变小，存储效率下降，而速度上升。</p>
<img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/4.png" style="zoom:80%;">



<ul>
<li><strong>二次探测和再哈希化的性能</strong>：</li>
</ul>
<p>二次探测和再哈希法性能相当，它们的性能比线性探测略好。由下图可知，随着装填因子的变大，平均探测长度呈指数形式增长，需要探测的次数也呈指数形式增长，性能不高。</p>
<img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/5.png" style="zoom:80%;">



<ul>
<li><strong>链地址法的性能：</strong></li>
</ul>
<p>可以看到随着装填因子的增加，平均探测长度呈线性增长，较为平缓。在开发中使用链地址法较多，比如Java中的HashMap中使用的就是<strong>链地址法</strong>。</p>
<img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/6.png" style="zoom:80%;">

<br>

<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>哈希表的优势在于它的速度，所以哈希函数不能采用消耗性能较高的复杂算法。提高速度的一个方法是在哈希函数中<strong>尽量减少乘法和除法</strong>。</p>
<p>性能高的哈希函数应具备以下两个优点：</p>
<ul>
<li><strong>快速的计算</strong>；</li>
<li><strong>均匀的分布</strong>。</li>
</ul>
<h4 id="快速计算"><a href="#快速计算" class="headerlink" title="快速计算"></a>快速计算</h4><p><strong>霍纳法则</strong>：在中国霍纳法则也叫做<strong>秦九韶算法</strong>，具体算法为：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/7.png"></p>
<p>求多项式的值时，首先计算最内层括号内一次多项式的值，然后由内向外逐层计算一次多项式的值。这种算法把求 n 次多项式 f(x)的值就转化为求 n 个一次多项式的值。</p>
<p>例如我们在前面计算哈希值时候使用的方式：</p>
<ul>
<li>cats = 3 * 27^3 + 1 * 27^2 + 20 * 27 + 17 = 60037</li>
</ul>
<p>将这个表达式抽象成一个多项式，则此时问题就变成了该多项式的乘法和加法的次数：</p>
<ul>
<li>变换之前：<ul>
<li>乘法次数：n(n+1)/2 次；</li>
<li>加法次数：n 次；</li>
</ul>
</li>
<li>变换之后：<ul>
<li>乘法次数：n 次；</li>
<li>加法次数：n 次；</li>
</ul>
</li>
</ul>
<p>如果使用大 O 表示时间复杂度的话，直接从变换前的 O(N^2)降到了 O(N)。</p>
<h4 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h4><p>在设计哈希表时，我们已经有办法处理映射到相同下标值的情况：链地址法或者开放地址法。</p>
<p>但是，为了提供效率，最好的情况还是让数据在哈希表中<strong>均匀分布</strong>。因此，我们需要在<strong>使用常量</strong>的地方，尽量使用<strong>质数</strong>。比如：哈希表的长度、N 次幂的底数等。（至于为什么最好取质数，数学问题这里不作原因讲解，可以自行了解）</p>
<p>Java 中的 HashMap 采用的是链地址法，哈希化采用的是公式为：index = HashCode(key) &amp; (Length-1)</p>
<p> 即将数据化为二进制进行<strong>与</strong>运算，而不是取余运算。这样计算机直接运算二进制数据，效率更高。但是 JavaScript 在进行较大数据的与运算时会出现问题，所以我们使用 JavaScript 实现哈希化时采用取余运算。</p>
<br>

<h3 id="封装哈希表"><a href="#封装哈希表" class="headerlink" title="封装哈希表"></a>封装哈希表</h3><h4 id="哈希表常见操作"><a href="#哈希表常见操作" class="headerlink" title="哈希表常见操作"></a>哈希表常见操作</h4><ul>
<li><code>put(key, value)</code> 插入或修改操作。</li>
<li><code>get(key)</code> 获取哈希表中特定位置的元素。</li>
<li><code>remove(key)</code> 删除哈希表中特定位置的元素。</li>
<li><code>isEmpty()</code> 如果哈希表中不包含任何元素，返回 trun，如果哈希表长度大于 0 则返回 false。</li>
<li><code>size()</code> 返回哈希表包含的元素个数。</li>
<li><code>resize(value)</code> 对哈希表进行扩容操作。</li>
</ul>
<h4 id="哈希函数的简单实现"><a href="#哈希函数的简单实现" class="headerlink" title="哈希函数的简单实现"></a>哈希函数的简单实现</h4><p>首先使用霍纳法则计算 hashCode 的值，通过取余操作实现哈希化，此处先简单地指定数组的大小。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashFunc</span>(<span class="params">string, size = <span class="number">7</span></span>) </span>&#123;   <span class="comment">//参数二为长度，默认为7</span></span><br><span class="line">  <span class="comment">// 自己采用的一个质数（无强制要求，质数即可），这里采用常用的37</span></span><br><span class="line">  <span class="keyword">const</span> PRIME = <span class="number">37</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1、定义存储 hashCode 的变量</span></span><br><span class="line">  <span class="keyword">let</span> hashCode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2、使用霍纳法则（秦九韶算法），计算 hashCode 的值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; string.length; i++) &#123;</span><br><span class="line">    hashCode = PRIME * hashCode + <span class="built_in">String</span>.charCodeAt(i);</span><br><span class="line">      <span class="comment">//charCodeAt():返回字符串指定位置字符的Unicode编码</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3、对 hashCode 取余，并返回</span></span><br><span class="line">  <span class="keyword">return</span> hashCode % size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>哈希函数测试</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(hashFunc(<span class="string">&quot;123&quot;</span>)); <span class="comment">//--&gt; 4</span></span><br><span class="line"><span class="built_in">console</span>.log(hashFunc(<span class="string">&quot;nba&quot;</span>)); <span class="comment">//--&gt; 5</span></span><br><span class="line"><span class="built_in">console</span>.log(hashFunc(<span class="string">&quot;abcd&quot;</span>)); <span class="comment">//--&gt; 3</span></span><br></pre></td></tr></table></figure>
<h4 id="哈希表的实现"><a href="#哈希表的实现" class="headerlink" title="哈希表的实现"></a>哈希表的实现</h4><blockquote>
<p>这里只放出使用function实现的代码，使用class实现见后面完整代码。</p>
</blockquote>
<h5 id="0-创建哈希表类"><a href="#0-创建哈希表类" class="headerlink" title="0. 创建哈希表类"></a>0. 创建哈希表类</h5><p>这里使用链地址法实现哈希表。</p>
<p>封装哈希表的数组结构模型:</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/9.png"></p>
<p>首先创建哈希表类HashTable，并添加必要的属性和上面实现的哈希函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装哈希表类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//属性</span></span><br><span class="line">  <span class="built_in">this</span>.storage = [];</span><br><span class="line">  <span class="built_in">this</span>.count = <span class="number">0</span>;<span class="comment">//计算已经存储的元素个数</span></span><br><span class="line">  <span class="comment">//装填因子：loadFactor &gt; 0.75时需要扩容；loadFactor &lt; 0.25时需要减少容量</span></span><br><span class="line">  <span class="built_in">this</span>.limit = <span class="number">7</span>;<span class="comment">//初始长度</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">//方法</span></span><br><span class="line">  <span class="comment">//哈希函数</span></span><br><span class="line">  HashTable.prototype.hashFunc = <span class="function"><span class="keyword">function</span>(<span class="params">str, size=<span class="number">7</span></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 自己采用的一个质数（无强制要求，质数即可），这里采用常用的37</span></span><br><span class="line">  <span class="keyword">const</span> PRIME = <span class="number">37</span>;</span><br><span class="line">  <span class="comment">// 1、定义存储 hashCode 的变量</span></span><br><span class="line">  <span class="keyword">let</span> hashCode = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 2、使用霍纳法则（秦九韶算法），计算 hashCode 的值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; string.length; i++) &#123;</span><br><span class="line">    hashCode = PRIME * hashCode + <span class="built_in">String</span>.charCodeAt(i);</span><br><span class="line">      <span class="comment">//charCodeAt():返回字符串指定位置字符的Unicode编码</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3、对 hashCode 取余，并返回</span></span><br><span class="line">  <span class="keyword">return</span> hashCode % size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-put-key-value"><a href="#1-put-key-value" class="headerlink" title="1. put(key,value)"></a>1. put(key,value)</h5><p>哈希表的插入和修改操作是同一个函数：因为，当使用者传入一个&lt;key，value&gt;时，如果原来不存在该key，那么就是插入操作，如果原来已经存在该key，那么就是修改操作。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/10.png"></p>
<p><strong>实现思路：</strong></p>
<ul>
<li>首先，根据key获取索引值index，目的为将数据插入到storage的对应位置；</li>
<li>然后，根据索引值取出bucket，如果bucket不存在，先创建bucket，随后放置在该索引值的位置；</li>
<li>接着，判断新增还是修改原来的值。如果已经有值了，就修改该值；如果没有，就执行后续操作。</li>
<li>最后，进行新增数据操作。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入&amp;修改操作</span></span><br><span class="line">HashTable.prototype.put = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.根据key获取对应的index</span></span><br><span class="line">  <span class="keyword">let</span> index = <span class="built_in">this</span>.hashFunc(key, <span class="built_in">this</span>.limit);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.根据index取出对应的bucket</span></span><br><span class="line">  <span class="keyword">let</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.判断该bucket是否为null</span></span><br><span class="line">  <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">    bucket = [];</span><br><span class="line">    <span class="built_in">this</span>.storage[index] = bucket;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4.判断是否是修改数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> tuple = bucket[i];  <span class="comment">//此时tuple为[key,value]的数组</span></span><br><span class="line">    <span class="keyword">if</span> (tuple[<span class="number">0</span>] == key) &#123;</span><br><span class="line">      tuple[<span class="number">1</span>] = value;</span><br><span class="line">      <span class="keyword">return</span><span class="comment">//不用返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//5.进行添加操作</span></span><br><span class="line">  bucket.push([key, value]);</span><br><span class="line">  <span class="built_in">this</span>.count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试哈希表</span></span><br><span class="line"><span class="comment">//1.创建哈希表</span></span><br><span class="line"><span class="keyword">let</span> ht = <span class="keyword">new</span> HashTable();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">ht.put(<span class="string">&#x27;class1&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class2&#x27;</span>,<span class="string">&#x27;Mary&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class3&#x27;</span>,<span class="string">&#x27;Gogo&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class4&#x27;</span>,<span class="string">&#x27;Tony&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class4&#x27;</span>, <span class="string">&#x27;Vibi&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ht);</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/11.png"></p>
<br>

<h5 id="2-get-key"><a href="#2-get-key" class="headerlink" title="2. get(key)"></a>2. get(key)</h5><p><strong>实现思路</strong>：</p>
<ul>
<li>首先，根据key通过哈希函数获取它在storage中对应的索引值index；</li>
<li>然后，根据索引值获取对应的bucket；</li>
<li>接着，判断获取到的bucket是否为null，如果为null，直接返回null；</li>
<li>随后，线性遍历bucket中每一个key是否等于传入的key。如果等于，直接返回对应的value；</li>
<li>最后，遍历完bucket后，仍然没有找到对应的key，直接return null即可。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取操作</span></span><br><span class="line"> HashTable.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//1.根据key获取对应的index</span></span><br><span class="line">   <span class="keyword">let</span> index = <span class="built_in">this</span>.hashFunc(key, <span class="built_in">this</span>.limit);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.根据index获取对应的bucket</span></span><br><span class="line">   <span class="keyword">let</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.判断bucket是否等于null</span></span><br><span class="line">   <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//4.有bucket，那么就进行线性查找</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">     <span class="keyword">let</span> tuple = bucket[i];</span><br><span class="line">     <span class="keyword">if</span> (tuple[<span class="number">0</span>] == key) &#123;<span class="comment">//tuple[0]存储key，tuple[1]存储value</span></span><br><span class="line">       <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//5.依然没有找到，那么返回null</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//测试哈希表</span></span><br><span class="line">   <span class="comment">//1.创建哈希表</span></span><br><span class="line">   <span class="keyword">let</span> ht = <span class="keyword">new</span> HashTable();</span><br><span class="line">   </span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">   ht.put(<span class="string">&#x27;class1&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line">   ht.put(<span class="string">&#x27;class2&#x27;</span>,<span class="string">&#x27;Mary&#x27;</span>)</span><br><span class="line">   ht.put(<span class="string">&#x27;class3&#x27;</span>,<span class="string">&#x27;Gogo&#x27;</span>)</span><br><span class="line">   ht.put(<span class="string">&#x27;class4&#x27;</span>,<span class="string">&#x27;Tony&#x27;</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//3.获取数据</span></span><br><span class="line">   <span class="built_in">console</span>.log(ht.get(<span class="string">&#x27;class3&#x27;</span>));</span><br><span class="line">   <span class="built_in">console</span>.log(ht.get(<span class="string">&#x27;class2&#x27;</span>));</span><br><span class="line">   <span class="built_in">console</span>.log(ht.get(<span class="string">&#x27;class1&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/12.png"></p>
<br>

<h5 id="3-remove-key"><a href="#3-remove-key" class="headerlink" title="3. remove(key)"></a>3. remove(key)</h5><p><strong>实现思路</strong>：</p>
<ul>
<li>首先，根据key通过哈希函数获取它在storage中对应的索引值index；</li>
<li>然后，根据索引值获取对应的bucket；</li>
<li>接着，判断获取到的bucket是否为null，如果为null，直接返回null；</li>
<li>随后，线性查找bucket，寻找对应的数据，并且删除；</li>
<li>最后，依然没有找到，返回null；</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"> HashTable.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//1.根据key获取对应的index</span></span><br><span class="line">   <span class="keyword">let</span> index = <span class="built_in">this</span>.hashFunc(key, <span class="built_in">this</span>.limit);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.根据index获取对应的bucket</span></span><br><span class="line">   <span class="keyword">let</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.判断bucket是否为null</span></span><br><span class="line">   <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//4.有bucket,那么就进行线性查找并删除</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">     <span class="keyword">let</span> tuple = bucket[i];</span><br><span class="line">     <span class="keyword">if</span> (tuple[<span class="number">0</span>] == key) &#123;</span><br><span class="line">       bucket.splice(i,<span class="number">1</span>);  <span class="comment">//splice()会改变原数组</span></span><br><span class="line">       <span class="built_in">this</span>.count -= <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//5.依然没有找到，返回null</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//测试哈希表</span></span><br><span class="line">   <span class="comment">//1.创建哈希表</span></span><br><span class="line">   <span class="keyword">let</span> ht = <span class="keyword">new</span> HashTable();</span><br><span class="line">   </span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">   ht.put(<span class="string">&#x27;class1&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line">   ht.put(<span class="string">&#x27;class2&#x27;</span>,<span class="string">&#x27;Mary&#x27;</span>);</span><br><span class="line">   ht.put(<span class="string">&#x27;class3&#x27;</span>,<span class="string">&#x27;Gogo&#x27;</span>);</span><br><span class="line">   ht.put(<span class="string">&#x27;class4&#x27;</span>,<span class="string">&#x27;Tony&#x27;</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//3.删除数据</span></span><br><span class="line">   <span class="built_in">console</span>.log( ht.remove(<span class="string">&#x27;class2&#x27;</span>));</span><br><span class="line">   <span class="built_in">console</span>.log(ht.get(<span class="string">&#x27;class2&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/13.png"></p>
<br>

<h5 id="4-其他方法"><a href="#4-其他方法" class="headerlink" title="4. 其他方法"></a>4. 其他方法</h5><p>其他方法包括：**isEmpty()、size()**：</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断哈希表是否为null</span></span><br><span class="line">  HashTable.prototype.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取哈希表中元素的个数</span></span><br><span class="line">  HashTable.prototype.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<br>

<h4 id="哈希表的扩容与压缩"><a href="#哈希表的扩容与压缩" class="headerlink" title="哈希表的扩容与压缩"></a>哈希表的扩容与压缩</h4><p>为什么需要扩容？</p>
<ul>
<li>前面我们在哈希表中使用的是<strong>长度为7的数组</strong>，由于使用的是**链地址法，装填因子(loadFactor)**可以大于1，所以这个哈希表可以无限制地插入新数据。</li>
<li>但是，随着<strong>数据量的增多</strong>，storage中每一个index对应的bucket数组（链表）就会越来越长，这就会造成哈希表<strong>效率的降低</strong></li>
</ul>
<blockquote>
<p><strong>装填因子</strong> = 哈希表中数据 / 哈希表长度，即 loadFactor = count / HashTable.length。</p>
</blockquote>
<p>什么情况下需要扩容？</p>
<ul>
<li>常见的情况是<strong>loadFactor &gt; 0.75</strong>的时候进行扩容；</li>
</ul>
<p>如何进行扩容？</p>
<ul>
<li>简单的扩容可以直接扩大<strong>两倍</strong>（关于质数，之后讨论）；</li>
<li>扩容之后<strong>所有的</strong>数据项都要进行<strong>同步修改</strong>；</li>
</ul>
<p><strong>实现思路:</strong></p>
<ul>
<li>首先，定义一个变量，比如oldStorage指向原来的storage；</li>
<li>然后，创建一个新的容量更大的数组，让this.storage指向它；</li>
<li>最后，将oldStorage中的每一个bucket中的每一个数据取出来依次添加到this.storage指向的新数组中；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/15.png"></p>
<p>代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希表扩容</span></span><br><span class="line">HashTable.prototype.resize = <span class="function"><span class="keyword">function</span>(<span class="params">newLimit</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.保存旧的storage数组内容</span></span><br><span class="line">  <span class="keyword">let</span> oldStorage = <span class="built_in">this</span>.storage;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.重置所有的属性</span></span><br><span class="line">  <span class="built_in">this</span>.storage = [];</span><br><span class="line">  <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.limit = newLimit;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.遍历oldStorage中所有的bucket</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; oldStorage.length; i++) &#123;</span><br><span class="line">    <span class="comment">//3.1.取出对应的bucket</span></span><br><span class="line">    <span class="keyword">const</span> bucket = oldStorage[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.2.判断bucket是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;      </span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3.bucket中有数据，就取出数据重新插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">      <span class="keyword">const</span> tuple = bucket[j];</span><br><span class="line">      <span class="built_in">this</span>.put(tuple[<span class="number">0</span>], tuple[<span class="number">1</span>]);<span class="comment">//插入数据的key和value</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述定义的哈希表的resize方法，既可以实现哈希表的<strong>扩容</strong>，也可以实现哈希表容量的<strong>压缩</strong>。</p>
<ul>
<li>通常情况下当<strong>装填因子laodFactor &gt; 0.75</strong>时，对哈希表进行扩容。在哈希表中的添加方法（push方法）中添加如下代码，判断是否需要调用扩容函数进行扩容：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容操作</span></span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">this</span>.count &gt; <span class="built_in">this</span>.limit * <span class="number">0.75</span>)&#123;</span><br><span class="line">   <span class="built_in">this</span>.resize(<span class="built_in">this</span>.limit * <span class="number">2</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当<strong>装填因子laodFactor &lt; 0.25</strong>时，对哈希表容量进行压缩。在哈希表中的删除方法（remove方法）中添加如下代码，判断是否需要调用扩容函数进行压缩：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//缩小容量</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.limit &gt; <span class="number">7</span> &amp;&amp; <span class="built_in">this</span>.count &lt; <span class="built_in">this</span>.limit * <span class="number">0.25</span>) &#123;</span><br><span class="line">  <span class="built_in">this</span>.resize(<span class="built_in">Math</span>.floor(<span class="built_in">this</span>.limit / <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="选择质数作为哈希表容量"><a href="#选择质数作为哈希表容量" class="headerlink" title="选择质数作为哈希表容量"></a>选择质数作为哈希表容量</h4><p><strong>判断质数的方法</strong>：</p>
<blockquote>
<p>注意1不是质数</p>
</blockquote>
<ul>
<li>方法一：针对质数的特点：只能被1和num整除，不能被2 ~ (num-1)整除。遍历2 ~ (num-1) 。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num &lt;= <span class="number">1</span> )&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= num - <span class="number">1</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(num % i ==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法虽然能实现质数的判断，但是效率不高。</p>
<ul>
<li>方法二：只需要遍历2 ~ num的平方根即可。(原因这里不作讲解，可以参考视频)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//1.获取num的平方根:Math.sqrt(num)</span></span><br><span class="line">   <span class="comment">//2.循环判断</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i&lt;= <span class="built_in">Math</span>.sqrt(num); i++ )&#123;</span><br><span class="line">     <span class="keyword">if</span>(num % i == <span class="number">0</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现扩容后的哈希表容量为质数</strong></p>
<p><strong>实现思路：</strong></p>
<p>2倍扩容之后，通过循环调用isPrime判断得到的容量是否为质数，不是则+1，直到是为止。比如原长度：7，2倍扩容后长度为14，14不是质数，14 + 1 = 15不是质数，15 + 1 = 16不是质数，16 + 1 = 17是质数，停止循环，由此得到质数17。</p>
<p><strong>代码实现：</strong></p>
<ul>
<li><strong>第一步：</strong>首先需要为HashTable类添加判断质数的isPrime方法和获取质数的getPrime方法：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断传入的num是否质数</span></span><br><span class="line">HashTable.prototype.isPrime = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.获取num的平方根:Math.sqrt(num)</span></span><br><span class="line">    <span class="comment">//2.循环判断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i&lt;= <span class="built_in">Math</span>.sqrt(num); i++ )&#123;</span><br><span class="line">      <span class="keyword">if</span>(num % i == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取质数的方法</span></span><br><span class="line">  HashTable.prototype.getPrime = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">     <span class="comment">//7*2=14,+1=15,+1=16,+1=17(质数)</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isPrime(num)) &#123;</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>第二步：</strong>修改添加元素的put方法和删除元素的remove方法中关于数组扩容的相关操作：</li>
</ul>
<p>在put方法中添加如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容操作</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.count &gt; <span class="built_in">this</span>.limit * <span class="number">0.75</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> newSize = <span class="built_in">this</span>.limit * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">let</span> newPrime = <span class="built_in">this</span>.getPrime(newSize);</span><br><span class="line">  <span class="built_in">this</span>.resize(newPrime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在remove方法中添加如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//缩小容量</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.limit &gt; <span class="number">7</span> &amp;&amp; <span class="built_in">this</span>.count &lt; <span class="built_in">this</span>.limit * <span class="number">0.25</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newSize = <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.limit / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">let</span> newPrime = <span class="built_in">this</span>.getPrime(newSize);</span><br><span class="line">  <span class="built_in">this</span>.resize(newPrime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ht = <span class="keyword">new</span> HashTable();</span><br><span class="line"></span><br><span class="line">ht.put(<span class="string">&#x27;class1&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class2&#x27;</span>,<span class="string">&#x27;Mary&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class3&#x27;</span>,<span class="string">&#x27;Gogo&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class4&#x27;</span>,<span class="string">&#x27;Tony&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class5&#x27;</span>,<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class6&#x27;</span>,<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class7&#x27;</span>,<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class8&#x27;</span>,<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class9&#x27;</span>,<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">ht.put(<span class="string">&#x27;class10&#x27;</span>,<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ht.size());<span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(ht.limit);<span class="comment">//17</span></span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/16.png"></p>
<h4 id="哈希表的完整实现"><a href="#哈希表的完整实现" class="headerlink" title="哈希表的完整实现"></a>哈希表的完整实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*使用function实现*/</span>	</span><br><span class="line">    <span class="comment">//封装哈希表类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//属性</span></span><br><span class="line">      <span class="built_in">this</span>.storage = []</span><br><span class="line">      <span class="built_in">this</span>.count = <span class="number">0</span><span class="comment">//计算已经存储的元素个数</span></span><br><span class="line">      <span class="comment">//装填因子：loadFactor &gt; 0.75时需要扩容；loadFactor &lt; 0.25时需要减少容量</span></span><br><span class="line">      <span class="built_in">this</span>.limit = <span class="number">7</span><span class="comment">//初始长度</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//方法</span></span><br><span class="line">      <span class="comment">//哈希函数</span></span><br><span class="line">      HashTable.prototype.hashFunc = <span class="function"><span class="keyword">function</span>(<span class="params">str, size=<span class="number">7</span></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//1.定义hashCode变量</span></span><br><span class="line">      <span class="keyword">let</span> hashCode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.霍纳法则，计算hashCode的值</span></span><br><span class="line">      <span class="comment">//cats -&gt; Unicode编码</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ;i &lt; str.length; i++)&#123;</span><br><span class="line">        <span class="comment">// str.charCodeAt(i)//获取某个字符对应的unicode编码</span></span><br><span class="line">        hashCode = <span class="number">37</span> * hashCode + str.charCodeAt(i);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.取余操作</span></span><br><span class="line">      <span class="keyword">let</span> index = hashCode % size;</span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一.插入&amp;修改操作</span></span><br><span class="line">    HashTable.prototype.put = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//1.根据key获取对应的index</span></span><br><span class="line">      <span class="keyword">let</span> index = <span class="built_in">this</span>.hashFunc(key, <span class="built_in">this</span>.limit);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.根据index取出对应的bucket</span></span><br><span class="line">      <span class="keyword">let</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.判断该bucket是否为null</span></span><br><span class="line">      <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">        bucket = [];</span><br><span class="line">        <span class="built_in">this</span>.storage[index] = bucket;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.判断是否是修改数据</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tuple = bucket[i];</span><br><span class="line">        <span class="keyword">if</span> (tuple[<span class="number">0</span>] == key) &#123;</span><br><span class="line">          tuple[<span class="number">1</span>] = value;</span><br><span class="line">          <span class="keyword">return</span><span class="comment">//不用返回值</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//5.进行添加操作</span></span><br><span class="line">      bucket.push([key, value]);</span><br><span class="line">      <span class="built_in">this</span>.count += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//6.判断是否需要扩容操作</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>.count &gt; <span class="built_in">this</span>.limit * <span class="number">0.75</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> newSize = <span class="built_in">this</span>.limit * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">let</span> newPrime = <span class="built_in">this</span>.getPrime(newSize);</span><br><span class="line">        <span class="built_in">this</span>.resize(newPrime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二.获取操作</span></span><br><span class="line">    HashTable.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//1.根据key获取对应的index</span></span><br><span class="line">      <span class="keyword">let</span> index = <span class="built_in">this</span>.hashFunc(key, <span class="built_in">this</span>.limit);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.根据index获取对应的bucket</span></span><br><span class="line">      <span class="keyword">let</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.判断bucket是否等于null</span></span><br><span class="line">      <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.有bucket，那么就进行线性查找</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tuple = bucket[i];</span><br><span class="line">        <span class="keyword">if</span> (tuple[<span class="number">0</span>] == key); &#123;<span class="comment">//tuple[0]存储key，tuple[1]存储value</span></span><br><span class="line">          <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//5.依然没有找到，那么返回null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//三.删除操作</span></span><br><span class="line">    HashTable.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//1.根据key获取对应的index</span></span><br><span class="line">      <span class="keyword">let</span> index = <span class="built_in">this</span>.hashFunc(key, <span class="built_in">this</span>.limit);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.根据index获取对应的bucket</span></span><br><span class="line">      <span class="keyword">let</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.判断bucket是否为null</span></span><br><span class="line">      <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.有bucket,那么就进行线性查找并删除</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tuple = bucket[i];</span><br><span class="line">        <span class="keyword">if</span> (tuple[<span class="number">0</span>] == key) &#123;</span><br><span class="line">          bucket.splice(i,<span class="number">1</span>);</span><br><span class="line">          <span class="built_in">this</span>.count -= <span class="number">1</span> ;</span><br><span class="line">          <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">          <span class="comment">//6.缩小容量</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">this</span>.limit &gt; <span class="number">7</span> &amp;&amp; <span class="built_in">this</span>.count &lt; <span class="built_in">this</span>.limit * <span class="number">0.25</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> newSize = <span class="built_in">Math</span>.floor(<span class="built_in">this</span>.limit / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">let</span> newPrime = <span class="built_in">this</span>.getPrime(newSize);</span><br><span class="line">            <span class="built_in">this</span>.resize(newPrime);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//5.依然没有找到，返回null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*------------------其他方法--------------------*/</span></span><br><span class="line">  <span class="comment">//判断哈希表是否为null</span></span><br><span class="line">  HashTable.prototype.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取哈希表中元素的个数</span></span><br><span class="line">  HashTable.prototype.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//哈希表扩容</span></span><br><span class="line">  HashTable.prototype.resize = <span class="function"><span class="keyword">function</span>(<span class="params">newLimit</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1.保存旧的storage数组内容</span></span><br><span class="line">    <span class="keyword">let</span> oldStorage = <span class="built_in">this</span>.storage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.重置所有的属性</span></span><br><span class="line">    <span class="built_in">this</span>.storage = [];</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.limit = newLimit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.遍历oldStorage中所有的bucket</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; oldStorage.length; i++) &#123;</span><br><span class="line">      <span class="comment">//3.1.取出对应的bucket</span></span><br><span class="line">      <span class="keyword">const</span> bucket = oldStorage[i];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.2.判断bucket是否为null</span></span><br><span class="line">      <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;      </span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.3.bucket中有数据，就取出数据重新插入</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">        <span class="keyword">const</span> tuple = bucket[j];</span><br><span class="line">        <span class="built_in">this</span>.put(tuple[<span class="number">0</span>], tuple[<span class="number">1</span>]);<span class="comment">//插入数据的key和value</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断传入的num是否质数</span></span><br><span class="line">  HashTable.prototype.isPrime = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//1.获取num的平方根:Math.sqrt(num)</span></span><br><span class="line">      <span class="comment">//2.循环判断</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">2</span>; i&lt;= <span class="built_in">Math</span>.sqrt(num); i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>(num % i == <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取质数的方法</span></span><br><span class="line">    HashTable.prototype.getPrime = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">       <span class="comment">//7*2=14,+1=15,+1=16,+1=17(质数)</span></span><br><span class="line">      <span class="keyword">while</span> (!<span class="built_in">this</span>.isPrime(num)) &#123;</span><br><span class="line">        num++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*使用class实现*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.storage = []; <span class="comment">// 哈希表存储数据的变量</span></span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>; <span class="comment">// 当前存放的元素个数</span></span><br><span class="line">    <span class="built_in">this</span>.limit = <span class="number">7</span>;  <span class="comment">// 哈希表长度（初始设为质数 7）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装填因子(已有个数/总个数)</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = <span class="number">0.75</span>;</span><br><span class="line">    <span class="built_in">this</span>.minLoadFactor = <span class="number">0.25</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getPrime(number) 根据传入的 number 获取最临近的质数</span></span><br><span class="line">  <span class="function"><span class="title">getPrime</span>(<span class="params">number</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!isPrime(number)) &#123;</span><br><span class="line">      number++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// put(key, value) 往哈希表里添加数据</span></span><br><span class="line">  <span class="function"><span class="title">put</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、根据 key 获取要映射到 storage 里面的 index（通过哈希函数获取）</span></span><br><span class="line">    <span class="keyword">const</span> index = hashFn(key, <span class="built_in">this</span>.limit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、根据 index 取出对应的 bucket</span></span><br><span class="line">    <span class="keyword">let</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、判断是否存在 bucket</span></span><br><span class="line">    <span class="keyword">if</span> (bucket === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      bucket = [];  <span class="comment">// 不存在则创建</span></span><br><span class="line">      <span class="built_in">this</span>.storage[index] = bucket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、判断是插入数据操作还是修改数据操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> tuple = bucket[i]; <span class="comment">// tuple 的格式：[key, value]</span></span><br><span class="line">      <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123; <span class="comment">// 如果 key 相等，则修改数据</span></span><br><span class="line">        tuple[<span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 修改完 tuple 里数据，return 终止，不再往下执行。</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、bucket 新增数据</span></span><br><span class="line">    bucket.push([key, value]); <span class="comment">// bucket 存储元组 tuple，格式为 [key, value]</span></span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断哈希表是否要扩容，若装填因子 &gt; 0.75，则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.count / <span class="built_in">this</span>.limit &gt; <span class="built_in">this</span>.loadFactor) &#123;</span><br><span class="line">      <span class="built_in">this</span>.resize(<span class="built_in">this</span>.getPrime(<span class="built_in">this</span>.limit * <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 get(key) 获取 value</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> index = hashFn(key, <span class="built_in">this</span>.limit);</span><br><span class="line">    <span class="keyword">const</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bucket === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> tuple <span class="keyword">of</span> bucket) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">        <span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove(key) 删除指定 key 的数据</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> index = hashFn(key, <span class="built_in">this</span>.limit);</span><br><span class="line">    <span class="keyword">const</span> bucket = <span class="built_in">this</span>.storage[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bucket === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 bucket，找到对应位置的 tuple，将其删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = bucket.length; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> tuple = bucket[i];</span><br><span class="line">      <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">        bucket.splice(i, <span class="number">1</span>); <span class="comment">// 删除对应位置的数组项</span></span><br><span class="line">        <span class="built_in">this</span>.count--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据装填因子的大小，判断是否要进行哈希表压缩</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.limit &gt; <span class="number">7</span> &amp;&amp; <span class="built_in">this</span>.count / <span class="built_in">this</span>.limit &lt; <span class="built_in">this</span>.minLoadFactor) &#123;</span><br><span class="line">          <span class="built_in">this</span>.resize(<span class="built_in">this</span>.getPrime(<span class="built_in">Math</span>.floor(<span class="built_in">this</span>.limit / <span class="number">2</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tuple;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重新调整哈希表大小，扩容或压缩</span></span><br><span class="line">  <span class="function"><span class="title">resize</span>(<span class="params">newLimit</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、保存旧的 storage 数组内容</span></span><br><span class="line">    <span class="keyword">const</span> oldStorage = <span class="built_in">this</span>.storage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、重置所有属性</span></span><br><span class="line">    <span class="built_in">this</span>.storage = [];</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.limit = newLimit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、遍历 oldStorage，取出所有数据，重新 put 到 this.storage</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> bucket <span class="keyword">of</span> oldStorage) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bucket) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bucket) &#123;</span><br><span class="line">          <span class="built_in">this</span>.put(b[<span class="number">0</span>], b[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><hr>

<h3 id="树结构简介"><a href="#树结构简介" class="headerlink" title="树结构简介"></a>树结构简介</h3><p><strong>什么是树？</strong></p>
<p>真实的树：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/1.png"></p>
<p><strong>树的特点：</strong></p>
<ul>
<li>树一般都有一个<strong>根</strong>，连接着根的是<strong>树干</strong>；</li>
<li>树干会发生分叉，形成许多<strong>树枝</strong>，树枝会继续分化成更小的<strong>树枝</strong>；</li>
<li>树枝的最后是<strong>叶子</strong>；</li>
</ul>
<p>现实生活中很多结构都是树的抽象，模拟的树结构相当于旋转<code>180°</code>的树。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/2.png"></p>
<p><strong>树结构对比于数组/链表/哈希表有哪些优势呢：</strong></p>
<p><em>数组：</em></p>
<ul>
<li>优点：可以通过<strong>下标值访问</strong>，效率高；</li>
<li>缺点：查找数据时需要先对数据进行<strong>排序</strong>，生成<strong>有序数组</strong>，才能提高查找效率；并且在插入和删除元素时，需要大量的<strong>位移操作</strong>；</li>
</ul>
<p><em>链表：</em></p>
<ul>
<li>优点：数据的插入和删除操作效率都很高；</li>
<li>缺点：<strong>查找</strong>效率低，需要从头开始依次查找，直到找到目标数据为止；当需要在链表中间位置插入或删除数据时，插入或删除的效率都不高。</li>
</ul>
<p><em>哈希表：</em></p>
<ul>
<li>优点：哈希表的插入/查询/删除效率都非常高；</li>
<li>缺点：<strong>空间利用率不高</strong>，底层使用的数组中很多单元没有被利用；并且哈希表中的元素是<strong>无序</strong>的，不能按照固定顺序遍历哈希表中的元素；而且不能快速找出哈希表中<strong>最大值或最小值</strong>这些特殊值。</li>
</ul>
<p><em>树结构：</em></p>
<p>优点：树结构综合了上述三种结构的优点，同时也弥补了它们存在的缺点（虽然效率不一定都比它们高），比如树结构中数据都是有序的，查找效率高；空间利用率高；并且可以快速获取最大值和最小值等。</p>
<p>总的来说：<strong>每种数据结构都有自己特定的应用场景</strong>。</p>
<h3 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h3><ul>
<li><strong>树（Tree）</strong>:由 n（n ≥ 0）个节点构成的<strong>有限集合</strong>。当 n = 0 时，称为<strong>空树</strong>。</li>
</ul>
<p>对于任一棵非空树（n &gt; 0），它具备以下性质：</p>
<ul>
<li>数中有一个称为<strong>根（Root）</strong>的特殊节点，用 **r **表示；</li>
<li>其余节点可分为 m（m &gt; 0）个互不相交的有限集合 T1，T2，…，Tm，其中每个集合本身又是一棵树，称为原来树的<strong>子树（SubTree）</strong>。</li>
</ul>
<h4 id="树的常用术语"><a href="#树的常用术语" class="headerlink" title="树的常用术语"></a>树的常用术语</h4><p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/3.png"></p>
<ul>
<li><strong>节点的度（Degree）</strong>：节点的<strong>子树个数</strong>，比如节点B的度为2；</li>
<li><strong>树的度</strong>：树的所有节点中<strong>最大的度数</strong>，如上图树的度为2；</li>
<li><strong>叶节点（Leaf）</strong>：<strong>度为0的节点</strong>（也称为叶子节点），如上图的H，I等；</li>
<li><strong>父节点（Parent）</strong>：度不为0的节点称为父节点，如上图节点B是节点D和E的父节点；</li>
<li><strong>子节点（Child）</strong>：若B是D的父节点，那么D就是B的子节点；</li>
<li><strong>兄弟节点（Sibling）</strong>：具有同一父节点的各节点彼此是兄弟节点，比如上图的B和C，D和E互为兄弟节点；</li>
<li><strong>路径和路径长度</strong>：路径指的是一个节点到另一节点的通道，路径所包含边的个数称为路径长度，比如A-&gt;H的路径长度为3；</li>
<li><strong>节点的层次（Level）</strong>：规定<strong>根节点在1层</strong>，其他任一节点的层数是其父节点的<strong>层数加1</strong>。如B和C节点的层次为2；</li>
<li><strong>树的深度（Depth）</strong>：树种所有节点中的<strong>最大层次</strong>是这棵树的深度，如上图树的深度为4；</li>
</ul>
<h4 id="树结构的表示"><a href="#树结构的表示" class="headerlink" title="树结构的表示"></a>树结构的表示</h4><ul>
<li><strong>最普通的表示方法</strong>：</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/4.png"></p>
<p>如图，树结构的组成方式类似于链表，都是由一个个节点连接构成。不过，根据每个父节点子节点数量的不同，每一个父节点需要的引用数量也不同。比如节点A需要3个引用，分别指向子节点B，C，D；B节点需要2个引用，分别指向子节点E和F；K节点由于没有子节点，所以不需要引用。</p>
<p>这种方法缺点在于我们无法确定某一结点的引用数。</p>
<ul>
<li><strong>儿子-兄弟表示法</strong>：</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/5.png"></p>
<p>这种表示方法可以完整地记录每个节点的数据，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//节点A</span></span><br><span class="line">Node&#123;</span><br><span class="line">  <span class="comment">//存储数据</span></span><br><span class="line">  <span class="built_in">this</span>.data = data;</span><br><span class="line">  <span class="comment">//统一只记录左边的子节点</span></span><br><span class="line">  <span class="built_in">this</span>.leftChild = B;</span><br><span class="line">  <span class="comment">//统一只记录右边的第一个兄弟节点</span></span><br><span class="line">  <span class="built_in">this</span>.rightSibling = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点B</span></span><br><span class="line">Node&#123;</span><br><span class="line">  <span class="built_in">this</span>.data = data;</span><br><span class="line">  <span class="built_in">this</span>.leftChild = E;</span><br><span class="line">  <span class="built_in">this</span>.rightSibling = C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点F</span></span><br><span class="line">Node&#123;</span><br><span class="line">  <span class="built_in">this</span>.data = data;</span><br><span class="line">  <span class="built_in">this</span>.leftChild = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.rightSibling = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种表示法的优点在于每一个节点中引用的数量都是确定的。</p>
<ul>
<li><strong>儿子-兄弟表示法旋转</strong></li>
</ul>
<p>将儿子-兄弟表示法组成的树结构顺时针旋转45°之后：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/7.png"></p>
<p>这样就成为了一棵<strong>二叉树</strong>，由此我们可以得出结论：<strong>任何树都可以通过二叉树进行模拟</strong>。但是这样父节点不是变了吗？其实，父节点的设置只是为了方便指向子节点，在代码实现中谁是父节点并没有关系，只要能正确找到对应节点即可。</p>
<blockquote>
<p>因为任何树都可以通过二叉树进行模拟，所以我们这里不再讨论一般的树，而是直接学习二叉树。</p>
</blockquote>
<br>

<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><hr>

<h3 id="二叉树简介"><a href="#二叉树简介" class="headerlink" title="二叉树简介"></a>二叉树简介</h3><p><strong>二叉树的概念</strong>：如果树中的每一个节点最多只能有<strong>两个子节点</strong>（左子节点和右子节点），这样的树就称为<strong>二叉树</strong>。</p>
<p>二叉树十分重要，不仅仅是因为简单，更是因为几乎所有的树都可以表示成二叉树形式。</p>
<p><strong>二叉树的组成</strong>：</p>
<ul>
<li>二叉树可以为空，也就是没有节点；</li>
<li>若二叉树不为空，则它由根节点和称为其左子树TL和右子树TR的两个不相交的二叉树组成。</li>
</ul>
<p><strong>二叉树的五种形态</strong>：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/8.png"></p>
<p>上图分别表示：空的二叉树、只有一个节点的二叉树、只有左子树TL的二叉树、只有右子树TR的二叉树和有左右两个子树的二叉树。</p>
<p><strong>二叉树的特性</strong>：</p>
<ul>
<li><p>一个二叉树的第 i 层的最大节点树为：2<sup>(i-1)</sup>，i &gt;= 1；</p>
</li>
<li><p>深度为k的二叉树的最大节点总数为：2<sup>k </sup>- 1 ，k &gt;= 1；</p>
</li>
<li><p>对任何非空二叉树，若 n<sub>0</sub> 表示叶子节点的个数，n<sub>2</sub>表示度为2的非叶子节点个数，那么两者满足关系：n<sub>0</sub>  = n<sub>2</sub>+ 1。</p>
<p>如下图所示：H，E，I，J，G为叶子节点，总数为5；A，B，C，F为度为2的非叶子节点，总数为4；满足n<sub>0</sub>  = n<sub>2</sub> + 1的规律。</p>
</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/9.png"></p>
<h3 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h3><p><strong>完美二叉树</strong></p>
<p>完美二叉树（Perfect Binary Tree）也成为满二叉树（Full Binary Tree），在二叉树中，除了最下一层的叶子节点外，每层节点都有2个子节点，这就构成了完美二叉树。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/10.png"></p>
<p><strong>完全二叉树</strong></p>
<p>完全二叉树（Complete Binary Tree）:</p>
<ul>
<li>除了二叉树最后一层外，其他各层的节点数都达到了最大值；</li>
<li>并且，最后一层的叶子节点从左向右是连续存在，只缺失右侧若干叶子节点；</li>
<li>完美二叉树是特殊的完全二叉树。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/11.png"></p>
<h3 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h3><p>常见的二叉树存储方式为<strong>数组</strong>和<strong>链表</strong>：</p>
<p><strong>使用数组：</strong></p>
<ul>
<li><strong>完全二叉树</strong>：按从上到下，从左到右的方式存储数据。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/12.png"></p>
<table>
<thead>
<tr>
<th>节点</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
<th>H</th>
</tr>
</thead>
<tbody><tr>
<td><strong>序号</strong></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>4</strong></td>
<td><strong>5</strong></td>
<td><strong>6</strong></td>
<td><strong>7</strong></td>
<td><strong>8</strong></td>
</tr>
</tbody></table>
<p>使用数组存储时，取数据的时候也十分方便：左子节点的序号等于父节点序号 * 2，右子节点的序号等于父节点序号 * 2 + 1 。</p>
<ul>
<li><strong>非完全二叉树</strong>：非完全二叉树需要转换成完全二叉树才能按照上面的方案存储，这样会浪费很大的存储空间。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/13.png"></p>
<table>
<thead>
<tr>
<th>节点</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>^</th>
<th>^</th>
<th>F</th>
<th>^</th>
<th>^</th>
<th>^</th>
<th>^</th>
<th>^</th>
<th>^</th>
<th>M</th>
</tr>
</thead>
<tbody><tr>
<td><strong>序号</strong></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>4</strong></td>
<td><strong>5</strong></td>
<td><strong>6</strong></td>
<td><strong>7</strong></td>
<td><strong>8</strong></td>
<td><strong>9</strong></td>
<td><strong>10</strong></td>
<td><strong>11</strong></td>
<td><strong>12</strong></td>
<td><strong>13</strong></td>
</tr>
</tbody></table>
<p><strong>使用链表</strong></p>
<p>二叉树最常见的存储方式为<strong>链表</strong>：每一个节点封装成一个Node，Node中包含存储的数据、左节点的引用和右节点的引用。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/14.png"></p>
<br>

<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><hr>

<h3 id="认识二叉搜索树"><a href="#认识二叉搜索树" class="headerlink" title="认识二叉搜索树"></a>认识二叉搜索树</h3><p><strong>二叉搜索树</strong>（<strong>BST</strong>，Binary Search Tree），也称为<strong>二叉排序树</strong>和<strong>二叉查找树</strong>。</p>
<p>二叉搜索树是一棵二叉树，可以为空；</p>
<p>如果不为空，则满足以下<strong>性质</strong>：</p>
<ul>
<li>条件1：非空左子树的<strong>所有</strong>键值<strong>小于</strong>其根节点的键值。比如三中节点6的所有非空左子树的键值都小于6；</li>
<li>条件2：非空右子树的<strong>所有</strong>键值<strong>大于</strong>其根节点的键值；比如三中节点6的所有非空右子树的键值都大于6；</li>
<li>条件3：左、右子树本身也都是二叉搜索树（即左右子树也包含上述性质）。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/15.png"></p>
<p>如上图所示，树二和树三符合3个条件属于二叉树，树一不满足条件3所以不是二叉树。</p>
<p><strong>总结：</strong>二叉搜索树的特点主要是<strong>较小的值</strong>总是保存在<strong>左节点</strong>上，相对<strong>较大的值</strong>总是保存在<strong>右节点</strong>上。这种特点使得二叉搜索树的查询效率非常高，这也就是二叉搜索树中”搜索”的来源。</p>
<h3 id="二叉搜索树应用举例"><a href="#二叉搜索树应用举例" class="headerlink" title="二叉搜索树应用举例"></a>二叉搜索树应用举例</h3><p>下面是一个二叉搜索树：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/16.png"></p>
<p>若想在其中查找数据10，只需要查找4次，查找效率非常高。</p>
<ul>
<li>第1次：将10与根节点9进行比较，由于10 &gt; 9，所以10下一步与根节点9的右子节点13比较；</li>
<li>第2次：由于10 &lt; 13，所以10下一步与父节点13的左子节点11比较；</li>
<li>第3次：由于10 &lt; 11，所以10下一步与父节点11的左子节点10比较；</li>
<li>第4次：由于10 = 10，最终查找到数据10 。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/17.png"></p>
<p>同样是15个数据，在排序好的数组中查询数据10，需要查询10次：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/18.png"></p>
<p>其实：如果是排序好的数组，可以通过二分查找：第一次找9，第二次找13，第三次找15…。我们发现如果把每次二分的数据拿出来以树的形式表示的话就是<strong>二叉搜索树</strong>。这就是数组二分法查找效率之所以高的原因。</p>
<h3 id="二叉搜索树的封装"><a href="#二叉搜索树的封装" class="headerlink" title="二叉搜索树的封装"></a>二叉搜索树的封装</h3><h4 id="二叉树搜索树的基本属性"><a href="#二叉树搜索树的基本属性" class="headerlink" title="二叉树搜索树的基本属性"></a>二叉树搜索树的基本属性</h4><p>如图所示：二叉搜索树有四个最基本的属性：指向节点的<strong>根</strong>（root），节点中的<strong>键</strong>（key）、<strong>左指针</strong>（right）、<strong>右指针</strong>（right）。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/1.png"></p>
<p>所以，二叉搜索树中除了定义root属性外，还应定义一个节点内部类，里面包含每个节点中的left、right和key三个属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//封装二叉搜索树</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">BinarySearchTree</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.key = key;</span><br><span class="line">      <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">      <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉搜索树的常见操作"><a href="#二叉搜索树的常见操作" class="headerlink" title="二叉搜索树的常见操作"></a>二叉搜索树的常见操作</h4><ul>
<li><code>insert(key)</code>：向树中插入一个新的键；</li>
<li><code>search(key)</code>：在树中查找一个键，如果节点存在，则返回true；如果不存在，则返回false；</li>
<li><code>inOrderTraverse</code>：通过中序遍历方式遍历所有节点；</li>
<li><code>preOrderTraverse</code>：通过先序遍历方式遍历所有节点；</li>
<li><code>postOrderTraverse</code>：通过后序遍历方式遍历所有节点；</li>
<li><code>min</code>：返回树中最小的值/键；</li>
<li><code>max</code>：返回树中最大的值/键；</li>
<li><code>remove(key)</code>：从树中移除某个键；</li>
</ul>
<h4 id="二叉搜索树方法实现"><a href="#二叉搜索树方法实现" class="headerlink" title="二叉搜索树方法实现"></a>二叉搜索树方法实现</h4><h5 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1. 插入数据"></a>1. 插入数据</h5><p><strong>实现思路：</strong></p>
<ul>
<li>首先根据传入的key创建节点对象；</li>
<li>然后判断根节点是否存在，不存在时通过：<code>this.root = newNode</code>，直接把新节点作为二叉搜索树的根节点。</li>
<li>若存在根节点则重新定义一个内部方法insertNode()用于查找插入点。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insert方法:对外向用户暴露的方法</span></span><br><span class="line"> BinarySearchTree.prototype.insert = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//1.根据key创建节点</span></span><br><span class="line">   <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(key);</span><br><span class="line">     </span><br><span class="line">   <span class="comment">//2.判断根节点是否存在</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="built_in">this</span>.root = newNode;</span><br><span class="line">     <span class="comment">//根节点存在时</span></span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.insertNode(<span class="built_in">this</span>.root, newNode);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>内部方法insertNode()的实现思路</strong>:</p>
<p>根据比较传入的两个节点，一直查找新节点适合插入的位置，直到成功插入新节点为止。</p>
<p>当newNode.key &lt; node.key向左查找:</p>
<ul>
<li>情况1：当node无左子节点时，直接插入：</li>
<li>情况2：当node有左子节点时，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/2.png"></p>
<p>当newNode.key &gt;= node.key向右查找，与向左查找类似：</p>
<ul>
<li>情况1：当node无右子节点时，直接插入：</li>
<li>情况2：当node有右子节点时，依然递归调用insertNode(),直到遇到传入insertNode方法的node无右子节点成功插入newNode为止：</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/3.png"></p>
<p><strong>insertNode()代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内部使用的insertNode方法:用于比较节点从左边插入还是右边插入</span></span><br><span class="line">BinarySearchTree.prototype.insertNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, newNode</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//当newNode.key &lt; node.key向左查找</span></span><br><span class="line">  <span class="keyword">if</span>(newNode.key &lt; node.key)&#123;</span><br><span class="line">    <span class="comment">//情况1：node无左子节点，直接插入</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">      node.left = newNode;</span><br><span class="line">    <span class="comment">//情况2：node有左子节点，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.insertNode(node.left, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">  <span class="comment">//当newNode.key &gt;= node.key向右查找</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//情况1：node无右子节点，直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">      node.right == newNode;</span><br><span class="line">    <span class="comment">//情况2：node有右子节点，依然递归调用insertNode(),直到遇到无右子节点成功插入newNode为止</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.insertNode(node.right, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//测试代码</span></span><br><span class="line">   <span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line">   <span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.插入数据</span></span><br><span class="line">   bst.insert(<span class="number">11</span>);</span><br><span class="line">   bst.insert(<span class="number">7</span>);</span><br><span class="line">   bst.insert(<span class="number">15</span>);</span><br><span class="line">   bst.insert(<span class="number">5</span>);</span><br><span class="line">   bst.insert(<span class="number">9</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bst);</span><br></pre></td></tr></table></figure>
<p>应得到下图所示的二叉搜索树：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/5.png"></p>
<p><strong>测试结果</strong>:</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/6.png"></p>
<br>

<h5 id="2-数据遍历"><a href="#2-数据遍历" class="headerlink" title="2. 数据遍历"></a>2. 数据遍历</h5><p>这里所说的树的遍历不仅仅针对二叉搜索树，而是适用于所有的二叉树。由于树结构不是线性结构，所以遍历方式有多种选择，常见的三种二叉树遍历方式为：</p>
<ul>
<li>先序遍历；</li>
<li>中序遍历；</li>
<li>后序遍历。</li>
</ul>
<p>还有层序遍历，使用较少。</p>
<h6 id="2-1-先序遍历"><a href="#2-1-先序遍历" class="headerlink" title="2.1.先序遍历"></a>2.1.先序遍历</h6><p>先序遍历的过程为：</p>
<ul>
<li>首先，遍历根节点；</li>
<li>然后，遍历其左子树；</li>
<li>最后，遍历其右子树。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/7.png"></p>
<p>如上图所示，二叉树的节点遍历顺序为：A -&gt; B -&gt; D -&gt; H -&gt; I -&gt; E -&gt; C -&gt; F -&gt; G。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line">   <span class="comment">//掺入一个handler函数方便之后对得到的key进行处理</span></span><br><span class="line">   BinarySearchTree.prototype.preOrderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">handler</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">this</span>.preOrderTraversalNode(<span class="built_in">this</span>.root, handler);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//封装内部方法，对某个节点进行遍历</span></span><br><span class="line">   BinarySearchTree.prototype.preOrderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node,handler</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="comment">//1.处理经过的节点</span></span><br><span class="line">       handler(node.key);</span><br><span class="line">       <span class="comment">/*-------递归1---------*/</span></span><br><span class="line">       <span class="comment">//2.遍历左子树中的节点</span></span><br><span class="line">       <span class="built_in">this</span>.preOrderTraversalNode(node.left, handler);</span><br><span class="line">       <span class="comment">/*--------递归2-------*/</span></span><br><span class="line">       <span class="comment">//3.遍历右子树中的节点</span></span><br><span class="line">       <span class="built_in">this</span>.preOrderTraversalNode(node.right, handler);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>过程详解：</strong></p>
<p>以遍历以下二叉搜索树为例：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/8.png"></p>
<p>首先调用preOrderTraversal方法，在方法里再调用preOrderTraversalNode方法用于遍历二叉搜索树。在preOrderTraversalNode方法中，递归1负责遍历左子节点，递归2负责遍历右子节点。先执行递归1，执行过程如下图所示：</p>
<blockquote>
<p><strong>记：preOrderTraversalNode() 为 A()</strong></p>
</blockquote>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/9.png"></p>
<p>可以看到一共递归调用了4次方法A，分别传入11、7、5、3，最后遇到null不满足 node != null 条件结束递归1；注意此时只是执行完最开始的递归1，并没有执行递归2，并且递归1执行到null停止后要一层层地往上返回，按顺序将调用的函数压出函数调用栈。</p>
<p>关于函数调用栈：之前的四次递归共把4个函数压入了函数调用栈，现在递归执行完了一层层地把函数压出栈。</p>
<p>值得注意的是：每一层函数都只是执行完了递归1，当返回到该层函数时，比如A（3）要继续执行递归2遍历二叉搜索树中的右子节点；</p>
<p>在执行递归2的过程中会不断调用方法A，并依次执行递归1和递归2，以此类推直到遇到null不满足 node != null 条件为止，才停止递归并一层层返回，如此循环。同理A（5）层、A（7）层、A（11）层都要经历上述循环，直到将二叉搜索树中的节点全部遍历完为止。</p>
<p>具体过程如下图所示：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/10.png"></p>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line"><span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">bst.insert(<span class="number">11</span>);</span><br><span class="line">bst.insert(<span class="number">7</span>);</span><br><span class="line">bst.insert(<span class="number">15</span>);</span><br><span class="line">bst.insert(<span class="number">5</span>);</span><br><span class="line">bst.insert(<span class="number">3</span>);</span><br><span class="line">bst.insert(<span class="number">9</span>);</span><br><span class="line">bst.insert(<span class="number">8</span>);</span><br><span class="line">bst.insert(<span class="number">10</span>);</span><br><span class="line">bst.insert(<span class="number">13</span>);</span><br><span class="line">bst.insert(<span class="number">12</span>);</span><br><span class="line">bst.insert(<span class="number">14</span>);</span><br><span class="line">bst.insert(<span class="number">20</span>);</span><br><span class="line">bst.insert(<span class="number">18</span>);</span><br><span class="line">bst.insert(<span class="number">25</span>);</span><br><span class="line">bst.insert(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试遍历</span></span><br><span class="line"><span class="keyword">let</span> resultString = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">//掺入处理节点值的处理函数</span></span><br><span class="line">bst.preOrderTraversal(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">  resultString += key + <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">&#125;)</span><br><span class="line">alert(resultString);</span><br></pre></td></tr></table></figure>
<p>应输出这样的顺序：11 -&gt; 7 -&gt; 5 -&gt; 3 -&gt; 6 -&gt; 9 -&gt; 8 -&gt; 10 -&gt; 15 -&gt; 13 -&gt;12 -&gt; 14 -&gt; 20 -&gt; 18 -&gt; 25 。</p>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/11.png"></p>
<br>

<h6 id="2-2-中序遍历"><a href="#2-2-中序遍历" class="headerlink" title="2.2.中序遍历"></a>2.2.中序遍历</h6><p>实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。</p>
<ul>
<li>首先，遍历其左子树；</li>
<li>然后，遍历根（父）节点；</li>
<li>最后，遍历其右子树。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line">BinarySearchTree.prototype.midOrderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">handler</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.midOrderTraversalNode(<span class="built_in">this</span>.root, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinarySearchTree.prototype.midOrderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, handler</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//1.遍历左子树中的节点</span></span><br><span class="line">    <span class="built_in">this</span>.midOrderTraversalNode(node.left, handler);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.处理节点</span></span><br><span class="line">    handler(node.key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.遍历右子树中的节点</span></span><br><span class="line">    <span class="built_in">this</span>.midOrderTraversalNode(node.right, handler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>过程详解：</strong></p>
<p>遍历的顺序应如下图所示：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/12.png"></p>
<blockquote>
<p>原作者这里画的有点错误，看到了吗？</p>
</blockquote>
<p>首先调用midOrderTraversal方法，在方法里再调用midOrderTraversalNode方法用于遍历二叉搜索树。先使用递归1遍历左子树中的节点；然后，处理父节点；最后，遍历右子树中的节点。</p>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">  <span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line">  <span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.插入数据</span></span><br><span class="line">  bst.insert(<span class="number">11</span>);</span><br><span class="line">  bst.insert(<span class="number">7</span>);</span><br><span class="line">  bst.insert(<span class="number">15</span>);</span><br><span class="line">  bst.insert(<span class="number">5</span>);</span><br><span class="line">  bst.insert(<span class="number">3</span>);</span><br><span class="line">  bst.insert(<span class="number">9</span>);</span><br><span class="line">  bst.insert(<span class="number">8</span>);</span><br><span class="line">  bst.insert(<span class="number">10</span>);</span><br><span class="line">  bst.insert(<span class="number">13</span>);</span><br><span class="line">  bst.insert(<span class="number">12</span>);</span><br><span class="line">  bst.insert(<span class="number">14</span>);</span><br><span class="line">  bst.insert(<span class="number">20</span>);</span><br><span class="line">  bst.insert(<span class="number">18</span>);</span><br><span class="line">  bst.insert(<span class="number">25</span>);</span><br><span class="line">  bst.insert(<span class="number">6</span>);	</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//3.测试中序遍历</span></span><br><span class="line">  <span class="keyword">let</span> resultString2 =<span class="string">&quot;&quot;</span>;</span><br><span class="line">  bst.midOrderTraversal(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    resultString2 += key + <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  alert(resultString2);</span><br></pre></td></tr></table></figure>
<p>输出节点的顺序应为：3 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 11 -&gt; 12 -&gt; 13 -&gt; 14 -&gt; 15 -&gt; 18 -&gt; 20 -&gt; 25 。</p>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/13.png"></p>
<br>

<h6 id="2-3-后序遍历"><a href="#2-3-后序遍历" class="headerlink" title="2.3.后序遍历"></a>2.3.后序遍历</h6><p>实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。</p>
<ul>
<li>首先，遍历其左子树；</li>
<li>然后，遍历其右子树；</li>
<li>最后，遍历根（父）节点；</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line">BinarySearchTree.prototype.postOrderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">handler</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.postOrderTraversalNode(<span class="built_in">this</span>.root, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinarySearchTree.prototype.postOrderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, handler</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//1.遍历左子树中的节点</span></span><br><span class="line">    <span class="built_in">this</span>.postOrderTraversalNode(node.left, handler);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.遍历右子树中的节点</span></span><br><span class="line">    <span class="built_in">this</span>.postOrderTraversalNode(node.right, handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.处理节点</span></span><br><span class="line">    handler(node.key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>过程详解：</strong></p>
<p>遍历的顺序应如下图所示：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/14.png"></p>
<p>首先调用postOrderTraversal方法，在方法里再调用postOrderTraversalNode方法用于遍历二叉搜索树。先使用递归1遍历左子树中的节点；然后，遍历右子树中的节点；最后，处理父节点。</p>
<p><strong>测试代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line"><span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">bst.insert(<span class="number">11</span>);</span><br><span class="line">bst.insert(<span class="number">7</span>);</span><br><span class="line">bst.insert(<span class="number">15</span>);</span><br><span class="line">bst.insert(<span class="number">5</span>);</span><br><span class="line">bst.insert(<span class="number">3</span>);</span><br><span class="line">bst.insert(<span class="number">9</span>);</span><br><span class="line">bst.insert(<span class="number">8</span>);</span><br><span class="line">bst.insert(<span class="number">10</span>);</span><br><span class="line">bst.insert(<span class="number">13</span>);</span><br><span class="line">bst.insert(<span class="number">12</span>);</span><br><span class="line">bst.insert(<span class="number">14</span>);</span><br><span class="line">bst.insert(<span class="number">20</span>);</span><br><span class="line">bst.insert(<span class="number">18</span>);</span><br><span class="line">bst.insert(<span class="number">25</span>);</span><br><span class="line">bst.insert(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试后序遍历</span></span><br><span class="line"><span class="keyword">let</span> resultString3 =<span class="string">&quot;&quot;</span>;</span><br><span class="line">bst.postOrderTraversal(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">  resultString3 += key + <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">&#125;)</span><br><span class="line">alert(resultString3);</span><br></pre></td></tr></table></figure>
<p>输出节点的顺序应为：3 -&gt; 6 -&gt; 5 -&gt; 8 -&gt; 10 -&gt; 9 -&gt; 7 -&gt; 12 -&gt; 14 -&gt; 13 -&gt; 18 -&gt; 25 -&gt; 20 -&gt; 15 -&gt; 11 。</p>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/15.png"></p>
<p><strong>总结：</strong>以遍历根（父）节点的顺序来区分三种遍历方式。比如：先序遍历先遍历根节点、中序遍历第二遍历根节点、后续遍历最后遍历根节点。</p>
<br>

<h5 id="3-查找数据"><a href="#3-查找数据" class="headerlink" title="3. 查找数据"></a>3. 查找数据</h5><h6 id="3-1-查找最大值-amp-最小值"><a href="#3-1-查找最大值-amp-最小值" class="headerlink" title="3.1.查找最大值&amp;最小值"></a>3.1.查找最大值&amp;最小值</h6><p>在二叉搜索树中查找最值非常简单，最小值在二叉搜索树的最左边，最大值在二叉搜索树的最右边。只需要一直向左/右查找就能得到最值，如下图所示：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/16.png"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//寻找最大值</span></span><br><span class="line">BinarySearchTree.prototype.max = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//1.获取根节点</span></span><br><span class="line">  <span class="keyword">let</span> node = <span class="built_in">this</span>.root;</span><br><span class="line">  <span class="comment">//2.定义key保存节点值</span></span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//3.依次向右不断查找，直到节点为null</span></span><br><span class="line">  <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">    key = node.key;</span><br><span class="line">    node = node.right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找最小值</span></span><br><span class="line">BinarySearchTree.prototype.min = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//1.获取根节点</span></span><br><span class="line">   <span class="keyword">let</span> node = <span class="built_in">this</span>.root;</span><br><span class="line">  <span class="comment">//2.定义key保存节点值</span></span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//3.依次向左不断查找，直到节点为null</span></span><br><span class="line">  <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">    key = node.key;</span><br><span class="line">    node = node.left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"> <span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line"> <span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//2.插入数据</span></span><br><span class="line"> bst.insert(<span class="number">11</span>);</span><br><span class="line"> bst.insert(<span class="number">7</span>);</span><br><span class="line"> bst.insert(<span class="number">15</span>);</span><br><span class="line"> bst.insert(<span class="number">5</span>);</span><br><span class="line"> bst.insert(<span class="number">3</span>);</span><br><span class="line"> bst.insert(<span class="number">9</span>);</span><br><span class="line"> bst.insert(<span class="number">8</span>);</span><br><span class="line"> bst.insert(<span class="number">10</span>);</span><br><span class="line"> bst.insert(<span class="number">13</span>);</span><br><span class="line"> bst.insert(<span class="number">12</span>);</span><br><span class="line"> bst.insert(<span class="number">14</span>);</span><br><span class="line"> bst.insert(<span class="number">20</span>);</span><br><span class="line"> bst.insert(<span class="number">18</span>);</span><br><span class="line"> bst.insert(<span class="number">25</span>);</span><br><span class="line"> bst.insert(<span class="number">6</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//4.测试最值</span></span><br><span class="line"> <span class="built_in">console</span>.log(bst.max());</span><br><span class="line"> <span class="built_in">console</span>.log(bst.min());</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/17.png"></p>
<br>

<h6 id="3-2-查找特定值"><a href="#3-2-查找特定值" class="headerlink" title="3.2.查找特定值"></a>3.2.查找特定值</h6><p>查找二叉搜索树当中的特定值效率也非常高。只需要从根节点开始将需要查找节点的key值与之比较，若<strong>node.key &lt; root**则向左查找，若**node.key &gt; root</strong>就向右查找，直到找到或查找到null为止。这里可以使用递归实现，也可以采用循环来实现。</p>
<p><strong>实现代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找特定的key</span></span><br><span class="line"> BinarySearchTree.prototype.search = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//1.获取根节点</span></span><br><span class="line">   <span class="keyword">let</span> node = <span class="built_in">this</span>.root;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.循环搜索key</span></span><br><span class="line">   <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">     <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">       <span class="comment">//小于根(父)节点就往左边找</span></span><br><span class="line">       node = node.left;</span><br><span class="line">       <span class="comment">//大于根(父)节点就往右边找</span></span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; node.key)&#123;</span><br><span class="line">       node = node.right;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line"><span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">bst.insert(<span class="number">11</span>);</span><br><span class="line">bst.insert(<span class="number">7</span>);</span><br><span class="line">bst.insert(<span class="number">15</span>);</span><br><span class="line">bst.insert(<span class="number">5</span>);</span><br><span class="line">bst.insert(<span class="number">3</span>);</span><br><span class="line">bst.insert(<span class="number">9</span>);</span><br><span class="line">bst.insert(<span class="number">8</span>);</span><br><span class="line">bst.insert(<span class="number">10</span>);</span><br><span class="line">bst.insert(<span class="number">13</span>);</span><br><span class="line">bst.insert(<span class="number">12</span>);</span><br><span class="line">bst.insert(<span class="number">14</span>);</span><br><span class="line">bst.insert(<span class="number">20</span>);</span><br><span class="line">bst.insert(<span class="number">18</span>);</span><br><span class="line">bst.insert(<span class="number">25</span>);</span><br><span class="line">bst.insert(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试搜索方法</span></span><br><span class="line"><span class="built_in">console</span>.log(bst.search(<span class="number">24</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(bst.search(<span class="number">13</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(bst.search(<span class="number">2</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/18.png"></p>
<br>

<h5 id="4-删除数据"><a href="#4-删除数据" class="headerlink" title="4. 删除数据"></a>4. 删除数据</h5><p><strong>实现思路：</strong></p>
<p><strong>第一步：</strong>先找到需要删除的节点，若没找到，则不需要删除；</p>
<p>首先定义变量current用于保存需要删除的节点、变量parent用于保存它的父节点、变量isLeftChild保存current是否为parent的左节点，这样方便之后删除节点时改变相关节点的指向。</p>
<p><strong>实现代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.1.定义变量</span></span><br><span class="line">     <span class="keyword">let</span> current = <span class="built_in">this</span>.root;</span><br><span class="line">     <span class="keyword">let</span> parent = <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">let</span> isLeftChild = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//1.2.开始寻找删除的节点</span></span><br><span class="line">     <span class="keyword">while</span> (current.key != key) &#123;</span><br><span class="line">       parent = current;</span><br><span class="line">       <span class="comment">// 小于则往左查找</span></span><br><span class="line">       <span class="keyword">if</span> (key &lt; current.key) &#123;</span><br><span class="line">         isLeftChild = <span class="literal">true</span>;</span><br><span class="line">         current = current.left;</span><br><span class="line">       &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="comment">//大于则往右查找</span></span><br><span class="line">         isLeftChild = <span class="literal">false</span>;</span><br><span class="line">         current = current.rigth;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//找到最后依然没有找到相等的节点</span></span><br><span class="line">       <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//结束while循环后：current.key = key</span></span><br></pre></td></tr></table></figure>
<p><strong>第二步：</strong>删除找到的指定节点，后分3种情况：</p>
<ul>
<li>删除叶子节点；</li>
<li>删除只有一个子节点的节点；</li>
<li>删除有两个子节点的节点。</li>
</ul>
<h6 id="4-1-情况1：没有子节点"><a href="#4-1-情况1：没有子节点" class="headerlink" title="4.1.情况1：没有子节点"></a>4.1.情况1：没有子节点</h6><p>没有子节点时也有两种情况：</p>
<p>当该叶子节点为根节点时，如下图所示，此时<strong>current == this.root</strong>，直接通过：<strong>this.root = null</strong>，删除根节点。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/19.png"></p>
<p>当该叶子节点不为根节点时也有两种情况，如下图所示：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/20.png"></p>
<p>若current = 8，可以通过：parent.left = null，删除节点8；</p>
<p>若current = 10，可以通过：parent.right = null，删除节点10。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况1：删除的是叶子节点(没有子节点)</span></span><br><span class="line"><span class="keyword">if</span> (current.left == <span class="literal">null</span> &amp;&amp; current.right ==<span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild)&#123;</span><br><span class="line">    parent.left = <span class="literal">null</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    parent.right =<span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-2-情况2：有一个子节点"><a href="#4-2-情况2：有一个子节点" class="headerlink" title="4.2.情况2：有一个子节点"></a>4.2.情况2：有一个子节点</h6><p>有六种情况分别是：</p>
<p>当current存在左子节点时（current.right == null）：</p>
<ul>
<li>情况1：current为根节点（current == this.root），如节点11，此时通过：this.root = current.left，删除根节点11；</li>
<li>情况2：current为父节点parent的左子节点（isLeftChild == true），如节点5，此时通过：parent.left = current.left，删除节点5；</li>
<li>情况3：current为父节点parent的右子节点（isLeftChild == false），如节点9，此时通过：parent.right = current.left，删除节点9；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/21.png"></p>
<p>当current存在右子节点时（current.left = null）：</p>
<ul>
<li>情况4：current为根节点（current == this.root），如节点11，此时通过：this.root = current.right，删除根节点11。</li>
<li>情况5：current为父节点parent的左子节点（isLeftChild == true），如节点5，此时通过：parent.left = current.right，删除节点5；</li>
<li>情况6：current为父节点parent的右子节点（isLeftChild == false），如节点9，此时通过：parent.right = current.right，删除节点9；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/22.png"></p>
<p><strong>实现代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//情况2：删除的节点有一个子节点</span></span><br><span class="line">  <span class="comment">//当current存在左子节点时</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(current.right == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = current.left;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">          parent.left = current.left;</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">          parent.right = current.left;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">//当current存在右子节点时</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(current.left == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = current.right;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">          parent.left = current.right;</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">          parent.right = current.right;</span><br><span class="line">      &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-3-情况3：有两个子节点"><a href="#4-3-情况3：有两个子节点" class="headerlink" title="4.3.情况3：有两个子节点"></a>4.3.情况3：有两个子节点</h6><p>这种情况<strong>十分复杂</strong>，首先依据以下二叉搜索树，讨论这样的问题：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/23.png"></p>
<p><strong>删除节点9</strong></p>
<p>在保证删除节点9后原二叉树仍为二叉搜索树的前提下，有两种方式：</p>
<ul>
<li>方式1：从节点9的左子树中选择一合适的节点替代节点9，可知节点8符合要求；</li>
<li>方式2：从节点9的右子树中选择一合适的节点替代节点9，可知节点10符合要求；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/24.png"></p>
<p><strong>删除节点7</strong></p>
<p>在保证删除节点7后原二叉树仍为二叉搜索树的前提下，也有两种方式：</p>
<ul>
<li>方式1：从节点7的左子树中选择一合适的节点替代节点7，可知节点5符合要求；</li>
<li>方式2：从节点7的右子树中选择一合适的节点替代节点7，可知节点8符合要求；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/25.png"></p>
<p><strong>删除节点15</strong></p>
<p>在保证删除节点15后原树二叉树仍为二叉搜索树的前提下，同样有两种方式：</p>
<ul>
<li>方式1：从节点15的左子树中选择一合适的节点替代节点15，可知节点14符合要求；</li>
<li>方式2：从节点15的右子树中选择一合适的节点替代节点15，可知节点18符合要求；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/26.png"></p>
<p>相信你已经发现其中的规律了！</p>
<p><strong>规律总结：</strong>如果要删除的节点有两个子节点，甚至子节点还有子节点，这种情况下需要从要删除节点<strong>下面的子节点中找到一个合适的节点</strong>，来替换当前的节点。</p>
<p>若用current表示需要删除的节点，则合适的节点指的是：</p>
<ul>
<li>current左子树中比current<strong>小一点点的节点</strong>，即current<strong>左子树</strong>中的<strong>最大值</strong>；</li>
<li>current右子树中比current<strong>大一点点的节点</strong>，即current<strong>右子树</strong>中的<strong>最小值</strong>。</li>
</ul>
<p><strong>前驱&amp;后继</strong></p>
<p>在二叉搜索树中，这两个特殊的节点有特殊的名字：</p>
<ul>
<li>比current小一点点的节点，称为current节点的<strong>前驱</strong>。比如下图中的节点5就是节点7的前驱；</li>
<li>比current大一点点的节点，称为current节点的<strong>后继</strong>。比如下图中的节点8就是节点7的后继；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/27.png"></p>
<p><strong>代码实现：</strong></p>
<ul>
<li>查找需要被删除的节点current的后继时，需要在current的<strong>右子树</strong>中查找<strong>最小值</strong>，即在current的<strong>右子树</strong>中一直<strong>向左遍历</strong>查找；</li>
<li>查找前驱时，则需要在current的<strong>左子树</strong>中查找<strong>最大值</strong>，即在current的<strong>左子树</strong>中一直<strong>向右</strong>遍历查找。</li>
</ul>
<p>下面只讨论查找current后继的情况，查找前驱的原理相同，这里暂不讨论。</p>
<h6 id="4-4-完整实现"><a href="#4-4-完整实现" class="headerlink" title="4.4.完整实现"></a>4.4.完整实现</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">      <span class="comment">//删除节点</span></span><br><span class="line">      BinarySearchTree.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line"><span class="comment">/*------------------------------1.寻找要删除的节点---------------------------------*/</span></span><br><span class="line">        <span class="comment">//1.1.定义变量current保存删除的节点，parent保存它的父节点。isLeftChild保存current是否为parent的左节点</span></span><br><span class="line">        <span class="keyword">let</span> current = <span class="built_in">this</span>.root;</span><br><span class="line">        <span class="keyword">let</span> parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> isLeftChild = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.2.开始寻找删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> (current.key != key) &#123;</span><br><span class="line">          parent = current;</span><br><span class="line">          <span class="comment">// 小于则往左查找</span></span><br><span class="line">          <span class="keyword">if</span> (key &lt; current.key) &#123;</span><br><span class="line">            isLeftChild = <span class="literal">true</span>;</span><br><span class="line">            current = current.left;</span><br><span class="line">          &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            isLeftChild = <span class="literal">false</span>;</span><br><span class="line">            current = current.right;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//找到最后依然没有找到相等的节点</span></span><br><span class="line">          <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束while循环后：current.key = key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------2.根据对应情况删除节点------------------------------*/</span></span><br><span class="line">        <span class="comment">//情况1：删除的是叶子节点(没有子节点)</span></span><br><span class="line">        <span class="keyword">if</span> (current.left == <span class="literal">null</span> &amp;&amp; current.right ==<span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild)&#123;</span><br><span class="line">            parent.left = <span class="literal">null</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right =<span class="literal">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//情况2：删除的节点有一个子节点</span></span><br><span class="line">        <span class="comment">//当current存在左子节点时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(current.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">              <span class="built_in">this</span>.root = current.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">                parent.left = current.left;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                parent.right = current.left;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//当current存在右子节点时</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(current.left == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">              <span class="built_in">this</span>.root = current.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">                parent.left = current.right;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                parent.right = current.right</span><br><span class="line">            &#125; </span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">//情况3：删除的节点有两个子节点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//1.获取后继节点</span></span><br><span class="line">          <span class="keyword">let</span> successor = <span class="built_in">this</span>.getSuccessor(current);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//2.判断是否根节点</span></span><br><span class="line">          <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root = successor;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild)&#123;</span><br><span class="line">            parent.left = successor;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.right = successor;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//3.将后继的左子节点改为被删除节点的左子节点</span></span><br><span class="line">          successor.left = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//封装查找后继的方法</span></span><br><span class="line">      BinarySearchTree.prototype.getSuccessor = <span class="function"><span class="keyword">function</span>(<span class="params">delNode</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//1.定义变量,保存找到的后继</span></span><br><span class="line">        <span class="keyword">let</span> successor = delNode;</span><br><span class="line">        <span class="keyword">let</span> current = delNode.right;</span><br><span class="line">        <span class="keyword">let</span> successorParent = delNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.循环查找current的右子树节点</span></span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">          successorParent = successor</span><br><span class="line">          successor = current;</span><br><span class="line">          current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.判断寻找到的后继节点是否直接就是删除节点的right节点</span></span><br><span class="line">        <span class="keyword">if</span>(successor != delNode.right)&#123;</span><br><span class="line">          successorParent.left = successor.right;</span><br><span class="line">          successor.right = delNode.right ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"> <span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line"> <span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//2.插入数据</span></span><br><span class="line"> bst.insert(<span class="number">11</span>);</span><br><span class="line"> bst.insert(<span class="number">7</span>);</span><br><span class="line"> bst.insert(<span class="number">15</span>);</span><br><span class="line"> bst.insert(<span class="number">5</span>);</span><br><span class="line"> bst.insert(<span class="number">3</span>);</span><br><span class="line"> bst.insert(<span class="number">9</span>);</span><br><span class="line"> bst.insert(<span class="number">8</span>);</span><br><span class="line"> bst.insert(<span class="number">10</span>);</span><br><span class="line"> bst.insert(<span class="number">13</span>);</span><br><span class="line"> bst.insert(<span class="number">12</span>);</span><br><span class="line"> bst.insert(<span class="number">14</span>);</span><br><span class="line"> bst.insert(<span class="number">20</span>);</span><br><span class="line"> bst.insert(<span class="number">18</span>);</span><br><span class="line"> bst.insert(<span class="number">25</span>);</span><br><span class="line"> bst.insert(<span class="number">6</span>);</span><br><span class="line"> bst.insert(<span class="number">19</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//3.测试删除代码</span></span><br><span class="line"> <span class="comment">//删除没有子节点的节点</span></span><br><span class="line"> bst.remove(<span class="number">3</span>);</span><br><span class="line"> bst.remove(<span class="number">8</span>);</span><br><span class="line"> bst.remove(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//删除有一个子节点的节点</span></span><br><span class="line"> bst.remove(<span class="number">5</span>);</span><br><span class="line"> bst.remove(<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//删除有两个子节点的节点</span></span><br><span class="line"> bst.remove(<span class="number">9</span>);</span><br><span class="line"> bst.remove(<span class="number">7</span>);</span><br><span class="line"> bst.remove(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//遍历二叉搜索树并输出</span></span><br><span class="line"> <span class="keyword">let</span> resultString = <span class="string">&quot;&quot;</span>;</span><br><span class="line"> bst.midOrderTraversal(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">   resultString += key + <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line"> &#125;)</span><br><span class="line"> alert(resultString);</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/28.png"></p>
<p>可见三种情况的节点都被成功删除了。</p>
<h5 id="完整封装"><a href="#完整封装" class="headerlink" title="完整封装"></a>完整封装</h5><h6 id="1）-使用function实现"><a href="#1）-使用function实现" class="headerlink" title="1） 使用function实现"></a>1） 使用function实现</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*使用function实现*/</span>    </span><br><span class="line"><span class="comment">//封装二叉搜索树</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">BinarySearchTree</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//节点内部类</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key</span><br><span class="line">        <span class="built_in">this</span>.left = <span class="literal">null</span></span><br><span class="line">        <span class="built_in">this</span>.right = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//属性</span></span><br><span class="line">      <span class="built_in">this</span>.root = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//方法</span></span><br><span class="line">      <span class="comment">//一.插入数据：insert方法:对外向用户暴露的方法</span></span><br><span class="line">      BinarySearchTree.prototype.insert = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//1.根据key创建节点</span></span><br><span class="line">        <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(key)</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//2.判断根节点是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="built_in">this</span>.root = newNode</span><br><span class="line">          <span class="comment">//根节点存在时</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.insertNode(<span class="built_in">this</span>.root, newNode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//内部使用的insertNode方法:用于比较节点从左边插入还是右边插入</span></span><br><span class="line">      BinarySearchTree.prototype.insertNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, newNode</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//当newNode.key &lt; node.key向左查找</span></span><br><span class="line">        <span class="keyword">if</span>(newNode.key &lt; node.key)&#123;</span><br><span class="line">          <span class="comment">//情况1：node无左子节点，直接插入</span></span><br><span class="line">          <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.left = newNode</span><br><span class="line">          <span class="comment">//情况2：node有左子节点，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。</span></span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.insertNode(node.left, newNode)</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">//当newNode.key &gt;= node.key向右查找</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//情况1：node无右子节点，直接插入</span></span><br><span class="line">          <span class="keyword">if</span>(node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            node.right = newNode</span><br><span class="line">          <span class="comment">//情况2：node有右子节点，依然递归调用insertNode(),直到遇到无右子节点成功插入newNode为止</span></span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.insertNode(node.right, newNode)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//二.树的遍历</span></span><br><span class="line">      <span class="comment">//1.先序遍历</span></span><br><span class="line">      <span class="comment">//掺入一个handler函数对得到的key进行处理</span></span><br><span class="line">      BinarySearchTree.prototype.preOrderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">handler</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.preOrderTraversalNode(<span class="built_in">this</span>.root, handler)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//封装内部方法，对某个节点进行遍历</span></span><br><span class="line">      BinarySearchTree.prototype.preOrderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//1.处理经过的节点</span></span><br><span class="line">          handler(node.key)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//2.遍历经过节点的左子节点</span></span><br><span class="line">          <span class="built_in">this</span>.preOrderTraversalNode(node.left, handler)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//3.遍历经过节点的右子节点</span></span><br><span class="line">          <span class="built_in">this</span>.preOrderTraversalNode(node.right, handler)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.中序遍历</span></span><br><span class="line">      BinarySearchTree.prototype.midOrderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">handler</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.midOrderTraversalNode(<span class="built_in">this</span>.root, handler)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      BinarySearchTree.prototype.midOrderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//1.遍历左子树中的节点</span></span><br><span class="line">          <span class="built_in">this</span>.midOrderTraversalNode(node.left, handler)</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//2.处理节点</span></span><br><span class="line">          handler(node.key)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//3.遍历右子树中的节点</span></span><br><span class="line">          <span class="built_in">this</span>.midOrderTraversalNode(node.right, handler)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.后序遍历</span></span><br><span class="line">      BinarySearchTree.prototype.postOrderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">handler</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.postOrderTraversalNode(<span class="built_in">this</span>.root, handler)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      BinarySearchTree.prototype.postOrderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//1.遍历左子树中的节点</span></span><br><span class="line">          <span class="built_in">this</span>.postOrderTraversalNode(node.left, handler)</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//2.遍历右子树中的节点</span></span><br><span class="line">          <span class="built_in">this</span>.postOrderTraversalNode(node.right, handler)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//3.处理节点</span></span><br><span class="line">          handler(node.key)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//三.寻找最值</span></span><br><span class="line">      <span class="comment">//寻找最大值</span></span><br><span class="line">      BinarySearchTree.prototype.max = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取根节点</span></span><br><span class="line">        <span class="keyword">let</span> node = <span class="built_in">this</span>.root</span><br><span class="line">        <span class="comment">//2.定义key保存节点值</span></span><br><span class="line">        <span class="keyword">let</span> key = <span class="literal">null</span></span><br><span class="line">        <span class="comment">//3.依次向右不断查找，直到节点为null</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          key = node.key</span><br><span class="line">          node = node.right</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> key</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//寻找最小值</span></span><br><span class="line">      BinarySearchTree.prototype.min = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="comment">//1.获取根节点</span></span><br><span class="line">         <span class="keyword">let</span> node = <span class="built_in">this</span>.root</span><br><span class="line">        <span class="comment">//2.定义key保存节点值</span></span><br><span class="line">        <span class="keyword">let</span> key = <span class="literal">null</span></span><br><span class="line">        <span class="comment">//3.依次向左不断查找，直到节点为null</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          key = node.key</span><br><span class="line">          node = node.left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> key</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//查找特定的key</span></span><br><span class="line">      BinarySearchTree.prototype.search = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//1.获取根节点</span></span><br><span class="line">        <span class="keyword">let</span> node = <span class="built_in">this</span>.root</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.循环搜索key</span></span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">            <span class="comment">//小于根(父)节点就往左边找</span></span><br><span class="line">            node = node.left</span><br><span class="line">            <span class="comment">//大于根(父)节点就往右边找</span></span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; node.key)&#123;</span><br><span class="line">            node = node.right</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//四.删除节点</span></span><br><span class="line">      BinarySearchTree.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line"><span class="comment">/*------------------------------1.寻找要删除的节点---------------------------------*/</span></span><br><span class="line">        <span class="comment">//1.1.定义变量current保存删除的节点，parent保存它的父节点。isLeftChild保存current是否为parent的左节点</span></span><br><span class="line">        <span class="keyword">let</span> current = <span class="built_in">this</span>.root</span><br><span class="line">        <span class="keyword">let</span> parent = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">let</span> isLeftChild = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.2.开始寻找删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> (current.key != key) &#123;</span><br><span class="line">          parent = current</span><br><span class="line">          <span class="comment">// 小于则往左查找</span></span><br><span class="line">          <span class="keyword">if</span> (key &lt; current.key) &#123;</span><br><span class="line">            isLeftChild = <span class="literal">true</span></span><br><span class="line">            current = current.left</span><br><span class="line">          &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            isLeftChild = <span class="literal">false</span></span><br><span class="line">            current = current.right</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//找到最后依然没有找到相等的节点</span></span><br><span class="line">          <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束while循环后：current.key = key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------2.根据对应情况删除节点------------------------------*/</span></span><br><span class="line">        <span class="comment">//情况1：删除的是叶子节点(没有子节点)</span></span><br><span class="line">        <span class="keyword">if</span> (current.left == <span class="literal">null</span> &amp;&amp; current.right ==<span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root = <span class="literal">null</span></span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild)&#123;</span><br><span class="line">            parent.left = <span class="literal">null</span></span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right =<span class="literal">null</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//情况2：删除的节点有一个子节点</span></span><br><span class="line">        <span class="comment">//当current存在左子节点时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(current.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">              <span class="built_in">this</span>.root = current.left</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">                parent.left = current.left</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                parent.right = current.left</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//当current存在右子节点时</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(current.left == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">              <span class="built_in">this</span>.root = current.right</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">                parent.left = current.right</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                parent.right = current.right</span><br><span class="line">            &#125; </span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">//情况3：删除的节点有两个子节点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//1.获取后继节点</span></span><br><span class="line">          <span class="keyword">let</span> successor = <span class="built_in">this</span>.getSuccessor(current)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//2.判断是否根节点</span></span><br><span class="line">          <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root = successor</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild)&#123;</span><br><span class="line">            parent.left = successor</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.right = successor</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//3.将后继的左子节点改为被删除节点的左子节点</span></span><br><span class="line">          successor.left = current.left</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//封装查找后继的方法</span></span><br><span class="line">      BinarySearchTree.prototype.getSuccessor = <span class="function"><span class="keyword">function</span>(<span class="params">delNode</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//1.定义变量,保存找到的后继</span></span><br><span class="line">        <span class="keyword">let</span> successor = delNode</span><br><span class="line">        <span class="keyword">let</span> current = delNode.right</span><br><span class="line">        <span class="keyword">let</span> successorParent = delNode</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.循环查找current的右子树节点</span></span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">          successorParent = successor</span><br><span class="line">          successor = current</span><br><span class="line">          current = current.left</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.判断寻找到的后继节点是否直接就是删除节点的right节点</span></span><br><span class="line">        <span class="keyword">if</span>(successor != delNode.right)&#123;</span><br><span class="line">          successorParent.left = successor.right</span><br><span class="line">          successor.right = delNode.right </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> successor</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="2）使用class实现"><a href="#2）使用class实现" class="headerlink" title="2）使用class实现"></a>2）使用class实现</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="function"><span class="title">remove</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.root;</span><br><span class="line">  <span class="keyword">let</span> parentNode = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> isLeftChild = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环查找到要删除的节点 currentNode，以及它的 parentNode、isLeftChild</span></span><br><span class="line">  <span class="keyword">while</span> (currentNode.key !== key) &#123;</span><br><span class="line"></span><br><span class="line">    parentNode = currentNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小于，往左查找</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; currentNode.key) &#123;</span><br><span class="line">      isLeftChild = <span class="literal">true</span>;</span><br><span class="line">      currentNode = currentNode.left;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 否则往右查找</span></span><br><span class="line">      isLeftChild = <span class="literal">false</span>;</span><br><span class="line">      currentNode = currentNode.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最后都没找到相等的节点，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1、删除的是叶子节点的情况</span></span><br><span class="line">  <span class="keyword">if</span> (currentNode.left === <span class="literal">null</span> &amp;&amp; currentNode.right === <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="built_in">this</span>.root) &#123;</span><br><span class="line">      <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">      parentNode.left = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parentNode.right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、删除的是只有一个子节点的节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentNode.right === <span class="literal">null</span>) &#123; <span class="comment">// currentNode 只存在左节点</span></span><br><span class="line">    <span class="comment">//-- 2.1、currentNode 只存在&lt;左节点&gt;的情况</span></span><br><span class="line">    <span class="comment">//---- 2.1.1、currentNode 等于 root</span></span><br><span class="line">    <span class="comment">//---- 2.1.2、parentNode.left 等于 currentNode</span></span><br><span class="line">    <span class="comment">//---- 2.1.3、parentNode.right 等于 currentNode</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="built_in">this</span>.root) &#123;</span><br><span class="line">      <span class="built_in">this</span>.root = currentNode.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">      parentNode.left = currentNode.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parentNode.right = currentNode.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentNode.left === <span class="literal">null</span>) &#123; <span class="comment">// currentNode 只存在右节点</span></span><br><span class="line">    <span class="comment">//-- 2.2、currentNode 只存在&lt;右节点&gt;的情况</span></span><br><span class="line">    <span class="comment">//---- 2.1.1 currentNode 等于 root</span></span><br><span class="line">    <span class="comment">//---- 2.1.1 parentNode.left 等于 currentNode</span></span><br><span class="line">    <span class="comment">//---- 2.1.1 parentNode.right 等于 currentNode</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="built_in">this</span>.root) &#123;</span><br><span class="line">      <span class="built_in">this</span>.root = currentNode.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">      parentNode.left = currentNode.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parentNode.right = currentNode.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、删除的是有两个子节点的节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、找到后续节点</span></span><br><span class="line">    <span class="keyword">let</span> successor = <span class="built_in">this</span>.getSuccessor(currentNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、判断是否为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode === <span class="built_in">this</span>.root) &#123;</span><br><span class="line">      <span class="built_in">this</span>.root = successor;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">      parentNode.left = successor;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parentNode.right = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、将后续的左节点改为被删除的左节点</span></span><br><span class="line">    successor.left = currentNode.left;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取后续节点，即从要删除的节点的右边开始查找最小的值</span></span><br><span class="line"><span class="function"><span class="title">getSuccessor</span>(<span class="params">delNode</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义变量，保存要找到的后续</span></span><br><span class="line">  <span class="keyword">let</span> successor = delNode;</span><br><span class="line">  <span class="keyword">let</span> current = delNode.right;</span><br><span class="line">  <span class="keyword">let</span> successorParent = delNode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环查找 current 的右子树节点</span></span><br><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    successorParent = successor;</span><br><span class="line">    successor = current;</span><br><span class="line">    current = current.left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断寻找到的后续节点是否直接就是要删除节点的 right</span></span><br><span class="line">  <span class="keyword">if</span> (successor !== delNode.right) &#123;</span><br><span class="line">    successorParent.left = successor.right;</span><br><span class="line">    successor.right = delNode.right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> successor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><p><strong>二叉搜索树的缺陷：</strong></p>
<p>当插入的数据是有序的数据，就会造成二叉搜索树的深度过大。比如原二叉搜索树右 11 7 15 组成，如下图所示：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/29.png"></p>
<p>当插入一组有序数据：6 5 4 3 2就会变成深度过大的搜索二叉树，会严重影响二叉搜索树的性能。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/30.png"></p>
<p><strong>非平衡树</strong></p>
<ul>
<li>比较好的二叉搜索树，它的数据应该是<strong>左右均匀分布</strong>的；</li>
<li>但是插入<strong>连续数据</strong>后，二叉搜索树中的数据分布就变得<strong>不均匀</strong>了，我们称这种树为<strong>非平衡树</strong>；</li>
<li>对于一棵<strong>平衡二叉树</strong>来说，插入/查找等操作的效率是<strong>O（logN）</strong>；</li>
<li>而对于一棵<strong>非平衡二叉树</strong>来说，相当于编写了一个链表，查找效率变成了<strong>O（N）</strong>;</li>
</ul>
<p><strong>树的平衡性</strong></p>
<p>为了能以<strong>较快的时间O（logN）</strong>来操作一棵树，我们需要<strong>保证树总是平衡</strong>的：</p>
<ul>
<li>起码大部分是平衡的，此时的时间复杂度也是接近O（logN）的；</li>
<li>这就要求树中<strong>每个节点左边的子孙节点</strong>的个数，应该尽可能地等于<strong>右边的子孙节点</strong>的个数；</li>
</ul>
<p><strong>常见的平衡树</strong></p>
<ul>
<li><strong>AVL树</strong>：是最早的一种平衡树，它通过在每个节点多存储一个额外的数据来保持树的平衡。由于AVL树是平衡树，所以它的时间复杂度也是O（logN）。但是它的整体效率不如红黑树，开发中比较少用。</li>
<li><strong>红黑树</strong>：同样通过<strong>一些特性</strong>来保持树的平衡，时间复杂度也是O（logN）。进行插入/删除等操作时，性能优于AVL树，所以平衡树的应用基本都是红黑树。</li>
</ul>
<blockquote>
<p>这里有一份平衡二叉树的JS实现代码的链接，原地址：<a href="https://blog.csdn.net/wang516038746/article/details/66565505">JS实现平衡二叉树</a>。</p>
</blockquote>
<br>

<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><hr>

<blockquote>
<p>这里只作较简单的说明和代码封装，感兴趣的请自行深入了解。</p>
</blockquote>
<h3 id="图的简介"><a href="#图的简介" class="headerlink" title="图的简介"></a>图的简介</h3><p><strong>什么是图？</strong></p>
<ul>
<li><strong>图结构</strong>是一种与<strong>树结构</strong>有些相似的数据结构；</li>
<li><strong>图论</strong>是数学的一个分支，并且，在数学中，树是图的一种；</li>
<li>图论以图为研究对象，研究<strong>顶点</strong>和<strong>边</strong>组成的<strong>图形</strong>的数学理论和方法；</li>
<li>主要的研究目的为：<strong>事物之间的联系</strong>，<strong>顶点</strong>代表<strong>事物</strong>，<strong>边</strong>代表两个事物间的<strong>关系</strong>；</li>
</ul>
<p><strong>图的特点：</strong></p>
<ul>
<li><strong>一组顶点</strong>：通常用 <strong>V</strong> （Vertex）表示顶点的集合；</li>
<li>一组边：通常用 E（Edge）表示边的集合；<ul>
<li>边是顶点和顶点之间的连线；</li>
<li>边可以是有向的，也可以是无向的。比如A—-B表示无向，A —&gt; B 表示有向；</li>
</ul>
</li>
</ul>
<p><strong>图的常用术语：</strong></p>
<ul>
<li><strong>顶点：</strong>表示图中的一个<strong>节点</strong>；</li>
<li><strong>边：</strong>表示<strong>顶点和顶点</strong>给之间的<strong>连线</strong>；</li>
<li><strong>相邻顶点：</strong>由一条边连接在一起的顶点称为<strong>相邻顶点</strong>；</li>
<li><strong>度：</strong>一个顶点的<strong>度</strong>是<strong>相邻顶点的数量</strong>；</li>
<li><strong>路径：</strong><ul>
<li><strong>简单路径：</strong>简单路径要求不包含重复的顶点；</li>
<li><strong>回路：</strong>第一个顶点和最后一个顶点<strong>相同</strong>的路径称为回路；</li>
</ul>
</li>
<li><strong>无向图：</strong>图中的所有边都是<strong>没有</strong>方向的；</li>
<li><strong>有向图：</strong>图中的所有边都是<strong>有</strong>方向的；</li>
<li><strong>无权图：</strong>无权图中的边没有任何权重意义；</li>
<li><strong>带权图：</strong>带权图中的边有一定的权重含义；</li>
</ul>
<h3 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>表示图的常用方式为：<strong>邻接矩阵</strong>。</p>
<ul>
<li>可以使用二维数组来表示邻接矩阵；</li>
<li>邻接矩阵让<strong>每个节点和一个整数相关联</strong>，该<strong>整数作为数组的下标值</strong>；</li>
<li>使用一个<strong>二维数组</strong>来表示顶点之间的<strong>连接</strong>。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/1.png"></p>
<p>如上图所示：</p>
<ul>
<li>二维数组中的<strong>0</strong>表示没有连线，<strong>1</strong>表示有连线；</li>
<li>如：A[ 0 ] [ 3 ] = 1，表示 A 和 C 之间有连接；</li>
<li>邻接矩阵的对角线上的值都为0，表示A - A ，B - B，等自回路都没有连接（自己与自己之间没有连接）；</li>
<li>若为无向图，则邻接矩阵应为对角线上元素全为0的对称矩阵；</li>
</ul>
<p><strong>邻接矩阵的问题：</strong></p>
<ul>
<li>如果图是一个<strong>稀疏图</strong>，那么邻接矩阵中将存在<strong>大量的 0</strong>，造成存储空间的浪费。</li>
</ul>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>另外一种表示图的常用方式为：<strong>邻接表</strong>。</p>
<ul>
<li>邻接表由图中<strong>每个顶点</strong>以及<strong>和顶点相邻的顶点列表</strong>组成；</li>
<li>这个列表可用多种方式存储，比如：<strong>数组/链表/字典（哈希表）</strong>等都可以；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/2.png"></p>
<p>如上图所示：</p>
<ul>
<li>图中可清楚看到<strong>A与B、C、D相邻</strong>，假如要表示这些与A顶点相邻的顶点（边），可以通过将它们作为A的值（value）存入到对应的<strong>数组/链表/字典</strong>中。</li>
<li>之后，通过键（key）A可以十分方便地取出对应的数据；</li>
</ul>
<p><strong>邻接表的问题：</strong></p>
<ul>
<li>邻接表可以简单地得出<strong>出度</strong>，即某一顶点指向其他顶点的个数；</li>
<li>但是，邻接表计算<strong>入度</strong>（指向某一顶点的其他顶点的个数称为该顶点的入度）十分困难。此时需要构造<strong>逆邻接表</strong>才能有效计算入度；</li>
</ul>
<br>

<h3 id="封装图结构"><a href="#封装图结构" class="headerlink" title="封装图结构"></a>封装图结构</h3><blockquote>
<p>在实现过程中采用<strong>邻接表</strong>的方式来表示边，使用<strong>字典类</strong>来存储邻接表。</p>
</blockquote>
<h4 id="添加字典类和队列类"><a href="#添加字典类和队列类" class="headerlink" title="添加字典类和队列类"></a>添加字典类和队列类</h4><p>首先需要引入之前实现的，之后会用到的字典类和队列类:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//封装字典类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dictionary</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//字典属性</span></span><br><span class="line">  <span class="built_in">this</span>.items = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//字典操作方法</span></span><br><span class="line">  <span class="comment">//一.在字典中添加键值对</span></span><br><span class="line">  Dictionary.prototype.set = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.items[key] = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//二.判断字典中是否有某个key</span></span><br><span class="line">  Dictionary.prototype.has = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.hasOwnProperty(key)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//三.从字典中移除元素</span></span><br><span class="line">  Dictionary.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1.判断字典中是否有这个key</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.has(key)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.从字典中删除key</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.items[key]</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//四.根据key获取value</span></span><br><span class="line">  Dictionary.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.has(key) ? <span class="built_in">this</span>.items[key] : <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//五.获取所有keys</span></span><br><span class="line">  Dictionary.prototype.keys = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//六.size方法</span></span><br><span class="line">  Dictionary.prototype.keys = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.keys().length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//七.clear方法</span></span><br><span class="line">  Dictionary.prototype.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 基于数组封装队列类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">      <span class="built_in">this</span>.items = []</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="comment">// 1.将元素加入到队列中</span></span><br><span class="line">    Queue.prototype.enqueue = <span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.从队列中删除前端元素</span></span><br><span class="line">    Queue.prototype.dequeue = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.items.shift()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.查看前端的元素</span></span><br><span class="line">    Queue.prototype.front = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.查看队列是否为空</span></span><br><span class="line">    Queue.prototype.isEmpty = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.items.length == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.查看队列中元素的个数</span></span><br><span class="line">    Queue.prototype.size = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.items.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.toString方法</span></span><br><span class="line">    Queue.prototype.toString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> resultString = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> <span class="built_in">this</span>.items)&#123;</span><br><span class="line">          resultString += i + <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultString</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="0-创建图类"><a href="#0-创建图类" class="headerlink" title="0. 创建图类"></a>0. 创建图类</h4><p>先创建图类Graph，并添加基本属性，再实现图类的常用方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装图类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//属性：顶点(数组)/边(字典)</span></span><br><span class="line">  <span class="built_in">this</span>.vertexes = [];  <span class="comment">//顶点</span></span><br><span class="line">  <span class="built_in">this</span>.edges = <span class="keyword">new</span> Dictionary(); <span class="comment">//边</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-添加顶点与边"><a href="#1-添加顶点与边" class="headerlink" title="1. 添加顶点与边"></a>1. 添加顶点与边</h4><p>如图所示：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/3.png"></p>
<p>创建一个数组对象vertexes存储图的顶点；创建一个字典对象edges存储图的边，其中key为顶点，value为存储key顶点相邻顶点的数组。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加方法</span></span><br><span class="line"><span class="comment">//一.添加顶点</span></span><br><span class="line">Graph.prototype.addVertex = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.vertexes.push(v);</span><br><span class="line">  <span class="built_in">this</span>.edges.set(v, []); <span class="comment">//将边添加到字典中，新增的顶点作为键，对应的值为一个存储边的空数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二.添加边</span></span><br><span class="line">Graph.prototype.addEdge = <span class="function"><span class="keyword">function</span>(<span class="params">v1, v2</span>)</span>&#123;<span class="comment">//传入两个顶点为它们添加边</span></span><br><span class="line">  <span class="built_in">this</span>.edges.get(v1).push(v2);<span class="comment">//取出字典对象edges中存储边的数组，并添加关联顶点</span></span><br><span class="line">  <span class="built_in">this</span>.edges.get(v2).push(v1);<span class="comment">//表示的是无向表，故要添加互相指向的两条边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-转换为字符串输出"><a href="#2-转换为字符串输出" class="headerlink" title="2. 转换为字符串输出"></a>2. 转换为字符串输出</h4><p>为图类Graph添加toString方法，实现以邻接表的形式输出图中各顶点。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三.实现toString方法:转换为邻接表形式</span></span><br><span class="line">Graph.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.定义字符串，保存最终结果</span></span><br><span class="line">  <span class="keyword">let</span> resultString = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.遍历所有的顶点以及顶点对应的边</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.vertexes.length; i++) &#123;</span><br><span class="line">      <span class="comment">//遍历所有顶点</span></span><br><span class="line">    resultString += <span class="built_in">this</span>.vertexes[i] + <span class="string">&#x27;--&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> vEdges = <span class="built_in">this</span>.edges.get(<span class="built_in">this</span>.vertexes[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; vEdges.length; j++) &#123;</span><br><span class="line">        <span class="comment">//遍历字典中每个顶点对应的数组</span></span><br><span class="line">      resultString += vEdges[j] + <span class="string">&#x27;  &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    resultString += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resultString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"> <span class="comment">//1.创建图结构</span></span><br><span class="line"> <span class="keyword">let</span> graph = <span class="keyword">new</span> Graph();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//2.添加顶点</span></span><br><span class="line"> <span class="keyword">let</span> myVertexes = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>];</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; myVertexes.length; i++) &#123;</span><br><span class="line">   graph.addVertex(myVertexes[i]);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//3.添加边</span></span><br><span class="line"> graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line"> graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line"> graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line"> graph.addEdge(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line"> graph.addEdge(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;G&#x27;</span>);</span><br><span class="line"> graph.addEdge(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>);</span><br><span class="line"> graph.addEdge(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line"> graph.addEdge(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;E&#x27;</span>);</span><br><span class="line"> graph.addEdge(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;F&#x27;</span>);</span><br><span class="line"> graph.addEdge(<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;I&#x27;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//4.输出结果</span></span><br><span class="line"> <span class="built_in">console</span>.log(graph.toString());</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/4.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/4.png" alt="image-20200303233737451"></a></p>
<br>

<h4 id="3-图的遍历"><a href="#3-图的遍历" class="headerlink" title="3. 图的遍历"></a>3. 图的遍历</h4><p><strong>图的遍历思想：</strong></p>
<ul>
<li>图的遍历思想与树的遍历思想一样，意味着需要将图中<strong>所有的顶点</strong>都访问一遍，并且不能有<strong>重复的访问</strong>（上面的toString方法会重复访问）；</li>
</ul>
<p><strong>遍历图的两种算法：</strong></p>
<ul>
<li>广度优先搜索（Breadth - First Search，简称<strong>BFS</strong>）;</li>
<li>深度优先搜索（Depth - First Search，简称<strong>DFS</strong>）;</li>
<li>两种遍历算法都需要指定<strong>第一个被访问的顶点</strong>；</li>
</ul>
<p>为了记录顶点是否被访问过，使用<strong>三种颜色</strong>来表示它们的状态</p>
<ul>
<li><strong>白色</strong>：表示该顶点还没有被访问过；</li>
<li><strong>灰色</strong>：表示该顶点被访问过，但其相邻顶点并未完全被访问过；</li>
<li><strong>黑色</strong>：表示该顶点被访问过，且其所有相邻顶点都被访问过；</li>
</ul>
<p>首先封装initializeColor方法将图中的所有顶点初始化为白色，代码实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//四.初始化状态颜色</span></span><br><span class="line">Graph.prototype.initializeColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> colors = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.vertexes.length; i++) &#123;</span><br><span class="line">     colors[<span class="built_in">this</span>.vertexes[i]] = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> colors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h5><p>广度优先搜索算法的思路：</p>
<ul>
<li>广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻顶点，就像一次访问图的一层；</li>
<li>也可以说是<strong>先宽后深</strong>地遍历图中的各个顶点；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/5.png"></p>
<p><strong>实现思路：</strong></p>
<p>基于<strong>队列</strong>可以简单地实现广度优先搜索算法：</p>
<ul>
<li>首先创建一个队列Q（尾部进，首部出）；</li>
<li>调用封装的initializeColor方法将所有顶点初始化为白色；</li>
<li>指定第一个顶点A，将A标注为<strong>灰色</strong>（被访问过的节点），并将A放入队列Q中；</li>
<li>循环遍历队列中的元素，只要队列Q非空，就执行以下操作：<ul>
<li>先将灰色的A从Q的首部取出；</li>
<li>取出A后，将A的所有未被访问过（白色）的相邻顶点依次从队列Q的尾部加入队列，并变为灰色。以此保证，灰色的相邻顶点不重复加入队列；</li>
<li>A的全部相邻节点加入Q后，A变为黑色，在下一次循环中被移除Q外。</li>
</ul>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//五.实现广度搜索(BFS)</span></span><br><span class="line"><span class="comment">//传入指定的第一个顶点和处理结果的函数</span></span><br><span class="line">Graph.prototype.bfs = <span class="function"><span class="keyword">function</span>(<span class="params">initV, handler</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.初始化颜色</span></span><br><span class="line">  <span class="keyword">let</span> colors = <span class="built_in">this</span>.initializeColor();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.创建队列</span></span><br><span class="line">  <span class="keyword">let</span> que = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.将顶点加入到队列中</span></span><br><span class="line">  que.enqueue(initV);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4.循环从队列中取出元素，队列为空才停止</span></span><br><span class="line">  <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">    <span class="comment">//4.1.从队列首部取出一个顶点</span></span><br><span class="line">    <span class="keyword">let</span> v = que.dequeue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2.从字典对象edges中获取和该顶点相邻的其他顶点组成的数组</span></span><br><span class="line">    <span class="keyword">let</span> vNeighbours = <span class="built_in">this</span>.edges.get(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3.将v的颜色变为灰色</span></span><br><span class="line">    colors[v] = <span class="string">&#x27;gray&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.4.遍历v所有相邻的顶点vNeighbours,并且加入队列中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vNeighbours.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> a = vNeighbours[i];</span><br><span class="line">      <span class="comment">//判断相邻顶点是否被探测过，被探测过则不加入队列中；并且加入队列后变为灰色，表示被探测过</span></span><br><span class="line">      <span class="keyword">if</span> (colors[a] == <span class="string">&#x27;white&#x27;</span>) &#123;</span><br><span class="line">        colors[a] = <span class="string">&#x27;gray&#x27;</span>;</span><br><span class="line">        que.enqueue(a);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.5.处理顶点v</span></span><br><span class="line">    handler(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.6.顶点v所有白色的相邻顶点都加入队列后，将顶点v设置为黑色。此时黑色顶点v位于队列最前面，进入下一次while循环时会被取出</span></span><br><span class="line">    colors[v] = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>过程详解：</strong></p>
<p>下为指定的第一个顶点为A时的遍历过程：</p>
<ul>
<li>如 a 图所示，将在字典edges中取出的与A相邻的且未被访问过的白色顶点B、C、D放入队列que中并变为灰色，随后将A变为黑色并移出队列；</li>
<li>接着，如图 b 所示，将在字典edges中取出的与B相邻的且未被访问过的白色顶点E、F放入队列que中并变为灰色，随后将B变为黑色并移出队列；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/6.png"></p>
<ul>
<li>如 c 图所示，将在字典edges中取出的与C相邻的且未被访问过的白色顶点G（A，D也相邻不过已变为灰色，所以不加入队列）放入队列que中并变为灰色，随后将C变为黑色并移出队列；</li>
<li>接着，如图 d 所示，将在字典edges中取出的与D相邻的且未被访问过的白色顶点H放入队列que中并变为灰色，随后将D变为黑色并移出队列。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/7.png"></p>
<p>如此循环直到队列中元素为0，即所有顶点都变黑并移出队列后才停止，此时图中顶点已被全部遍历。</p>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建图结构</span></span><br><span class="line"><span class="keyword">let</span> graph = <span class="keyword">new</span> Graph();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.添加顶点</span></span><br><span class="line"><span class="keyword">let</span> myVertexes = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; myVertexes.length; i++) &#123;</span><br><span class="line">  graph.addVertex(myVertexes[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.添加边</span></span><br><span class="line">graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;I&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.测试bfs遍历方法</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;&quot;</span></span><br><span class="line">graph.bfs(graph.vertexes[<span class="number">0</span>], <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  result += v + <span class="string">&quot;-&quot;</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/8.png"></p>
<br>

<h5 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h5><p>广度优先算法的思路：</p>
<ul>
<li>深度优先搜索算法将会从指定的第一个顶点开始遍历图，沿着一条路径遍历直到该路径的最后一个顶点都被访问过为止；</li>
<li>接着沿原来路径回退并探索下一条路径，即<strong>先深后宽</strong>地遍历图中的各个顶点。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/9.png"></p>
<p><strong>实现思路：</strong></p>
<ul>
<li>可以使用<strong>栈</strong>结构来实现深度优先搜索算法；</li>
<li>深度优先搜索算法的遍历顺序与二叉搜索树中的先序遍历较为相似，同样可以使用<strong>递归</strong>来实现（递归的本质就是<strong>函数栈</strong>的调用）。</li>
</ul>
<p>基于递归实现深度优先搜索算法：定义dfs方法用于调用递归方法dfsVisit，定义dfsVisit方法用于递归访问图中的各个顶点。</p>
<p>在dfs方法中：</p>
<ul>
<li>首先，调用initializeColor方法将所有顶点初始化为白色；</li>
<li>然后，调用dfsVisit方法遍历图的顶点；</li>
</ul>
<p>在dfsVisit方法中：</p>
<ul>
<li>首先，将传入的指定节点v标注为<strong>灰色</strong>；</li>
<li>接着，处理顶点v；</li>
<li>然后，访问v的相邻顶点；</li>
<li>最后，将顶点v标注为黑色。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//六.实现深度搜索(DFS)</span></span><br><span class="line">Graph.prototype.dfs = <span class="function"><span class="keyword">function</span>(<span class="params">initV, handler</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.初始化顶点颜色</span></span><br><span class="line">  <span class="keyword">let</span> colors = <span class="built_in">this</span>.initializeColor();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.从某个顶点开始依次递归访问</span></span><br><span class="line">  <span class="built_in">this</span>.dfsVisit(initV, colors, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了方便递归调用，封装访问顶点的函数，传入三个参数分别表示：指定的第一个顶点、颜色、处理函数</span></span><br><span class="line">Graph.prototype.dfsVisit = <span class="function"><span class="keyword">function</span>(<span class="params">v, colors, handler</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.将颜色设置为灰色</span></span><br><span class="line">  colors[v] = <span class="string">&#x27;gray&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.处理v顶点</span></span><br><span class="line">  handler(v);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.访问V的相邻顶点</span></span><br><span class="line">  <span class="keyword">let</span> vNeighbours = <span class="built_in">this</span>.edges.get(v);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vNeighbours.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = vNeighbours[i];</span><br><span class="line">    <span class="comment">//判断相邻顶点是否为白色，若为白色，递归调用函数继续访问</span></span><br><span class="line">    <span class="keyword">if</span> (colors[a] == <span class="string">&#x27;white&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.dfsVisit(a, colors, handler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4.将v设置为黑色</span></span><br><span class="line">  colors[v] = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>过程详解：</strong></p>
<p>这里主要解释一下代码中的第3步操作：访问指定顶点的相邻顶点。</p>
<ul>
<li>以指定顶点A为例，先从储存顶点及其对应相邻顶点的字典对象edges中取出由顶点A的相邻顶点组成的数组：</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/10.png"></p>
<ul>
<li><strong>第一步</strong>：A顶点变为灰色，随后进入第一个for循环，遍历A白色的相邻顶点：B、C、D；在该for循环的第1次循环中（执行B），B顶点满足：colors == “white”，触发递归，重新调用该方法；</li>
<li><strong>第二步</strong>：B顶点变为灰色，随后进入第二个for循环，遍历B白色的相邻顶点：E、F；在该for循环的第1次循环中（执行E），E顶点满足：colors == “white”，触发递归，重新调用该方法；</li>
<li><strong>第三步</strong>：E顶点变为灰色，随后进入第三个for循环，遍历E白色的相邻顶点：I；在该for循环的第1次循环中（执行I），I顶点满足：colors == “white”，触发递归，重新调用该方法；</li>
<li><strong>第四步</strong>：I顶点变为灰色，随后进入第四个for循环，由于顶点I的相邻顶点E不满足：colors == “white”，停止递归调用。过程如下图所示：</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/11.png"></p>
<ul>
<li><strong>第五步</strong>：递归结束后一路向上返回，首先回到第三个for循环中继续执行其中的第2、3…次循环，每次循环的执行过程与上面的同理，直到递归再次结束后，再返回到第二个for循环中继续执行其中的第2、3…次循环….以此类推直到将图的所有顶点访问完为止。</li>
</ul>
<p>下图为遍历图中各顶点的完整过程：</p>
<ul>
<li><strong>发现</strong>表示访问了该顶点，状态变为<strong>灰色</strong>；</li>
<li><strong>探索</strong>表示既访问了该顶点，也访问了该顶点的全部相邻顶点，状态变为<strong>黑色</strong>；</li>
<li>由于在顶点变为灰色后就调用了处理函数handler，所以handler方法的输出顺序为发现顶点的顺序即：A、B、E、I、F、C、D、G、H 。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/12.png"></p>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建图结构</span></span><br><span class="line"><span class="keyword">let</span> graph = <span class="keyword">new</span> Graph();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.添加顶点</span></span><br><span class="line"><span class="keyword">let</span> myVertexes = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; myVertexes.length; i++) &#123;</span><br><span class="line">  graph.addVertex(myVertexes[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.添加边</span></span><br><span class="line">graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;I&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.测试dfs遍历顶点</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">graph.dfs(graph.vertexes[<span class="number">0</span>], <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  result += v + <span class="string">&quot;-&quot;</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/13.png"></p>
<h4 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装图结构</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//属性：顶点(数组)/边(字典)</span></span><br><span class="line">  <span class="built_in">this</span>.vertexes = [];  <span class="comment">//顶点</span></span><br><span class="line">  <span class="built_in">this</span>.edges = <span class="keyword">new</span> Dictionary(); <span class="comment">//边</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法</span></span><br><span class="line">  <span class="comment">//添加方法</span></span><br><span class="line">  <span class="comment">//一.添加顶点</span></span><br><span class="line">  Graph.prototype.addVertex = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.vertexes.push(v);</span><br><span class="line">    <span class="built_in">this</span>.edges.set(v, []); <span class="comment">//将边添加到字典中，新增的顶点作为键，对应的值为一个存储边的空数组</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//二.添加边</span></span><br><span class="line">  Graph.prototype.addEdge = <span class="function"><span class="keyword">function</span>(<span class="params">v1, v2</span>)</span>&#123;<span class="comment">//传入两个顶点为它们添加边</span></span><br><span class="line">    <span class="built_in">this</span>.edges.get(v1).push(v2);<span class="comment">//取出字典对象edges中存储边的数组，并添加关联顶点</span></span><br><span class="line">    <span class="built_in">this</span>.edges.get(v2).push(v1);<span class="comment">//表示的是无向表，故要添加互相指向的两条边</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//三.实现toString方法:转换为邻接表形式</span></span><br><span class="line">  Graph.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1.定义字符串，保存最终结果</span></span><br><span class="line">    <span class="keyword">let</span> resultString = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.遍历所有的顶点以及顶点对应的边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.vertexes.length; i++) &#123;<span class="comment">//遍历所有顶点</span></span><br><span class="line">      resultString += <span class="built_in">this</span>.vertexes[i] + <span class="string">&#x27;--&gt;&#x27;</span>;</span><br><span class="line">      <span class="keyword">let</span> vEdges = <span class="built_in">this</span>.edges.get(<span class="built_in">this</span>.vertexes[i]);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; vEdges.length; j++) &#123;<span class="comment">//遍历字典中每个顶点对应的数组</span></span><br><span class="line">        resultString += vEdges[j] + <span class="string">&#x27;  &#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      resultString += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultString;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//四.初始化状态颜色</span></span><br><span class="line">  Graph.prototype.initializeColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> colors = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.vertexes.length; i++) &#123;</span><br><span class="line">       colors[<span class="built_in">this</span>.vertexes[i]] = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> colors;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//五.实现广度搜索(BFS)</span></span><br><span class="line">  <span class="comment">//传入指定的第一个顶点和处理结果的函数</span></span><br><span class="line">  Graph.prototype.bfs = <span class="function"><span class="keyword">function</span>(<span class="params">initV, handler</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1.初始化颜色</span></span><br><span class="line">    <span class="keyword">let</span> colors = <span class="built_in">this</span>.initializeColor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建队列</span></span><br><span class="line">    <span class="keyword">let</span> que = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.将顶点加入到队列中</span></span><br><span class="line">    que.enqueue(initV);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.循环从队列中取出元素</span></span><br><span class="line">    <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">      <span class="comment">//4.1.从队列中取出一个顶点</span></span><br><span class="line">      <span class="keyword">let</span> v = que.dequeue();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.2.获取和顶点相相邻的其他顶点</span></span><br><span class="line">      <span class="keyword">let</span> vNeighbours = <span class="built_in">this</span>.edges.get(v);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.3.将v的颜色变为灰色</span></span><br><span class="line">      colors[v] = <span class="string">&#x27;gray&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.4.遍历v所有相邻的顶点vNeighbours,并且加入队列中</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vNeighbours.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> a = vNeighbours[i];</span><br><span class="line">        <span class="comment">//判断相邻顶点是否被探测过，被探测过则不加入队列中；并且加入队列后变为灰色，表示被探测过</span></span><br><span class="line">        <span class="keyword">if</span> (colors[a] == <span class="string">&#x27;white&#x27;</span>) &#123;</span><br><span class="line">          colors[a] = <span class="string">&#x27;gray&#x27;</span>;</span><br><span class="line">          que.enqueue(a);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.5.处理顶点v</span></span><br><span class="line">      handler(v);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.6.顶点v所有白色的相邻顶点都加入队列后，将顶点v设置为黑色。此时黑色顶点v位于队列最前面，进入下一次while循环时会被取出</span></span><br><span class="line">      colors[v] = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//六.实现深度搜索(DFS)</span></span><br><span class="line">  Graph.prototype.dfs = <span class="function"><span class="keyword">function</span>(<span class="params">initV, handler</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1.初始化顶点颜色</span></span><br><span class="line">    <span class="keyword">let</span> colors = <span class="built_in">this</span>.initializeColor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.从某个顶点开始依次递归访问</span></span><br><span class="line">    <span class="built_in">this</span>.dfsVisit(initV, colors, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//为了方便递归调用，封装访问顶点的函数，传入三个参数分别表示：指定的第一个顶点、颜色、处理函数</span></span><br><span class="line">  Graph.prototype.dfsVisit = <span class="function"><span class="keyword">function</span>(<span class="params">v, colors, handler</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1.将颜色设置为灰色</span></span><br><span class="line">    colors[v] = <span class="string">&#x27;gray&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.处理v顶点</span></span><br><span class="line">    handler(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.访问v相连的其他顶点</span></span><br><span class="line">    <span class="keyword">let</span> vNeighbours = <span class="built_in">this</span>.edges.get(v)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vNeighbours.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> a = vNeighbours[i];</span><br><span class="line">      <span class="comment">//判断相邻顶点是否为白色，若为白色，递归调用函数继续访问</span></span><br><span class="line">      <span class="keyword">if</span> (colors[a] == <span class="string">&#x27;white&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.dfsVisit(a, colors, handler);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.将v设置为黑色</span></span><br><span class="line">    colors[v] = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
        <category>学习笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数据结构与算法（上）</title>
    <url>/2021/01/09/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>注意：原教学视频：<a href="https://www.bilibili.com/video/BV1a5411t7vZ">JavaScript(ES6)数据结构和算法</a>  |  <a href="https://www.bilibili.com/video/BV1r7411n7Pw">JavaScript数据结构与算法</a> (都是CoderWhy老师的教学)</p>
<p>原作者（笔记）链接：<a href="https://github.com/XPoet/JS-Data-Structures-and-Algorithms">JavaScript 数据结构与算法</a>  |  <a href="https://www.cnblogs.com/AhuntSun-blog/p/12636718.html">JavaScript数据结构与算法博客目录</a></p>
<p>PS：本文仅在学习过程中，对两篇笔记进行整合及总结（包含少量补充），以作学习之用。侵权立删。</p>
<p>Part1: 数组、栈、队列、优先队列、单向链表、双向链表。</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>

<h3 id="1-什么是数据结构？"><a href="#1-什么是数据结构？" class="headerlink" title="1. 什么是数据结构？"></a>1. 什么是数据结构？</h3><p>数据结构就是在计算机中，存储和组织数据的方式。</p>
<p>解决问题方法的效率，根据数据的组织方式有关。我们无需关心数据结构到底是什么，我们需要考虑的问题是：<strong>以什么样的方式，来存储和组织我们的数据才能在使用数据时更加方便呢？</strong>这才是学习数据结构的意义。</p>
<p><strong>常见的数据结构：</strong></p>
<ul>
<li><strong>数组</strong>（Aarray）</li>
<li><strong>栈</strong>（Stack）</li>
<li><strong>链表</strong>（Linked List）</li>
<li><strong>图</strong>（Graph）</li>
<li><strong>散列表</strong>（Hash）</li>
<li><strong>队列</strong>（Queue）</li>
<li><strong>树</strong>（Tree）</li>
<li><strong>堆</strong>（Heap）</li>
</ul>
<blockquote>
<p> 注意：数据结构与算法与语言无关，常见的编程语言都有<strong>直接或间接</strong>的使用上述常见的数据结构。</p>
</blockquote>
<h3 id="2-什么是算法？"><a href="#2-什么是算法？" class="headerlink" title="2. 什么是算法？"></a>2. 什么是算法？</h3><p><strong>算法（Algorithm）的定义：</strong></p>
<ul>
<li>一个有限指令集，每条指令的描述不依赖于语言。</li>
<li>接收一些输入（有些情况下不需要输入）。</li>
<li>产生输出。</li>
<li>一定在有限步骤之后终止。</li>
</ul>
<blockquote>
<p>通俗理解：解决问题的办法/步骤逻辑。数据结构的实现，离不开算法。</p>
</blockquote>
<br>

<a id="more"></a>

<h2 id="数组结构"><a href="#数组结构" class="headerlink" title="数组结构"></a>数组结构</h2><hr>

<blockquote>
<p>普通语言的数组封装（如Java的ArrayList）：</p>
<ul>
<li>常见语言的数组<strong>不能存放不同的数据类型</strong>，因此所有在封装时通常存放在数组中的是Object类型</li>
<li>常见语言的数组容量不会自动改变（需要进行扩容操作）。一般需要创建一个新数组放入以前的数组数据再放入其他内容</li>
<li>常见语言的数组进行中间插入和删除操作性能比较低</li>
</ul>
</blockquote>
<p> 几乎所有的编程语言都原生支持数组类型，因为数组是最简单的内存数据结构。 数组通常情况下用于存储一系列同一种数据类型的值。 但在 JavaScript 里，数组中可以保存不同类型的值。但我们还是要遵守最佳实践，别这么做（大多数语言都没这个能力）。</p>
<h3 id="创建和初始化数组"><a href="#创建和初始化数组" class="headerlink" title="创建和初始化数组"></a>创建和初始化数组</h3><ul>
<li><p>new Array() </p>
<p><code>const daysOfWeek = new Array(&#39;Sunday&#39;, &#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;,&#39;Thursday&#39;, &#39;Friday&#39;, &#39;Saturday&#39;);</code></p>
</li>
</ul>
<ul>
<li><p>[ ]</p>
<p><code>const daysOfWeek = [&#39;Sunday&#39;, &#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;, &#39;Saturday&#39;];</code></p>
</li>
</ul>
<h3 id="数组常见操作"><a href="#数组常见操作" class="headerlink" title="数组常见操作"></a>数组常见操作</h3><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><ul>
<li><p>添加一个元素到数组的最后位置 <code>array.push(item)</code></p>
</li>
<li><p>在数组首位插入一个元素 <code>array.unshift(item)</code></p>
</li>
<li><p>在指定索引位置插入元素</p>
</li>
</ul>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.splice(index.js, <span class="number">0</span>, item)</span><br></pre></td></tr></table></figure>


<p>  splice() 第二个参数为 0 时，表示插入数据。</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 在 索引 0 的位置，插入 A</span></span><br><span class="line">myArray.splice(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myArray); <span class="comment">//--&gt; [&#x27;A&#x27;, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><ul>
<li><p>删除数组最后的元素 <code>array.pop(item)</code></p>
</li>
<li><p>删除数组首位的元素 <code>array.shift(item)</code></p>
</li>
<li><p>删除指定索引位置的元素</p>
</li>
</ul>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.splice(start, number)</span><br></pre></td></tr></table></figure>
<p>  例如：</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myArray2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 删除索引 4 位置起，2 个元素</span></span><br><span class="line">myArray2.splice(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myArray2); <span class="comment">//--&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h4 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h4><ul>
<li>修改指定索引位置的元素</li>
</ul>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.splice(index.js, <span class="number">1</span>, item)</span><br></pre></td></tr></table></figure>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myArray3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">// 修改 索引 1 的位置的元素为 AA</span></span><br><span class="line">myArray2.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myArray3); <span class="comment">//--&gt; [1, &quot;AA&quot;, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改指定索引位置的几个元素</li>
</ul>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.splice(index.js, number, item)</span><br></pre></td></tr></table></figure>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myArray4 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="comment">// 在 索引 2 的位置起，修改两个元素为 AA BB</span></span><br><span class="line">myArray2.splice(<span class="number">2</span>, <span class="number">2</span>, <span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myArray3); <span class="comment">//--&gt; [1, 2, &quot;AA&quot;, &quot;BB&quot;, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>
<br>

<h2 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h2><hr>

<blockquote>
<p>数组也是一种<strong>线性结构</strong>，并且可以在任意位置插入和删除数据；</p>
<p>但是有时候，我们为了实现某些功能，必须对这种任意性加以限制；</p>
<p>而栈和队列就是比较常见的<strong>受限的线性结构</strong>。</p>
</blockquote>
<p>**栈结构示意图 **</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/1.png" alt="栈结构示意图"></p>
<h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><p>栈（stack），是一种受限的线性表。栈的特点为后进先出（LIFO）。</p>
<ul>
<li>其限制是仅允许在<strong>表的一端</strong>进行插入和删除运算。这一端被称为栈顶，相对的。另一端称为栈底。</li>
<li>LIFO（last in first out）表示后进入的元素，先弹出栈空间。</li>
<li>向一个栈插入新元素又称作<strong>进栈、入栈或压栈</strong>，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素。</li>
<li>从一个栈删除元素又称作<strong>出栈或退栈</strong>，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</li>
</ul>
<h3 id="程序中的栈结构"><a href="#程序中的栈结构" class="headerlink" title="程序中的栈结构"></a>程序中的栈结构</h3><ul>
<li>函数调用栈：A(B(C(D())))： 即 A 函数中调用 B，B 调用 C，C 调用 D；在 A 执行的过程中会将 A 压入栈，随后 B 执行时 B 也被压入栈，函数 C 和 D 执行时也会被压入栈。所以当前栈的顺序为：A-&gt;B-&gt;C-&gt;D（栈顶）；函数 D 执行完之后，会弹出栈被释放，弹出栈的顺序为 D-&gt;C-&gt;B-&gt;A;</li>
<li>递归： 为什么没有停止条件的递归会造成栈溢出？比如函数 A 为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数 A 压入栈，最后造成<strong>栈溢出</strong>（Queue Overfloat）。</li>
</ul>
<h3 id="栈结构面试题"><a href="#栈结构面试题" class="headerlink" title="栈结构面试题"></a>栈结构面试题</h3><blockquote>
<p>有六个元素6，5，4，3，2，1的顺序进栈，问下列哪一个不是合法的出栈序列？</p>
<p>A： 5 4 3 6 1 2       B：4 5 3 2 1 6        <strong>C</strong>：3 4 6 5 1 2         D：2 3 4 1 5 6 </p>
<p>（注意：题目所说的按顺序进栈指的不是一次性全部进栈，而是有进有出，进栈顺序为6 -&gt; 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1）</p>
<p>解析：</p>
<ul>
<li>A答案：65进栈，5出栈，4进栈出栈，3进栈出栈，6出栈，21进栈，1出栈，2出栈（整体入栈顺序符合654321）;</li>
<li>B答案：654进栈，4出栈，5出栈，3进栈出栈，2进栈出栈，1进栈出栈，6出栈（整体的入栈顺序符合654321）;</li>
<li>C答案：6543进栈，3出栈，4出栈，之后应该5出栈而不是6，所以错误；</li>
<li>D答案：65432进栈，2出栈，3出栈，4出栈，1进栈出栈，5出栈，6出栈。符合入栈顺序；</li>
</ul>
</blockquote>
<h3 id="栈常见的操作"><a href="#栈常见的操作" class="headerlink" title="栈常见的操作"></a>栈常见的操作</h3><ul>
<li><code>push(element)</code>：添加一个新元素到栈顶位置</li>
<li><code>pop()</code>：移除栈顶的元素，同时返回被移除的元素</li>
<li><code>peek()</code>：返回栈顶的元素，但不对栈做任何修改</li>
<li><code>isEmpty()</code>：若栈中没有任何元素就返回true，否则返回false</li>
<li><code>size()</code>：返回栈里元素的个数。与数组的length属性类似</li>
<li><code>toString()</code>：将栈结构的内容以字符形式返回</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>实现栈结构有两种比较常见的方式：基于数组和基于链表。（Js中没有自带链表）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装栈类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//栈中的属性，这里其实是给函数添加了一个items属性，因为函数也是对象</span></span><br><span class="line">    <span class="built_in">this</span>.items = [];</span><br><span class="line">    <span class="comment">//栈的相关操作</span></span><br><span class="line">    <span class="comment">//1.压栈</span></span><br><span class="line">    <span class="comment">//方式一(不推荐)：给对象添加方法，其他对象不能复用</span></span><br><span class="line">    <span class="comment">// this.push = () =&gt; &#123; &#125;</span></span><br><span class="line">    <span class="comment">//方式二(推荐)：给Stack类添加方法，能够多对象复用</span></span><br><span class="line">    Stack.prototype.push = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;     </span><br><span class="line">        <span class="built_in">this</span>.items.push(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.栈中取出元素</span></span><br><span class="line">    Stack.prototype.pop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.查看栈顶元素</span></span><br><span class="line">    Stack.prototype.peek = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.items.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.判断栈是否为空</span></span><br><span class="line">    Stack.prototype.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items.length == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.获取栈中元素的个数</span></span><br><span class="line">    Stack.prototype.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.toString()方法</span></span><br><span class="line">    Stack.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> resultString = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.items.length; i++) &#123;</span><br><span class="line">            resultString += <span class="built_in">this</span>.items[i] + <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="简单应用：十进制转二进制"><a href="#简单应用：十进制转二进制" class="headerlink" title="简单应用：十进制转二进制"></a>简单应用：十进制转二进制</h3><p>封装源码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec2bin</span>(<span class="params">decNumber</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//定义栈对象</span></span><br><span class="line">    <span class="keyword">var</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">while</span> (decNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//1.获取余数，并放入栈中</span></span><br><span class="line">        stack.push(decNumber % <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//2.获取整除后的结果</span></span><br><span class="line">        decNumber = <span class="built_in">Math</span>.floor(decNumber / <span class="number">2</span>);    <span class="comment">//Math.floor()：向下取整</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.从栈中取出0和1</span></span><br><span class="line">    <span class="keyword">var</span> binaryString = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        binaryString += stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binaryString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h2 id="队列结构"><a href="#队列结构" class="headerlink" title="队列结构"></a>队列结构</h2><hr>

<blockquote>
<p>队列（Queue），它是一种受限的线性表，<strong>先进先出（FIFO）</strong>。</p>
<p>受限之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。</p>
</blockquote>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/1.png" alt="栈结构示意图"></p>
<h3 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h3><p>队列的实现和栈一样，可以基于数组和链表实现。</p>
<h3 id="队列的常见操作"><a href="#队列的常见操作" class="headerlink" title="队列的常见操作"></a>队列的常见操作</h3><ul>
<li><code>enqueue(element)</code>：向队列尾部添加一个（或多个）新的项</li>
<li><code>dequeue()</code>：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素</li>
<li><code>front()</code>：移除队列中的第一个元素——最先被添加，也将是最先被移除的元素队列不做任何变动（不移除元素，只返回元素信息——与Stack类的peek方法非常类似）</li>
<li><code>isEmpty()</code>：如果队列中不包含任何元素，返回true，否则返回false</li>
<li><code>size()</code>：返回队列包含的元素个数，与数组的length属性类似</li>
<li><code>toString()</code>：将队列中的内容，转成字符串形式</li>
</ul>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于数组封装队列类</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 属性</span></span><br><span class="line">     <span class="built_in">this</span>.items = [];</span><br><span class="line">     </span><br><span class="line">   <span class="comment">// 方法</span></span><br><span class="line">   <span class="comment">// 1.enqueue():将元素加入到队列中</span></span><br><span class="line">   Queue.prototype.enqueue = <span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.items.push(element)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 2.dequeue():从队列中删除前端元素</span></span><br><span class="line">   Queue.prototype.dequeue = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.items.shift()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 3.front():查看前端的元素</span></span><br><span class="line">   Queue.prototype.front = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="number">0</span>]</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 4.isEmpty:查看队列是否为空</span></span><br><span class="line">   Queue.prototype.isEmpty = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.items.length == <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 5.size():查看队列中元素的个数</span></span><br><span class="line">   Queue.prototype.size = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.items.length</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 6.toString():将队列中元素以字符串形式输出</span></span><br><span class="line">   Queue.prototype.toString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> resultString = <span class="string">&#x27;&#x27;</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> <span class="built_in">this</span>.items)&#123;</span><br><span class="line">         resultString += i + <span class="string">&#x27; &#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> resultString</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列应用：击鼓传花"><a href="#队列应用：击鼓传花" class="headerlink" title="队列应用：击鼓传花"></a>队列应用：击鼓传花</h3><p>使用队列实现小游戏：击鼓传花。</p>
<p>分析：传入一组数据和设定的数字num，循环遍历数组内元素，遍历到的元素为指定数字num时将该元素删除，直至数组剩下一个元素。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 队列应用：面试题：击鼓传花</span></span><br><span class="line"><span class="keyword">let</span> passGame = <span class="function">(<span class="params">nameList, num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//1.创建队列结构</span></span><br><span class="line">  <span class="keyword">let</span> queue = <span class="keyword">new</span> Queue()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.将所有人依次加入队列</span></span><br><span class="line">  <span class="comment">// 这是ES6的for循环写法，i相当于nameList[i]</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> nameList)&#123;</span><br><span class="line">    queue.enqueue(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.开始数数</span></span><br><span class="line"> <span class="keyword">while</span>(queue.size() &gt; <span class="number">1</span>)&#123;<span class="comment">//队列中只剩1个人就停止数数</span></span><br><span class="line">  <span class="comment">// 不是num的时候，重新加入队列末尾</span></span><br><span class="line">  <span class="comment">// 是num的时候，将其从队列中删除</span></span><br><span class="line">  <span class="comment">// 3.1.num数字之前的人重新放入队列的末尾(把队列前面删除的加到队列最后)</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; num-<span class="number">1</span>; i++ )&#123;</span><br><span class="line">    queue.enqueue(queue.dequeue())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3.2.num对应这个人，直接从队列中删除</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路是这样的，由于队列没有像数组一样的下标值不能直接取到某一元素，所以采用，把num前面的num-1个元素先删除后添加到队列末尾，这样第num个元素就排到了队列的最前面，可以直接使用dequeue方法进行删除</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  queue.dequeue()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4.获取剩下的那个人</span></span><br><span class="line">  <span class="built_in">console</span>.log(queue.size());							</span><br><span class="line">  <span class="keyword">let</span> endName = queue.front()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;最终剩下的人：&#x27;</span> + endName);						 </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> nameList.indexOf(endName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.测试击鼓传花</span></span><br><span class="line"><span class="keyword">let</span> names = [<span class="string">&#x27;lily&#x27;</span>, <span class="string">&#x27;lucy&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lilei&#x27;</span>, <span class="string">&#x27;Tony&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(passGame(names, <span class="number">3</span>));								</span><br></pre></td></tr></table></figure>
<br>

<h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><hr>

<h3 id="优先级队列的特点"><a href="#优先级队列的特点" class="headerlink" title="优先级队列的特点"></a>优先级队列的特点</h3><ul>
<li>普通的队列插入一个元素，数据会被放在<strong>后端</strong>，并且需要前面所有的元素都处理完成后才会处理前面的数据。</li>
<li>但是优先级队列，在插入一个元素的时候会考虑<strong>该数据的优先级</strong>。</li>
<li>和其他数据优先级<strong>进行比较</strong>。</li>
<li>比较完成后，可以得出这个元素在队列中<strong>正确的位置</strong>。</li>
<li>其他处理方式，和基本队列的处理方式一样。</li>
</ul>
<p>优先级队列<strong>主要考虑的问题</strong>：</p>
<ul>
<li>每个元素不再只是一个数据，还包含数据的优先级；</li>
<li>在添加数据过程中，根据优先级放入到正确位置；</li>
</ul>
<h3 id="优先级队列的实现"><a href="#优先级队列的实现" class="headerlink" title="优先级队列的实现"></a>优先级队列的实现</h3><p><strong>代码实现</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装优先级队列</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PriorityQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//内部类：在类里面再封装一个类;表示带优先级的数据</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">QueueElement</span>(<span class="params">element, priority</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.element = element;</span><br><span class="line">    <span class="built_in">this</span>.priority = priority;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装属性</span></span><br><span class="line">  <span class="built_in">this</span>.items = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.实现按照优先级插入方法</span></span><br><span class="line">  PriorityQueue.prototype.enqueue = <span class="function">(<span class="params">element, priority</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 1.1.创建QueueElement对象</span></span><br><span class="line">    <span class="keyword">let</span> queueElement = <span class="keyword">new</span> QueueElement(element, priority);</span><br><span class="line">    <span class="comment">// 1.2.判断队列是否为空,没有其他元素可以直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.items.length == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">this</span>.items.push(queueElement);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 定义一个变量记录是否成功添加了新元素</span></span><br><span class="line">      <span class="keyword">let</span> added = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> <span class="built_in">this</span>.items)&#123;</span><br><span class="line">        <span class="comment">// 让新插入的元素与原有元素进行优先级比较(priority越小，优先级越大)</span></span><br><span class="line">        <span class="keyword">if</span>(queueElement.priority &lt; i.priority)&#123;</span><br><span class="line">          <span class="built_in">this</span>.items.splice(i, <span class="number">0</span>, queueElement);</span><br><span class="line">          added = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 新元素已经找到插入位置了可以使用break停止循环</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 新元素没有成功插入，就把它放在队列的最前面</span></span><br><span class="line">      <span class="keyword">if</span>(!added)&#123;</span><br><span class="line">        <span class="built_in">this</span>.items.push(queueElement);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.dequeue():从队列中删除前端元素</span></span><br><span class="line">  PriorityQueue.prototype.dequeue = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.shift();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.front():查看前端的元素</span></span><br><span class="line">  PriorityQueue.prototype.front = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.isEmpty():查看队列是否为空</span></span><br><span class="line">  PriorityQueue.prototype.isEmpty = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.length == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.size():查看队列中元素的个数</span></span><br><span class="line">  PriorityQueue.prototype.size = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6.toString():以字符串形式输出队列中的元素</span></span><br><span class="line">  PriorityQueue.prototype.toString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> resultString = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> <span class="built_in">this</span>.items)&#123;</span><br><span class="line">        resultString += i.element + <span class="string">&#x27;-&#x27;</span> + i.priority + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> resultString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> pq = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">pq.enqueue(<span class="string">&#x27;Tom&#x27;</span>,<span class="number">111</span>);</span><br><span class="line">pq.enqueue(<span class="string">&#x27;Hellen&#x27;</span>,<span class="number">200</span>);</span><br><span class="line">pq.enqueue(<span class="string">&#x27;Mary&#x27;</span>,<span class="number">30</span>);</span><br><span class="line">pq.enqueue(<span class="string">&#x27;Gogo&#x27;</span>,<span class="number">27</span>);</span><br><span class="line"><span class="comment">// 打印修改过后的优先队列对象</span></span><br><span class="line"><span class="built_in">console</span>.log(pq);</span><br></pre></td></tr></table></figure>
<h4 id="ES6实现"><a href="#ES6实现" class="headerlink" title="ES6实现"></a>ES6实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优先队列内部的元素类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueElement</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">element, priority</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.element = element;</span><br><span class="line">    <span class="built_in">this</span>.priority = priority;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先队列类（继承 Queue 类）</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span> <span class="keyword">extends</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enqueue(element, priority) 入队，将元素按优先级加入到队列中</span></span><br><span class="line">  <span class="comment">// 重写 enqueue()</span></span><br><span class="line">  <span class="function"><span class="title">enqueue</span>(<span class="params">element, priority</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据传入的元素，创建 QueueElement 对象</span></span><br><span class="line">    <span class="keyword">const</span> queueElement = <span class="keyword">new</span> QueueElement(element, priority);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// 如果为空，不用判断优先级，直接添加</span></span><br><span class="line">      <span class="built_in">this</span>.items.push(queueElement);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 定义一个变量记录是否成功添加了新元素</span></span><br><span class="line">      <span class="keyword">let</span> added = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.items.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 让新插入的元素进行优先级比较，priority 值越小，优先级越大</span></span><br><span class="line">        <span class="keyword">if</span> (queueElement.priority &lt; <span class="built_in">this</span>.items[i].priority) &#123;</span><br><span class="line">          <span class="comment">// 在指定的位置插入元素</span></span><br><span class="line">          <span class="built_in">this</span>.items.splice(i, <span class="number">0</span>, queueElement);</span><br><span class="line">          added = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果遍历完所有元素，优先级都大于新插入的元素，就将新插入的元素插入到最后</span></span><br><span class="line">      <span class="keyword">if</span> (!added) &#123;</span><br><span class="line">        <span class="built_in">this</span>.items.push(queueElement);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dequeue() 出队，从队列中删除前端元素，返回删除的元素</span></span><br><span class="line">  <span class="comment">// 继承 Queue 类的 dequeue()</span></span><br><span class="line">  <span class="function"><span class="title">dequeue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.dequeue();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// front() 查看队列的前端元素</span></span><br><span class="line">  <span class="comment">// 继承 Queue 类的 front()</span></span><br><span class="line">  <span class="function"><span class="title">front</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.front();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isEmpty() 查看队列是否为空</span></span><br><span class="line">  <span class="comment">// 继承 Queue 类的 isEmpty()</span></span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// size() 查看队列中元素的个数</span></span><br><span class="line">  <span class="comment">// 继承 Queue 类的 size()</span></span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// toString() 将队列中元素以字符串形式返回</span></span><br><span class="line">  <span class="comment">// 重写 toString()</span></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="built_in">this</span>.items) &#123;</span><br><span class="line">      result += item.element + <span class="string">&#x27;-&#x27;</span> + item.priority + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> priorityQueue = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="comment">// 入队 enqueue() 测试</span></span><br><span class="line">priorityQueue.enqueue(<span class="string">&#x27;A&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">priorityQueue.enqueue(<span class="string">&#x27;B&#x27;</span>, <span class="number">15</span>);</span><br><span class="line">priorityQueue.enqueue(<span class="string">&#x27;C&#x27;</span>, <span class="number">11</span>);</span><br><span class="line">priorityQueue.enqueue(<span class="string">&#x27;D&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">priorityQueue.enqueue(<span class="string">&#x27;E&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(priorityQueue.items);</span><br><span class="line"><span class="comment">//--&gt; output:</span></span><br><span class="line"><span class="comment">// QueueElement &#123;element: &quot;A&quot;, priority: 10&#125;</span></span><br><span class="line"><span class="comment">// QueueElement &#123;element: &quot;C&quot;, priority: 11&#125;</span></span><br><span class="line"><span class="comment">// QueueElement &#123;element: &quot;B&quot;, priority: 15&#125;</span></span><br><span class="line"><span class="comment">// QueueElement &#123;element: &quot;E&quot;, priority: 18&#125;</span></span><br><span class="line"><span class="comment">// QueueElement &#123;element: &quot;D&quot;, priority: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队 dequeue() 测试</span></span><br><span class="line">priorityQueue.dequeue();</span><br><span class="line">priorityQueue.dequeue();</span><br><span class="line"><span class="built_in">console</span>.log(priorityQueue.items);</span><br><span class="line"><span class="comment">//--&gt; output:</span></span><br><span class="line"><span class="comment">// QueueElement &#123;element: &quot;B&quot;, priority: 15&#125;</span></span><br><span class="line"><span class="comment">// QueueElement &#123;element: &quot;E&quot;, priority: 18&#125;</span></span><br><span class="line"><span class="comment">// QueueElement &#123;element: &quot;D&quot;, priority: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// isEmpty() 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(priorityQueue.isEmpty()); <span class="comment">//--&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// size() 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(priorityQueue.size()); <span class="comment">//--&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// toString() 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(priorityQueue.toString()); <span class="comment">//--&gt; B-15 E-18 D-20</span></span><br></pre></td></tr></table></figure>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><strong>数组的push方法在数组、栈和队列中的形式：</strong></p>
<ul>
<li><strong>数组</strong>：在数组[0，1，2]中，pop(3)，结果为[0，1，2，3]；</li>
<li><strong>栈</strong>：执行pop(0)，pop(1)，pop(2)，pop(3)，从栈底到栈顶的元素分别为：0，1，2，3；如果看成数组，可写为[0，1，2，3]，但是索引为3的元素3其实是栈顶元素；所以说栈的push方法是向栈顶添加元素（但在数组的视角下为向数组尾部添加元素）；</li>
<li><strong>队列</strong>：enqueue方法可以由数组的push方法实现，与数组相同，相当于在数组尾部添加元素。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/6.png" alt="数组、栈和队列图解"></p>
<br>

<h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><hr>

<h3 id="认识链表"><a href="#认识链表" class="headerlink" title="认识链表"></a>认识链表</h3><h4 id="链表和数组"><a href="#链表和数组" class="headerlink" title="链表和数组"></a>链表和数组</h4><p>链表和数组一样，可以用于存储一系列的元素，但是链表和数组的<strong>实现机制完全不同</strong>。</p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><ul>
<li><p>存储多个元素，数组（或列表）可能是最常用的数据结构。</p>
</li>
<li><p>几乎每一种编程语言都有默认实现数组结构，提供了一个便利的 <code>[]</code> 语法来访问数组元素。</p>
</li>
<li><p>数组缺点：</p>
<ul>
<li><p>数组的创建需要申请一段连续的内存空间(一整块内存)，并且大小是固定的，当前数组不能满足容量需求时，需要扩容。 (一般情况下是申请一个更大的数组，比如 2 倍，然后将原数组中的元素复制过去)</p>
</li>
<li><p>在数组开头或中间位置插入数据的成本很高，需要进行大量元素的位移。</p>
</li>
</ul>
</li>
</ul>
<h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><ul>
<li><p>存储多个元素，另外一个选择就是使用链表。</p>
</li>
<li><p>不同于数组，链表中的元素在内存中<strong>不必是连续的空间</strong>。</p>
</li>
<li><p>链表的每个元素由一个存储<strong>元素本身的节点</strong>和一个<strong>指向下一个元素的引用</strong>(有些语言称为指针)组成。</p>
</li>
<li><p>链表优点：</p>
<ul>
<li><p>内存空间不必是连续的，可以充分利用计算机的内存，实现灵活的<strong>内存动态管理</strong>。</p>
</li>
<li><p>链表不必在创建时就确定大小，并且大小可以<strong>无限延伸下去</strong>。</p>
</li>
<li><p>链表在插入和删除数据时，时间复杂度可以达到 O(1)，相对数组效率高很多。</p>
</li>
</ul>
</li>
<li><p>链表缺点：</p>
<ul>
<li><p>访问任何一个位置的元素时，需要<strong>从头开始访问</strong>。(无法跳过第一个元素访问任何一个元素)</p>
</li>
<li><p>无法通过下标值直接访问元素，需要<strong>从头开始一个个访问</strong>，直到找到对应的元素。</p>
</li>
<li><p>虽然可以轻松地到达下一个节点，但是回到前一个节点是很难的。</p>
</li>
</ul>
</li>
</ul>
<h3 id="单向链表的定义"><a href="#单向链表的定义" class="headerlink" title="单向链表的定义"></a>单向链表的定义</h3><p>单向链表类似于火车头，一节车厢载着乘客（数据），通过节点连接另一节车厢，以此类推。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/2.png" alt="链表的火车结构示意图"></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/3.png" alt="链表结构示意图"></p>
<ul>
<li>head属性指向链表的第一个节点；</li>
<li>链表中的最后一个节点指向null；</li>
<li>当链表中一个节点也没有的时候，head直接指向null；</li>
</ul>
<h3 id="链表中的常见操作"><a href="#链表中的常见操作" class="headerlink" title="链表中的常见操作"></a>链表中的常见操作</h3><ul>
<li><code>append(element)</code> 向链表尾部添加一个新的项。</li>
<li><code>insert(position, element)</code> 向链表的特定位置插入一个新的项。</li>
<li><code>getData(position)</code> 获取对应位置的元素数据。</li>
<li><code>indexOf(element)</code> 返回元素在链表中的索引。如果链表中没有该元素就返回-1。</li>
<li><code>update(position, element)</code> 修改某个位置的元素。</li>
<li><code>removeAt(position)</code> 从链表的特定位置移除一项。</li>
<li><code>remove(element)</code> 从链表中移除一项。</li>
<li><code>isEmpty()</code> 如果链表中不包含任何元素，返回 trun，如果链表长度大于 0 则返回 false。</li>
<li><code>size()</code> 返回链表包含的元素个数，与数组的 length 属性类似。</li>
<li><code>toString()</code> 由于链表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值。</li>
</ul>
<h3 id="封装单向链表类"><a href="#封装单向链表类" class="headerlink" title="封装单向链表类"></a>封装单向链表类</h3><p>首先需要弄清楚：下文中的position指的是两个节点之间，并且与index的关系如下图所示：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/4.png"></p>
<p>position的值一般表示position所指位置的下一个节点。当position的值与index的值相等时，比如position = index = 1，那么它们都表示Node2。</p>
<h4 id="0-创建单向链表类"><a href="#0-创建单向链表类" class="headerlink" title="0. 创建单向链表类"></a>0. 创建单向链表类</h4><p>先创建单向链表类LinkedList，并添加基本属性，再逐步实现单向链表的常用方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装单向链表类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 封装一个内部类：节点类</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.data = data;</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="comment">// 属性head指向链表的第一个节点</span></span><br><span class="line">  <span class="built_in">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*ES6使用class实现*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始链表长度为 0</span></span><br><span class="line">  length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始 head 为 null，head 指向链表的第一个节点</span></span><br><span class="line">  head = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内部类（链表里的节点 Node）</span></span><br><span class="line">  Node = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    data;</span><br><span class="line">    next = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h4 id="1-append-element"><a href="#1-append-element" class="headerlink" title="1. append(element)"></a>1. append(element)</h4><p><strong>过程详解：</strong></p>
<ul>
<li>首先让current指向第一个节点：</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/5.png"></p>
<ul>
<li>通过while循环使current指向最后一个节点，最后通过current.next = newNode，让最后一个节点指向新节点newNode：</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/6.png"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一.实现append方法</span></span><br><span class="line">LinkedList.prototype.append = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//1.创建新节点</span></span><br><span class="line">  <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.添加新节点</span></span><br><span class="line">  <span class="comment">//情况1：只有一个节点时候</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">this</span>.length == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>.head = newNode;</span><br><span class="line">  <span class="comment">//情况2：节点数大于1，在链表的最后添加新节点  </span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;              </span><br><span class="line">    <span class="comment">//让变量current指向第一个节点</span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="comment">//当current.next(下一个节点不为空)不为空时，一直循环，直到current指向最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (current.next)&#123;</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后节点的next指向新的节点</span></span><br><span class="line">    current.next = newNode;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//3.添加完新结点之后length+1</span></span><br><span class="line">  <span class="built_in">this</span>.length += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*ES6使用class实现，此处仅做一个示例，后面的单向链表方法实现相同，方法块中的内容和不用class实现的代码一样，便不再赘述*/</span></span><br><span class="line"><span class="comment">// append() 往链表尾部追加数据</span></span><br><span class="line"><span class="function"><span class="title">append</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、创建新节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="built_in">this</span>.Node(data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、追加新节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 链表长度为 0 时，即只有 head 的时候</span></span><br><span class="line">    <span class="built_in">this</span>.head = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 链表长度大于 0 时，在最后面添加新节点</span></span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="comment">// 当 currentNode.next 不为空时，</span></span><br><span class="line">    <span class="comment">// 循序依次找最后一个节点，即节点的 next 为 null 时</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一个节点的 next 指向新节点</span></span><br><span class="line">    currentNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3、追加完新节点后，链表长度 + 1</span></span><br><span class="line">    <span class="built_in">this</span>.length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建LinkList</span></span><br><span class="line"><span class="keyword">const</span> list = <span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.测试append方法</span></span><br><span class="line">list.append(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">list.append(<span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line">list.append(<span class="string">&#x27;ccc&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(list);  </span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/7.png"></p>
<br>

<h4 id="2-toString"><a href="#2-toString" class="headerlink" title="2. toString()"></a>2. toString()</h4><p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现toString方法</span></span><br><span class="line">LinkedList.prototype.toString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 1.定义变量</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">  <span class="keyword">let</span> listString = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.循环获取一个个的节点</span></span><br><span class="line">  <span class="keyword">while</span>(current)&#123; </span><br><span class="line">    listString += current.data + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    current = current.next;<span class="comment">//千万不要忘了拼接完一个节点数据之后，让current指向下一个节点</span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span>  listString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建LinkList</span></span><br><span class="line"><span class="keyword">let</span> list = <span class="keyword">new</span> LinkedList()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">list.append(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">list.append(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">list.append(<span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试toString方法</span></span><br><span class="line"><span class="built_in">console</span>.log(list.toString());</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/8.png" alt="image-20200305235437934"></p>
<br>

<h4 id="3-insert-position-element"><a href="#3-insert-position-element" class="headerlink" title="3. insert(position,element)"></a>3. insert(position,element)</h4><p><strong>过程详解：</strong></p>
<p>insert方法实现的过程：根据插入节点位置的不同可分为多种情况：</p>
<ul>
<li><strong>情况1：position = 0</strong>：</li>
</ul>
<p>通过： <code>newNode.next = this.head</code>，建立连接1；</p>
<p>通过： <code>this.head = newNode</code>，建立连接2；（不能先建立连接2，否则this.head不再指向Node1）</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/9.png"></p>
<ul>
<li><strong>情况2：position &gt; 0</strong>：</li>
</ul>
<p>首先定义两个变量previous和curent分别指向需要插入位置pos = X的前一个节点和后一个节点；</p>
<p>然后，通过：<code>newNode.next = current</code>，改变指向3；</p>
<p>最后，通过：<code>previous.next = newNode</code>，改变指向4；</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/10.png"></p>
<ul>
<li><strong>情况2的特殊情形：position = length</strong>：</li>
</ul>
<p>情况2也包含了pos = length的情况，该情况下current和newNode.next都指向null；建立连接3和连接4的方式与情况2相同。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/11.png"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现insert方法</span></span><br><span class="line">LinkedList.prototype.insert = <span class="function">(<span class="params">position, data</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//理解positon的含义：position=0表示新界点插入后要成为第1个节点，position=2表示新界点插入后要成为第3个节点</span></span><br><span class="line">  <span class="comment">//1.对position进行越界判断:要求传入的position不能是负数且不能超过LinkedList的length</span></span><br><span class="line">  <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt; <span class="built_in">this</span>.length)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2.根据data创建newNode</span></span><br><span class="line">  <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.插入新节点</span></span><br><span class="line">  <span class="comment">//情况1：插入位置position=0</span></span><br><span class="line">  <span class="keyword">if</span>(position == <span class="number">0</span>)&#123; </span><br><span class="line">    <span class="comment">// 让新节点指向第一个节点</span></span><br><span class="line">    newNode.next = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="comment">// 让head指向新节点</span></span><br><span class="line">    <span class="built_in">this</span>.head = newNode;</span><br><span class="line">  <span class="comment">//情况2：插入位置position&gt;0(该情况包含position=length)</span></span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="comment">//步骤1：通过while循环使变量current指向position位置的后一个节点(注意while循环的写法)</span></span><br><span class="line">    <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">    <span class="comment">//步骤2：在current指向下一个节点之前，让previous指向current当前指向的节点 </span></span><br><span class="line">      previous = current;</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 步骤3：通过变量current(此时current已经指向position位置的后一个节点)，使newNode指向position位置的后一个节点</span></span><br><span class="line">    newNode.next = current;</span><br><span class="line">    <span class="comment">//步骤4：通过变量previous，使position位置的前一个节点指向newNode</span></span><br><span class="line">    previous.next = newNode;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      启示：</span></span><br><span class="line"><span class="comment">      1.我们无法直接操作链表中的节点，但是可以通过变量指向这些节点，以此间接地操作节点(替身使者)；</span></span><br><span class="line"><span class="comment">      比如current指向节点3，想要节点3指向节点4只需要：current.next = 4即可。</span></span><br><span class="line"><span class="comment">      2.两个节点间是双向的，想要节点2的前一个节点为节点1，可以通过：1.next=2，来实现；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//4.新节点插入后要length+1</span></span><br><span class="line">  <span class="built_in">this</span>.length += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h4 id="4-getData-position"><a href="#4-getData-position" class="headerlink" title="4. getData(position)"></a>4. getData(position)</h4><p><strong>过程详解：</strong></p>
<p>getData方法的实现过程：以获取position = 2为例，如下图所示：</p>
<ul>
<li>首先使current指向第一个节点，此时index=0；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/14.png"></p>
<ul>
<li>通过while循环使current循环指向下一个节点，注意循环终止的条件index++ &lt; position，即当index=position时停止循环，此时循环了1次，current指向第二个节点(Node2)，最后通过current.data返回Node2节点的数据；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/15.png"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现get方法</span></span><br><span class="line">LinkedList.prototype.getData = <span class="function">(<span class="params">position</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//1.越界判断</span></span><br><span class="line">  <span class="comment">// 当position = length时，取到的是null所以0 =&lt; position &lt; length</span></span><br><span class="line">  <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt;= <span class="built_in">this</span>.length)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2.获取指定的positon位置的后一个节点的data</span></span><br><span class="line">  <span class="comment">//同样使用一个变量间接操作节点</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">    current = current.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">   <span class="comment">//1.创建LinkedList</span></span><br><span class="line">   <span class="keyword">let</span> list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2.插入数据</span></span><br><span class="line">   list.append(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">   list.append(<span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line">   list.append(<span class="string">&#x27;ccc&#x27;</span>);	</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试get方法</span></span><br><span class="line">   <span class="built_in">console</span>.log(list.get(<span class="number">0</span>));</span><br><span class="line">   <span class="built_in">console</span>.log(list.get(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/16.png"></p>
<br>

<h4 id="5-indexOf-element"><a href="#5-indexOf-element" class="headerlink" title="5. indexOf(element)"></a>5. indexOf(element)</h4><p><strong>过程详解：</strong></p>
<p>indexOf方法的实现过程：</p>
<ul>
<li>使用变量current记录当前指向的节点，使用变量index记录当前节点的索引值（注意index = node数-1）：</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/17.png"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现indexOf方法</span></span><br><span class="line">LinkedList.prototype.indexOf = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//1.定义变量</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.开始查找:只要current不指向null就一直循环</span></span><br><span class="line">  <span class="keyword">while</span>(current)&#123;</span><br><span class="line">    <span class="keyword">if</span>(current.data == data)&#123;</span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    current = current.next;</span><br><span class="line">    index += <span class="number">1</span>;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.遍历完链表没有找到，返回-1</span></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">   <span class="comment">//1.创建LinkList</span></span><br><span class="line">   <span class="keyword">let</span> list = <span class="keyword">new</span> LinkedList()</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2.插入数据</span></span><br><span class="line">   list.append(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">   list.append(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">   list.append(<span class="string">&#x27;ccc&#x27;</span>)	</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//3.测试indexOf方法</span></span><br><span class="line">   <span class="built_in">console</span>.log(list.indexOf(<span class="string">&#x27;aaa&#x27;</span>));</span><br><span class="line">   <span class="built_in">console</span>.log(list.indexOf(<span class="string">&#x27;ccc&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/18.png"></p>
<br>

<h4 id="6-update-position-element"><a href="#6-update-position-element" class="headerlink" title="6. update(position,element)"></a>6. update(position,element)</h4><p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现update方法</span></span><br><span class="line">LinkedList.prototype.update = <span class="function">(<span class="params">position, newData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//1.越界判断</span></span><br><span class="line">  <span class="comment">//因为被修改的节点不能为null，所以position不能等于length</span></span><br><span class="line">  <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt;= <span class="built_in">this</span>.length)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2.查找正确的节点</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">    current = current.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3.将position位置的后一个节点的data修改成newData</span></span><br><span class="line">  current.data = newData;</span><br><span class="line">  <span class="comment">//返回true表示修改成功</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">   <span class="comment">//1.创建LinkList</span></span><br><span class="line">   <span class="keyword">let</span> list = <span class="keyword">new</span> LinkedList()</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2.插入数据</span></span><br><span class="line">   list.append(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">   list.append(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">   list.append(<span class="string">&#x27;ccc&#x27;</span>)	</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//3.测试update方法</span></span><br><span class="line">   list.update(<span class="number">0</span>, <span class="string">&#x27;修改第一个节点&#x27;</span>)</span><br><span class="line">   list.update(<span class="number">1</span>, <span class="string">&#x27;修改第二个节点&#x27;</span>)</span><br><span class="line">   <span class="built_in">console</span>.log(list);</span><br><span class="line">   <span class="built_in">console</span>.log(list.update(<span class="number">3</span>, <span class="string">&#x27;能修改么&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/19.png"></p>
<br>

<h4 id="7-removeAt-position"><a href="#7-removeAt-position" class="headerlink" title="7. removeAt(position)"></a>7. removeAt(position)</h4><p><strong>过程详解：</strong></p>
<p>removeAt方法的实现过程：删除节点时存在多种情况：</p>
<ul>
<li><strong>情况1：position = 0</strong>，即移除第一个节点（Node1）。</li>
</ul>
<p>通过：<code>this.head = this.head.next</code>，改变指向1即可；</p>
<p>虽然Node1的next仍指向Node2，但是没有引用指向Node1，则Node1会被垃圾回收器自动回收，所以不用处理Node1指向Node2的引用next。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/20.png" alt="image-20200306110518877"></p>
<ul>
<li><strong>情况2：positon &gt; 0</strong>，比如pos = 2即移除第三个节点（Node3）。</li>
</ul>
<p><strong>注意：</strong>position = length时position后一个节点为null不能删除，因此position != length；</p>
<p>首先，定义两个变量previous和curent分别指向需要删除位置pos = x的前一个节点和后一个节点；</p>
<p>然后，通过：<code>previous.next = current.next</code>，改变指向1即可；</p>
<p>随后，没有引用指向Node3，Node3就会被自动回收，至此成功删除Node3 。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/21.png" alt="image-20200306104624457"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现removeAt方法</span></span><br><span class="line">LinkedList.prototype.removeAt = <span class="function">(<span class="params">position</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//1.越界判断</span></span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="built_in">this</span>.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2.删除元素</span></span><br><span class="line">  <span class="comment">//情况1：position = 0时(删除第一个节点)</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">  <span class="keyword">if</span> (position ==<span class="number">0</span> ) &#123;</span><br><span class="line">  <span class="comment">//情况2：position &gt; 0时</span></span><br><span class="line">    <span class="built_in">this</span>.head = <span class="built_in">this</span>.head.next;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">      previous = current;</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环结束后，current指向position后一个节点，previous指向current前一个节点</span></span><br><span class="line">    <span class="comment">//再使前一个节点的next指向current的next即可</span></span><br><span class="line">    previous.next = current.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3.length-1;</span></span><br><span class="line">  <span class="built_in">this</span>.length -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回被删除节点的data，为此current定义在最上面</span></span><br><span class="line">  <span class="keyword">return</span> current.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//测试代码</span></span><br><span class="line">  <span class="comment">//1.创建LinkedList</span></span><br><span class="line">  <span class="keyword">let</span> list = <span class="keyword">new</span> LinkedList()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//2.插入数据</span></span><br><span class="line">  list.append(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">  list.append(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">  list.append(<span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试removeAt方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(list.removeAt(<span class="number">0</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(list.removeAt(<span class="number">0</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(list);</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/22.png" alt="image-20200306000839608"></p>
<br>

<h4 id="8-其他方法"><a href="#8-其他方法" class="headerlink" title="8. 其他方法"></a>8. 其他方法</h4><p>其他方法包括：<strong>remove(element)、isEmpty()、size()</strong></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-------------其他方法的实现--------------*/</span></span><br><span class="line">      <span class="comment">//一.实现remove方法</span></span><br><span class="line">      LinkedList.prototype.remove = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取data在列表中的位置</span></span><br><span class="line">        <span class="keyword">let</span> position = <span class="built_in">this</span>.indexOf(data);</span><br><span class="line">        <span class="comment">//2.根据位置信息，删除结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.removeAt(position);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//二.实现isEmpty方法</span></span><br><span class="line">      LinkedList.prototype.isEmpty = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.length == <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//三.实现size方法</span></span><br><span class="line">      LinkedList.prototype.size = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.length;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//测试代码</span></span><br><span class="line">    <span class="comment">//1.创建LinkList</span></span><br><span class="line">    <span class="keyword">let</span> list = <span class="keyword">new</span> LinkedList()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.插入数据</span></span><br><span class="line">    list.append(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">    list.append(<span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line">    list.append(<span class="string">&#x27;ccc&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------其他方法测试----------------*/</span></span><br><span class="line">  	<span class="comment">//remove方法</span></span><br><span class="line">  	<span class="built_in">console</span>.log(list.remove(<span class="string">&#x27;aaa&#x27;</span>));</span><br><span class="line">  	<span class="built_in">console</span>.log(list);</span><br><span class="line">  	<span class="comment">//isEmpty方法</span></span><br><span class="line">  	<span class="built_in">console</span>.log(list.isEmpty());</span><br><span class="line">  	<span class="comment">//size方法</span></span><br><span class="line">  	<span class="built_in">console</span>.log(list.size());</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/23.png" alt="image-20200306001247346"></p>
<br>

<h4 id="9-完整实现"><a href="#9-完整实现" class="headerlink" title="9. 完整实现"></a>9. 完整实现</h4><h5 id="1-function类实现"><a href="#1-function类实现" class="headerlink" title="1) function类实现"></a>1) function类实现</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//内部类</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.data = data;</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//一.append方法</span></span><br><span class="line">  LinkedList.prototype.append = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.length == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">this</span>.head = newNode;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;              </span><br><span class="line">      <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">      <span class="keyword">while</span> (current.next)&#123;</span><br><span class="line">        current = current.next;</span><br><span class="line">      &#125;</span><br><span class="line">      current.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.length += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//二.toString方法</span></span><br><span class="line">  LinkedList.prototype.toString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">let</span> listString = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(current)&#123; </span><br><span class="line">      listString += current.data + <span class="string">&quot; &quot;</span>;</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listString;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//三.insert方法</span></span><br><span class="line">  LinkedList.prototype.insert = <span class="function">(<span class="params">position, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt; <span class="built_in">this</span>.length)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">    <span class="keyword">if</span>(position == <span class="number">0</span>)&#123;</span><br><span class="line">      newNode.next = <span class="built_in">this</span>.head;</span><br><span class="line">      <span class="built_in">this</span>.head = newNode</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> previous = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">      <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">        previous = current;</span><br><span class="line">        current = current.next;</span><br><span class="line">      &#125;</span><br><span class="line">      newNode.next = current;</span><br><span class="line">      previous.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.length += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//四.getData方法</span></span><br><span class="line">  LinkedList.prototype.getData = <span class="function">(<span class="params">position</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt;= <span class="built_in">this</span>.length)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//五.indexOf方法</span></span><br><span class="line">  LinkedList.prototype.indexOf = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(current)&#123;</span><br><span class="line">      <span class="keyword">if</span>(current.data == data)&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">      &#125;</span><br><span class="line">      current = current.next;</span><br><span class="line">      index += <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//六.update方法</span></span><br><span class="line">  LinkedList.prototype.update = <span class="function">(<span class="params">position, newData</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt;= <span class="built_in">this</span>.length)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    current.data = newData;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//七.removeAt方法</span></span><br><span class="line">  LinkedList.prototype.removeAt = <span class="function"><span class="params">position</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="built_in">this</span>.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">if</span> (position ==<span class="number">0</span> ) &#123;</span><br><span class="line">      <span class="built_in">this</span>.head = <span class="built_in">this</span>.head.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> previous = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">        previous = current;</span><br><span class="line">        current = current.next;</span><br><span class="line">      &#125;</span><br><span class="line">      previous.next = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.length -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> current.data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//八.remove方法</span></span><br><span class="line">  LinkedList.prototype.remove = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> position = <span class="built_in">this</span>.indexOf(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.removeAt(position);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//九.isEmpty方法</span></span><br><span class="line">  LinkedList.prototype.isEmpty = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.length == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//十.size方法</span></span><br><span class="line">  LinkedList.prototype.size = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-class类实现"><a href="#2-class类实现" class="headerlink" title="2) class类实现"></a>2) class类实现</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始链表长度为 0</span></span><br><span class="line">  length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始 head 为 null，head 指向链表的第一个节点</span></span><br><span class="line">  head = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内部类（链表里的节点 Node）</span></span><br><span class="line">  Node = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    data;</span><br><span class="line">    next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ------------ 链表的常见操作 ------------ //</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// append() 往链表尾部追加数据</span></span><br><span class="line">  <span class="function"><span class="title">append</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、创建新节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="built_in">this</span>.Node(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、追加新节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 链表长度为 0 时，即只有 head 的时候</span></span><br><span class="line">      <span class="built_in">this</span>.head = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 链表长度大于 0 时，在最后面添加新节点</span></span><br><span class="line">      <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当 currentNode.next 不为空时，</span></span><br><span class="line">      <span class="comment">// 循序依次找最后一个节点，即节点的 next 为 null 时</span></span><br><span class="line">      <span class="keyword">while</span> (currentNode.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 最后一个节点的 next 指向新节点</span></span><br><span class="line">      currentNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、追加完新节点后，链表长度 + 1</span></span><br><span class="line">    <span class="built_in">this</span>.length++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// insert() 在指定位置（position）插入节点</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">position, data</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// position 新插入节点的位置</span></span><br><span class="line">    <span class="comment">// position = 0 表示新插入后是第一个节点</span></span><br><span class="line">    <span class="comment">// position = 1 表示新插入后是第二个节点，以此类推</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、对 position 进行越界判断，不能小于 0 或大于链表长度</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="built_in">this</span>.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、创建新节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="built_in">this</span>.Node(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、插入节点</span></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// position = 0 的情况</span></span><br><span class="line">      <span class="comment">// 让新节点的 next 指向 原来的第一个节点，即 head</span></span><br><span class="line">      newNode.next = <span class="built_in">this</span>.head;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// head 赋值为 newNode</span></span><br><span class="line">      <span class="built_in">this</span>.head = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 0 &lt; position &lt;= length 的情况</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化一些变量</span></span><br><span class="line">      <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head; <span class="comment">// 当前节点初始化为 head</span></span><br><span class="line">      <span class="keyword">let</span> previousNode = <span class="literal">null</span>; <span class="comment">// head 的 上一节点为 null</span></span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">// head 的 index 为 0</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在 0 ~ position 之间遍历，不断地更新 currentNode 和 previousNode</span></span><br><span class="line">      <span class="comment">// 直到找到要插入的位置</span></span><br><span class="line">      <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在当前节点和当前节点的上一节点之间插入新节点，即它们的改变指向</span></span><br><span class="line">      newNode.next = currentNode;</span><br><span class="line">      previousNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新链表长度</span></span><br><span class="line">    <span class="built_in">this</span>.length++;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getData() 获取指定位置的 data</span></span><br><span class="line">  <span class="function"><span class="title">getData</span>(<span class="params">position</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、position 越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="built_in">this</span>.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、获取指定 position 节点的 data</span></span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、返回 data</span></span><br><span class="line">    <span class="keyword">return</span> currentNode.data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// indexOf() 返回指定 data 的 index，如果没有，返回 -1。</span></span><br><span class="line">  <span class="function"><span class="title">indexOf</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.data === data) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">      &#125;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// update() 修改指定位置节点的 data</span></span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params">position, data</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 涉及到 position 都要进行越界判断</span></span><br><span class="line">    <span class="comment">// 1、position 越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="built_in">this</span>.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、痛过循环遍历，找到指定 position 的节点</span></span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、修改节点 data</span></span><br><span class="line">    currentNode.data = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// removeAt() 删除指定位置的节点</span></span><br><span class="line">  <span class="function"><span class="title">removeAt</span>(<span class="params">position</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、position 越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="built_in">this</span>.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、删除指定 position 节点</span></span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// position = 0 的情况</span></span><br><span class="line">      <span class="built_in">this</span>.head = <span class="built_in">this</span>.head.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// position &gt; 0 的情况</span></span><br><span class="line">      <span class="comment">// 通过循环遍历，找到指定 position 的节点，赋值到 currentNode</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> previousNode = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 巧妙之处，让上一节点的 next 指向到当前的节点的 next，相当于删除了当前节点。</span></span><br><span class="line">      previousNode.next = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、更新链表长度 -1</span></span><br><span class="line">    <span class="built_in">this</span>.length--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove() 删除指定 data 的节点</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.removeAt(<span class="built_in">this</span>.indexOf(data));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isEmpty() 判断链表是否为空</span></span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.length === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// size() 获取链表的长度</span></span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// toString() 链表数据以字符串形式返回</span></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的节点，拼接为字符串，直到节点为 null</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">      result += currentNode.data + <span class="string">&quot; &quot;</span>;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><hr>

<h3 id="单向链表和双向链表"><a href="#单向链表和双向链表" class="headerlink" title="单向链表和双向链表"></a>单向链表和双向链表</h3><h4 id="单向链表-1"><a href="#单向链表-1" class="headerlink" title="单向链表"></a>单向链表</h4><ul>
<li>只能从头遍历到尾或者从尾遍历到头（一般从头到尾）。</li>
<li>链表相连的过程是单向的，实现原理是上一个节点中有指向下一个节点的引用。</li>
<li>单向链表有一个比较明显的缺点：可以轻松到达下一个节点，但回到前一个节点很难，在实际开发中, 经常会遇到需要回到上一个节点的情况。</li>
</ul>
<h4 id="双向链表-1"><a href="#双向链表-1" class="headerlink" title="双向链表"></a>双向链表</h4><ul>
<li>既可以从头遍历到尾，也可以从尾遍历到头。</li>
<li>链表相连的过程是双向的。实现原理是一个节点既有向前连接的引用，也有一个向后连接的引用。</li>
<li>双向链表可以有效的解决单向链表存在的问题。</li>
<li>双向链表缺点：<ul>
<li>每次在插入或删除某个节点时，都需要处理四个引用，而不是两个，实现起来会困难些。</li>
<li>相对于单向链表，所占内存空间更大一些。</li>
<li>但是，相对于双向链表的便利性而言，这些缺点微不足道。</li>
</ul>
</li>
</ul>
<h3 id="双向链表结构"><a href="#双向链表结构" class="headerlink" title="双向链表结构"></a>双向链表结构</h3><p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/1.png"></p>
<ul>
<li>双向链表不仅有 head 指针指向第一个节点，而且有 tail 指针指向最后一个节点。</li>
<li>每一个节点由三部分组成：item 储存数据、prev 指向前一个节点、next 指向后一个节点。</li>
<li>双向链表的第一个节点的 prev 指向 null。</li>
<li>双向链表的最后一个节点的 next 指向 null。</li>
</ul>
<h3 id="双向链表常见的操作"><a href="#双向链表常见的操作" class="headerlink" title="双向链表常见的操作"></a>双向链表常见的操作</h3><ul>
<li><code>append(element)</code> 向链表尾部追加一个新元素。</li>
<li><code>insert(position, element)</code> 向链表的指定位置插入一个新元素。</li>
<li><code>getElement(position)</code> 获取指定位置的元素。</li>
<li><code>indexOf(element)</code> 返回元素在链表中的索引。如果链表中没有该元素就返回 -1。</li>
<li><code>update(position, element)</code> 修改指定位置上的元素。</li>
<li><code>removeAt(position)</code> 从链表中的删除指定位置的元素。</li>
<li><code>remove(element)</code> 从链表删除指定的元素。</li>
<li><code>isEmpty()</code> 如果链表中不包含任何元素，返回 trun，如果链表长度大于 0 则返回 false。</li>
<li><code>size()</code> 返回链表包含的元素个数，与数组的 length 属性类似。</li>
<li><code>toString()</code> 由于链表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值。</li>
<li><code>forwardString()</code> 返回正向遍历节点字符串形式。</li>
<li><code>backwordString()</code> 返回反向遍历的节点的字符串形式。</li>
</ul>
<h3 id="封装双向链表类"><a href="#封装双向链表类" class="headerlink" title="封装双向链表类"></a>封装双向链表类</h3><blockquote>
<p>注：此处仅贴出使用function实现的代码，使用class实现代码参考完整实现</p>
</blockquote>
<h4 id="0-创建双向链表类"><a href="#0-创建双向链表类" class="headerlink" title="0. 创建双向链表类"></a>0. 创建双向链表类</h4><p>先创建双向链表类DoubleLinklist，并添加基本属性，再实现双向链表的常用方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装双向链表类</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">DoubleLinklist</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//封装内部类：节点类</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">this</span>.data = data;</span><br><span class="line">     <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">     <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//属性</span></span><br><span class="line">   <span class="built_in">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">   <span class="built_in">this</span>.tail ==<span class="literal">null</span>;</span><br><span class="line">   <span class="built_in">this</span>.length = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*使用class类实现*/</span></span><br><span class="line"><span class="comment">// 双向链表的节点类（继承单向链表的节点类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(element);</span><br><span class="line">    <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表类继承单向链表类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.tail = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h4 id="1-append-element-1"><a href="#1-append-element-1" class="headerlink" title="1. append(element)"></a>1. append(element)</h4><p><strong>过程详解：</strong></p>
<p>添加节点时分为多种情况：</p>
<ul>
<li>情况1：添加的是第一个节点：只需要让head和tail都指向新节点即可；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/2.png" alt="image-20200228094847845"></p>
<ul>
<li><p>情况2：添加的不是第一个节点，如下图所示：只需要改变相关引用的指向即可。</p>
<ul>
<li>通过：<code>newNode.prev = this.tail</code>，  建立指向1；</li>
<li>通过：<code>this.tail.next = newNode</code>， 建立指向2；</li>
<li>通过：<code>this.tail = newNode</code>， 建立指向3</li>
</ul>
<p>要注意改变变量指向的顺序，最后修改tail指向，这样未修改前tail始终指向原链表的最后一个节点。</p>
</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/3.png" alt="image-20200228095048677"></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/4.png" alt="image-20200228095135301"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//append方法</span></span><br><span class="line">DoubleLinklist.prototype.append = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//1.根据data创建新节点</span></span><br><span class="line">  <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.添加节点</span></span><br><span class="line">  <span class="comment">//情况1：添加的是第一个节点</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.tail = newNode;</span><br><span class="line">    <span class="built_in">this</span>.head = newNode ;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//情况2：添加的不是第一个节点</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    newNode.prev = <span class="built_in">this</span>.tail;</span><br><span class="line">    <span class="built_in">this</span>.tail.next = newNode;</span><br><span class="line">    <span class="built_in">this</span>.tail = newNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.length+1</span></span><br><span class="line">  <span class="built_in">this</span>.length += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建双向链表</span></span><br><span class="line"><span class="keyword">let</span> list = <span class="keyword">new</span> DoubleLinklist();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//2.测试append方法</span></span><br><span class="line"> list.append(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line"> list.append(<span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line"> list.append(<span class="string">&#x27;ccc&#x27;</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(list);</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<ul>
<li>next方向：</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/5.png"></p>
<ul>
<li>prev方向：</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/6.png"></p>
<br>

<h4 id="2-toString-1"><a href="#2-toString-1" class="headerlink" title="2. toString()"></a>2. toString()</h4><p><strong>过程详解：</strong></p>
<p>三种获取字符串的方法：<strong>toString（）</strong>、<strong>forwardString（）</strong>、<strong>backwardString（）</strong>实现原理相似，仅以backWardString方法为例：</p>
<ul>
<li>定义current变量记录当前指向的节点。首先让current指向第一个节点，然后通过 <code>current = current.next</code> 依次向后遍历。在while循环中以(current)作为条件遍历链表，只要 <code>current != null</code> 就一直遍历，由此可获取链表所有节点的数据。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/7.png"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将链表转变为字符串形式</span></span><br><span class="line"><span class="comment">//一.toString方法</span></span><br><span class="line">DoubleLinklist.prototype.toString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.backwardString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二.forwardString方法</span></span><br><span class="line">DoubleLinklist.prototype.forwardString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//1.定义变量</span></span><br><span class="line">  <span class="keyword">let</span> current =<span class="built_in">this</span>.tail;</span><br><span class="line">  <span class="keyword">let</span> resultString = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.依次向前遍历，获取每一个节点</span></span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    resultString += current.data + <span class="string">&quot;--&quot;</span>;</span><br><span class="line">    current = current.prev;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resultString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三.backwardString方法</span></span><br><span class="line">DoubleLinklist.prototype.backwardString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//1.定义变量</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">  <span class="keyword">let</span> resultString = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.依次向后遍历，获取每一个节点</span></span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    resultString += current.data + <span class="string">&quot;--&quot;</span>;</span><br><span class="line">    current = current.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resultString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建双向链表</span></span><br><span class="line"><span class="keyword">let</span> list = <span class="keyword">new</span> DoubleLinklist();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.测试字符串方法   </span></span><br><span class="line">list.append(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">list.append(<span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line">list.append(<span class="string">&#x27;ccc&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(list.toString());</span><br><span class="line"><span class="built_in">console</span>.log(list.forwardString());</span><br><span class="line"><span class="built_in">console</span>.log(list.backwardString());</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/8.png"></p>
<br>

<h4 id="3-insert-position-element-1"><a href="#3-insert-position-element-1" class="headerlink" title="3. insert(position,element)"></a>3. insert(position,element)</h4><p><strong>程详解：</strong></p>
<p>插入节点可分为多种情况：</p>
<p><strong>当原链表为空时</strong>：</p>
<ul>
<li>情况1：插入的新节点是链表的第一个节点；只需要让head和tail都指向newNode即可。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/9.png"></p>
<p><strong>当原链表不为空时</strong>：</p>
<ul>
<li>情况2：当position == 0，即在链表的首部添加节点：如下图所示：</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/10.png"></p>
<p>首先，通过：<code>this.head.prev = newNode</code>，改变指向1；</p>
<p>然后，通过：<code>newNode.next = this.head</code>，改变指向2；</p>
<p>最后，通过：<code>this.head = newNode</code>，改变指向3；</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/11.png"></p>
<ul>
<li>情况3：<code>position == this.length</code>，即在链表的尾部添加节点，如下图所示：</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/12.png"></p>
<p>首先，通过：<code>this.tail.next = newNode</code>，改变指向1；（注意这里使用this.tail指向原链表最后一个节点，而不是this.head。因为当length&gt;1时，this.head != this.tail。）</p>
<p>然后，通过：<code>newNode.prev = this.tail</code>，改变指向2；</p>
<p>最后，通过：<code>this.tail = newNode</code>，改变指向3；</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/13.png"></p>
<ul>
<li>情况4：0 &lt; position &lt; this.length，即在链表的中间插入新节点，假设在position = 1的位置插入，如下图所示：</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/14.png"></p>
<p>首先，需要定义变量current按照之前的思路，通过while循环找到position位置的后一个节点，循环结束后index = position</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/15.png"></p>
<p>如下图所示：当position = 1时，current就指向了Node2。这样操作current就等同于间接地操作Node2，还可以通过current.prev间接获取Node1。得到了newNode的前一个节点和后一个节点就可以通过改变它们的prev和next变量的指向来插入newNode了。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/16.png"></p>
<p>通过：<code>newNode.next = current</code>，改变指向1；</p>
<p>通过：<code>newNode.prev = current.prev</code>，改变指向2；</p>
<p>通过：<code>current.prev.next = newNode</code>，改变指向3；</p>
<blockquote>
<p>注意必须最后才修改current.prev的指向，不然就无法通过current.prev获取需要操作的Node1了。</p>
</blockquote>
<p>通过：<code>current.prev = current</code>，改变指向4；</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/17.png"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insert方法</span></span><br><span class="line">DoubleLinklist.prototype.insert = <span class="function">(<span class="params">position, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//1.越界判断</span></span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="built_in">this</span>.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.根据data创建新的节点</span></span><br><span class="line">  <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.插入新节点</span></span><br><span class="line">  <span class="comment">//原链表为空</span></span><br><span class="line">    <span class="comment">//情况1：插入的newNode是第一个节点</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.head = newNode;</span><br><span class="line">    <span class="built_in">this</span>.tail = newNode;</span><br><span class="line">  <span class="comment">//原链表不为空</span></span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//情况2：position == 0</span></span><br><span class="line">    <span class="keyword">if</span> (position == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.head.prev = newNode;</span><br><span class="line">      newNode.next = <span class="built_in">this</span>.head;</span><br><span class="line">      <span class="built_in">this</span>.head = newNode;</span><br><span class="line">    <span class="comment">//情况3：position == this.length </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(position == <span class="built_in">this</span>.length)&#123;</span><br><span class="line">      <span class="built_in">this</span>.tail.next = newNode;</span><br><span class="line">      newNode.prev = <span class="built_in">this</span>.tail;</span><br><span class="line">      <span class="built_in">this</span>.tail = newNode;</span><br><span class="line">      <span class="comment">//情况4：0 &lt; position &lt; this.length</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">        current = current.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//修改pos位置前后节点变量的指向</span></span><br><span class="line">      newNode.next = current;</span><br><span class="line">      newNode.prev = current.prev;</span><br><span class="line">      current.prev.next = newNode;</span><br><span class="line">      current.prev = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//4.length+1</span></span><br><span class="line">  <span class="built_in">this</span>.length += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span><span class="comment">//返回true表示插入成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//测试代码</span></span><br><span class="line">   <span class="comment">//1.创建双向链表</span></span><br><span class="line">   <span class="keyword">let</span> list = <span class="keyword">new</span> DoubleLinklist();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.测试insert方法</span></span><br><span class="line">   list.insert(<span class="number">0</span>, <span class="string">&#x27;插入链表的第一个元素&#x27;</span>);</span><br><span class="line">   list.insert(<span class="number">0</span>, <span class="string">&#x27;在链表首部插入元素&#x27;</span>);</span><br><span class="line">   list.insert(<span class="number">1</span>, <span class="string">&#x27;在链表中间插入元素&#x27;</span>);</span><br><span class="line">   list.insert(<span class="number">3</span>, <span class="string">&#x27;在链表尾部插入元素&#x27;</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(list);</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/19.png"></p>
<br>

<h4 id="4-get-position"><a href="#4-get-position" class="headerlink" title="4. get(position)"></a>4. get(position)</h4><p><strong>过程详解：</strong></p>
<p>定义两个变量current和index，按照之前的思路通过while循环遍历分别获取当前节点和对应的索引值index，直到找到需要获取的position位置后的一个节点，此时index = position =x，然后 <code>return current.data</code> 即可。</p>
<p>如果链表的节点数量很多时，这种查找方式效率不高，改进方法为：</p>
<blockquote>
<p>一定要通过this.length来获取链表的节点数否则就会报错。</p>
</blockquote>
<ul>
<li>当this.length / 2 &gt; position：从头（head）开始遍历；</li>
<li>当this.length / 2 &lt; position：从尾（tail）开始遍历；</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/20.png"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//get方法</span></span><br><span class="line">DoubleLinklist.prototype.get = <span class="function">(<span class="params">position</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//1.越界判断</span></span><br><span class="line">    <span class="comment">//获取元素时position不能等于length</span></span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="built_in">this</span>.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.获取元素</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//this.length / 2 &gt; position:从头开始遍历</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="built_in">this</span>.length / <span class="number">2</span>) &gt; position) &#123;</span><br><span class="line">    current = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">    current = current.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//this.length / 2 =&lt; position:从尾开始遍历</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    current = <span class="built_in">this</span>.tail;</span><br><span class="line">    index = <span class="built_in">this</span>.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(index-- &gt; position)&#123;</span><br><span class="line">    current = current.prev;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//测试代码</span></span><br><span class="line"> <span class="comment">//1.创建双向链表</span></span><br><span class="line"> <span class="keyword">let</span> list = <span class="keyword">new</span> DoubleLinklist();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//2.测试get方法</span></span><br><span class="line"> list.append(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"> list.append(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"> list.append(<span class="string">&#x27;b1&#x27;</span>);</span><br><span class="line"> list.append(<span class="string">&#x27;b2&#x27;</span>);</span><br><span class="line"> list.append(<span class="string">&#x27;b3&#x27;</span>);</span><br><span class="line"> list.append(<span class="string">&#x27;b4&#x27;</span>);</span><br><span class="line"> list.append(<span class="string">&#x27;b5&#x27;</span>);</span><br><span class="line"> list.append(<span class="string">&#x27;b6&#x27;</span>);</span><br><span class="line"> list.append(<span class="string">&#x27;b7&#x27;</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(list.get(<span class="number">0</span>));</span><br><span class="line"> <span class="built_in">console</span>.log(list.get(<span class="number">7</span>));</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/21.png"></p>
<br>

<h4 id="5-indexOf-element-1"><a href="#5-indexOf-element-1" class="headerlink" title="5. indexOf(element)"></a>5. indexOf(element)</h4><p><strong>过程详解：</strong></p>
<p>以（current）作为条件，通过while循环遍历链表中的所有节点（停止条件为current = null）。在遍历每个节点时将current指向的当前节点的data和传入的data进行比较即可。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//indexOf方法</span></span><br><span class="line">DoubleLinklist.prototype.indexOf = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//1.定义变量</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.遍历链表，查找与data相同的节点</span></span><br><span class="line">  <span class="keyword">while</span>(current)&#123;</span><br><span class="line">    <span class="keyword">if</span> (current.data == data) &#123;</span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    current = current.next;</span><br><span class="line">    index += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建双向链表</span></span><br><span class="line"><span class="keyword">let</span> list = <span class="keyword">new</span> DoubleLinklist();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.测试indexOf方法</span></span><br><span class="line">list.append(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">list.append(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">list.append(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(list.indexOf(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(list.indexOf(<span class="string">&#x27;c&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/23.png"></p>
<br>

<h4 id="6-update-position-element-1"><a href="#6-update-position-element-1" class="headerlink" title="6. update(position,element)"></a>6. update(position,element)</h4><p><strong>过程详解：</strong></p>
<p>以（index++ &lt; position）为条件，通过while循环遍历链表中的节点（停止条件为index = position）。循环结束后，current指向需要修改的节点。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//update方法</span></span><br><span class="line"> DoubleLinklist.prototype.update = <span class="function">(<span class="params">position, newData</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">//1.越界判断</span></span><br><span class="line">   <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="built_in">this</span>.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.寻找正确的节点</span></span><br><span class="line">   <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">   <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">//this.length / 2 &gt; position:从头开始遍历</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.length / <span class="number">2</span> &gt; position) &#123;</span><br><span class="line">     <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">     current = current.next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//this.length / 2 =&lt; position:从尾开始遍历</span></span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     current = <span class="built_in">this</span>.tail;</span><br><span class="line">     index = <span class="built_in">this</span>.length - <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span> (index -- &gt; position) &#123;</span><br><span class="line">       current = current.prev;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.修改找到节点的data</span></span><br><span class="line">   current.data = newData;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//表示成功修改</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建双向链表</span></span><br><span class="line"><span class="keyword">let</span> list = <span class="keyword">new</span> DoubleLinklist();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.测试update方法</span></span><br><span class="line">list.append(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">list.append(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(list.update(<span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(list);</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/25.png"></p>
<br>

<h4 id="7-removeAt-position-1"><a href="#7-removeAt-position-1" class="headerlink" title="7. removeAt(position)"></a>7. removeAt(position)</h4><p><strong>过程详解：</strong></p>
<p>删除节点时有多种情况：</p>
<p><strong>当链表的length = 1时</strong>：</p>
<ul>
<li>情况1：删除链表中的所有节点：只需要让链表的head和tail指向null即可。</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/26.png"></p>
<p><strong>当链表的length &gt; 1时</strong>：</p>
<ul>
<li><p>情况2：删除链表中的第一个节点：</p>
<p>通过：<code>this.head.next.prev = null</code>，改变指向1；</p>
<p>通过：<code>this.head = this.head.next</code>，改变指向2；</p>
<p>虽然Node1有引用指向其它节点，但是没有引用指向Node1，那么Node1会被自动回收。</p>
</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/27.png"></p>
<ul>
<li><p>情况3：删除链表中的最后一个节点：</p>
<p>通过：<code>this.tail.prev.next = null</code>，修改指向1；</p>
<p>通过：<code>this.tail = this.tail.prev</code>，修改指向2；</p>
</li>
</ul>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/28.png" alt="image-20200228161946691"></p>
<ul>
<li>情况4：删除链表中间的节点：</li>
</ul>
<p>通过while循环找到需要删除的节点，比如position = x，那么需要删除的节点就是Node(x+1)，如下图所示：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/29.png"></p>
<p>通过：<code>current.next.prev = current.prev</code>，修改指向1；</p>
<p>通过：<code>current.prev.next = current.next</code>，修改指向2；</p>
<p>这样就没有引用指向Node(x+1)了（current虽指向Node(x+1)，但current时临时变量，该方法执行完就会被销毁），随后Node(x+1)就会被自动删除。</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/30.png"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//removeAt方法</span></span><br><span class="line"> DoubleLinklist.prototype.removeAt = <span class="function"><span class="params">position</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">//1.越界判断</span></span><br><span class="line">   <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="built_in">this</span>.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2.删除节点</span></span><br><span class="line">   <span class="comment">//当链表中length == 1</span></span><br><span class="line">   <span class="comment">//情况1：链表只有一个节点</span></span><br><span class="line">   <span class="keyword">let</span> current = <span class="built_in">this</span>.head<span class="comment">//定义在最上面方便以下各种情况返回current.data</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.length == <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="built_in">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">     <span class="built_in">this</span>.tail = <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">//当链表中length &gt; 1</span></span><br><span class="line">   &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="comment">//情况2：删除第一个节点</span></span><br><span class="line">     <span class="keyword">if</span> (position == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">this</span>.head.next.prev = <span class="literal">null</span>;</span><br><span class="line">       <span class="built_in">this</span>.head = <span class="built_in">this</span>.head.next;</span><br><span class="line">     <span class="comment">//情况3：删除最后一个节点</span></span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(position == <span class="built_in">this</span>.length - <span class="number">1</span>)&#123;</span><br><span class="line">       current = <span class="built_in">this</span>.tail;<span class="comment">//该情况下返回被删除的最后一个节点</span></span><br><span class="line">       <span class="built_in">this</span>.tail.prev.next = <span class="literal">null</span>;</span><br><span class="line">       <span class="built_in">this</span>.tail = <span class="built_in">this</span>.tail.prev;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="comment">//情况4：删除链表中间的节点</span></span><br><span class="line">       <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">       <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">         current = current.next;</span><br><span class="line">       &#125;</span><br><span class="line">       current.next.prev = current.prev;</span><br><span class="line">       current.prev.next = current.next;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.length -= 1;</span></span><br><span class="line">   <span class="built_in">this</span>.length -= <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> current.data;  <span class="comment">//返回被删除节点的数据</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//测试代码</span></span><br><span class="line">   <span class="comment">//1.创建双向链表</span></span><br><span class="line">   <span class="keyword">let</span> list = <span class="keyword">new</span> DoubleLinklist();	</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.测试removeAt方法</span></span><br><span class="line">   list.append(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">   list.append(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">   list.append(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(list.removeAt(<span class="number">1</span>));</span><br><span class="line">   <span class="built_in">console</span>.log(list);</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/31.png"></p>
<br>

<h4 id="8-其他方法-1"><a href="#8-其他方法-1" class="headerlink" title="8. 其他方法"></a>8. 其他方法</h4><p>其他方法包括：<strong>remove(element)、isEmpty()、size()、getHead()、getTail()</strong></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*--------------------其他方法-------------------*/</span></span><br><span class="line"><span class="comment">//八.remove方法</span></span><br><span class="line">DoubleLinklist.prototype.remove = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//1.根据data获取下标值</span></span><br><span class="line">  <span class="keyword">let</span> index = <span class="built_in">this</span>.indexOf(data);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//2.根据index删除对应位置的节点</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.removeAt(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//九.isEmpty方法</span></span><br><span class="line">DoubleLinklist.prototype.isEmpty = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//十.size方法</span></span><br><span class="line">DoubleLinklist.prototype.size = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//十一.getHead方法：获取链表的第一个元素</span></span><br><span class="line">DoubleLinklist.prototype.getHead = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.head.data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//十二.getTail方法：获取链表的最后一个元素</span></span><br><span class="line">DoubleLinklist.prototype.getTail = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.tail.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//测试代码</span></span><br><span class="line">    <span class="comment">//1.创建双向链表</span></span><br><span class="line">    <span class="keyword">let</span> list = <span class="keyword">new</span> DoubleLinklist();	</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------其他方法的测试--------------*/</span></span><br><span class="line">    list.append(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    list.append(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    list.append(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    list.append(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">    <span class="comment">//remove方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(list.remove(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(list);</span><br><span class="line">    <span class="comment">//isEmpty方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(list.isEmpty());</span><br><span class="line">    <span class="comment">//size方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(list.size());</span><br><span class="line">    <span class="comment">//getHead方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(list.getHead());</span><br><span class="line">    <span class="comment">//getTead方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(list.getTail());</span><br></pre></td></tr></table></figure>
<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/32.png"></p>
<br>

<h4 id="9-完整实现-1"><a href="#9-完整实现-1" class="headerlink" title="9. 完整实现"></a>9. 完整实现</h4><h5 id="1-function类实现-1"><a href="#1-function类实现-1" class="headerlink" title="1) function类实现"></a>1) function类实现</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装双向链表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DoubleLinklist</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//封装内部类：节点类</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.data = data;</span><br><span class="line">    <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//属性</span></span><br><span class="line">  <span class="built_in">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.tail ==<span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//一.append方法</span></span><br><span class="line">  DoubleLinklist.prototype.append = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.tail = newNode;</span><br><span class="line">      <span class="built_in">this</span>.head = newNode ;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      newNode.prev = <span class="built_in">this</span>.tail;</span><br><span class="line">      <span class="built_in">this</span>.tail.next = newNode;</span><br><span class="line">      <span class="built_in">this</span>.tail = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.length += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//二.将链表转变为字符串形式</span></span><br><span class="line">  <span class="comment">//2.1.toString方法</span></span><br><span class="line">  DoubleLinklist.prototype.toString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.backwardString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.2.forwardString方法</span></span><br><span class="line">  DoubleLinklist.prototype.forwardString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current =<span class="built_in">this</span>.tail;</span><br><span class="line">    <span class="keyword">let</span> resultString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">      resultString += current.data + <span class="string">&quot;--&quot;</span>;</span><br><span class="line">      current = current.prev ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultString;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.3.backwardString方法</span></span><br><span class="line">  DoubleLinklist.prototype.backwardString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">let</span> resultString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">      resultString += current.data + <span class="string">&quot;--&quot;</span>;</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultString;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//三.insert方法</span></span><br><span class="line">  DoubleLinklist.prototype.insert = <span class="function">(<span class="params">position, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="built_in">this</span>.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.head = newNode;</span><br><span class="line">      <span class="built_in">this</span>.tail = newNode;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (position == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.head.prev = newNode;</span><br><span class="line">        newNode.next = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="built_in">this</span>.head = newNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(position == <span class="built_in">this</span>.length)&#123;</span><br><span class="line">        <span class="built_in">this</span>.tail.next = newNode;</span><br><span class="line">        newNode.prev = <span class="built_in">this</span>.tail;</span><br><span class="line">        <span class="built_in">this</span>.tail = newNode;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">          current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode.next = current;</span><br><span class="line">        newNode.prev = current.prev;</span><br><span class="line">        current.prev.next = newNode;</span><br><span class="line">        current.prev = newNode;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.length += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//四.get方法</span></span><br><span class="line">  DoubleLinklist.prototype.get = <span class="function"><span class="params">position</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="built_in">this</span>.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">this</span>.length / <span class="number">2</span>) &gt; position) &#123;</span><br><span class="line">      current = <span class="built_in">this</span>.head;</span><br><span class="line">      <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      current = <span class="built_in">this</span>.tail;</span><br><span class="line">      index = <span class="built_in">this</span>.length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span>(index-- &gt; position)&#123;</span><br><span class="line">      current = current.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//五.indexOf方法</span></span><br><span class="line">  DoubleLinklist.prototype.indexOf = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(current)&#123;</span><br><span class="line">      <span class="keyword">if</span> (current.data == data) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">      &#125;</span><br><span class="line">      current = current.next;</span><br><span class="line">      index += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">//六.update方法</span></span><br><span class="line">  DoubleLinklist.prototype.update = <span class="function">(<span class="params">position, newData</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="built_in">this</span>.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.length / <span class="number">2</span> &gt; position) &#123;</span><br><span class="line">      <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      current = <span class="built_in">this</span>.tail;</span><br><span class="line">      index = <span class="built_in">this</span>.length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (index -- &gt; position) &#123;</span><br><span class="line">        current = current.prev;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    current.data = newData;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//七.removeAt方法</span></span><br><span class="line">  DoubleLinklist.prototype.removeAt = <span class="function"><span class="params">position</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="built_in">this</span>.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.length == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">      <span class="built_in">this</span>.tail = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (position == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.head.next.prev = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="built_in">this</span>.head.next;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(position == <span class="built_in">this</span>.length - <span class="number">1</span>)&#123;</span><br><span class="line">        current = <span class="built_in">this</span>.tail;</span><br><span class="line">        <span class="built_in">this</span>.tail.prev.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="built_in">this</span>.tail.prev;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">          current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current.next.prev = current.prev;</span><br><span class="line">        current.prev.next = current.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.length -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> current.data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//八.remove方法</span></span><br><span class="line">  DoubleLinklist.prototype.remove = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="built_in">this</span>.indexOf(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.removeAt(index);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//九.isEmpty方法</span></span><br><span class="line">  DoubleLinklist.prototype.isEmpty = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.length == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//十.size方法</span></span><br><span class="line">  DoubleLinklist.prototype.size = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//十一.getHead方法：获取链表的第一个元素</span></span><br><span class="line">  DoubleLinklist.prototype.getHead = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.head.data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//十二.getTail方法：获取链表的最后一个元素</span></span><br><span class="line">  DoubleLinklist.prototype.getTail = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.tail.data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-class类实现-1"><a href="#2-class类实现-1" class="headerlink" title="2) class类实现"></a>2) class类实现</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.tail = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ------------ 链表的常见操作 ------------ //</span></span><br><span class="line">  <span class="comment">// append(element) 往双向链表尾部追加一个新的元素</span></span><br><span class="line">  <span class="comment">// 重写 append()</span></span><br><span class="line">  <span class="function"><span class="title">append</span>(<span class="params">element</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建双向链表节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> DoublyNode(element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、追加元素</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.head === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.head = newNode;</span><br><span class="line">      <span class="built_in">this</span>.tail = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ！！跟单向链表不同，不用通过循环找到最后一个节点</span></span><br><span class="line">      <span class="comment">// 巧妙之处</span></span><br><span class="line">      <span class="built_in">this</span>.tail.next = newNode;</span><br><span class="line">      newNode.prev = <span class="built_in">this</span>.tail;</span><br><span class="line">      <span class="built_in">this</span>.tail = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.length++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// insert(position, data) 插入元素</span></span><br><span class="line">  <span class="comment">// 重写 insert()</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">position, element</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、position 越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="built_in">this</span>.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、创建新的双向链表节点</span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> DoublyNode(element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、判断多种插入情况</span></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123; <span class="comment">// 在第 0 个位置插入</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.head === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.head = newNode;</span><br><span class="line">        <span class="built_in">this</span>.tail = newNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//== 巧妙之处：相处腾出 this.head 空间，留个 newNode 来赋值 ==//</span></span><br><span class="line">        newNode.next = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="built_in">this</span>.head.perv = newNode;</span><br><span class="line">        <span class="built_in">this</span>.head = newNode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === <span class="built_in">this</span>.length) &#123; <span class="comment">// 在最后一个位置插入</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.tail.next = newNode;</span><br><span class="line">      newNode.prev = <span class="built_in">this</span>.tail;</span><br><span class="line">      <span class="built_in">this</span>.tail = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 在 0 ~ this.length 位置中间插入</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> targetIndex = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">      <span class="keyword">let</span> previousNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 找到要插入位置的节点</span></span><br><span class="line">      <span class="keyword">while</span> (targetIndex++ &lt; position) &#123;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 交换节点信息</span></span><br><span class="line">      previousNode.next = newNode;</span><br><span class="line">      newNode.prev = previousNode;</span><br><span class="line"></span><br><span class="line">      newNode.next = currentNode;</span><br><span class="line">      currentNode.prev = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.length++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getData() 继承单向链表</span></span><br><span class="line">  <span class="function"><span class="title">getData</span>(<span class="params">position</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getData(position);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// indexOf() 继承单向链表</span></span><br><span class="line">  <span class="function"><span class="title">indexOf</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.indexOf(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// removeAt() 删除指定位置的节点</span></span><br><span class="line">  <span class="comment">// 重写 removeAt()</span></span><br><span class="line">  <span class="function"><span class="title">removeAt</span>(<span class="params">position</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、position 越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="built_in">this</span>.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、根据不同情况删除元素</span></span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123; <span class="comment">// 删除第一个节点的情况</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.length === <span class="number">1</span>) &#123; <span class="comment">// 链表内只有一个节点的情况</span></span><br><span class="line">        <span class="built_in">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 链表内有多个节点的情况</span></span><br><span class="line">        <span class="built_in">this</span>.head = <span class="built_in">this</span>.head.next;</span><br><span class="line">        <span class="built_in">this</span>.head.prev = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === <span class="built_in">this</span>.length - <span class="number">1</span>) &#123; <span class="comment">// 删除最后一个节点的情况</span></span><br><span class="line"></span><br><span class="line">      currentNode = <span class="built_in">this</span>.tail;</span><br><span class="line">      <span class="built_in">this</span>.tail.prev.next = <span class="literal">null</span>;</span><br><span class="line">      <span class="built_in">this</span>.tail = <span class="built_in">this</span>.tail.prev;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 删除 0 ~ this.length - 1 里面节点的情况</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> targetIndex = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> previousNode = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">while</span> (targetIndex++ &lt; position) &#123;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      previousNode.next = currentNode.next;</span><br><span class="line">      currentNode.next.perv = previousNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.length--;</span><br><span class="line">    <span class="keyword">return</span> currentNode.data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// update(position, data) 修改指定位置的节点</span></span><br><span class="line">  <span class="comment">// 重写 update()</span></span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params">position, data</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、删除 position 位置的节点</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">this</span>.removeAt(position);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、在 position 位置插入元素</span></span><br><span class="line">    <span class="built_in">this</span>.insert(position, data);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove(data) 删除指定 data 所在的节点（继承单向链表）</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.remove(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isEmpty() 判断链表是否为空</span></span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// size() 获取链表的长度</span></span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// forwardToString() 链表数据从前往后以字符串形式返回</span></span><br><span class="line">  <span class="function"><span class="title">forwardToString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的节点，拼接为字符串，直到节点为 null</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">      result += currentNode.data + <span class="string">&#x27;--&#x27;</span>;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// backwardString() 链表数据从后往前以字符串形式返回</span></span><br><span class="line">  <span class="function"><span class="title">backwardString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.tail;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的节点，拼接为字符串，直到节点为 null</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">      result += currentNode.data + <span class="string">&#x27;--&#x27;</span>;</span><br><span class="line">      currentNode = currentNode.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>学习笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>几首散诗</title>
    <url>/2020/12/30/%E6%95%A3%E8%AF%97/</url>
    <content><![CDATA[<blockquote>
<p>收集了几首曾经写过的诗歌，诗倒是写过不少，这几首算我比较满意和喜欢的吧。至于以后会不会写诗，只能说，无心插柳。</p>
</blockquote>
<h5 id="“诗歌还是少年的诗歌，只是不再炙热。而少年也终究不再是那个少年了。”"><a href="#“诗歌还是少年的诗歌，只是不再炙热。而少年也终究不再是那个少年了。”" class="headerlink" title="“诗歌还是少年的诗歌，只是不再炙热。而少年也终究不再是那个少年了。”"></a>“诗歌还是少年的诗歌，只是不再炙热。而少年也终究不再是那个少年了。”</h5><h5 id="“待你流离半世铅华洗净，望你嬉笑怒骂不恋市井”"><a href="#“待你流离半世铅华洗净，望你嬉笑怒骂不恋市井”" class="headerlink" title="“待你流离半世铅华洗净，望你嬉笑怒骂不恋市井”"></a>“待你流离半世铅华洗净，望你嬉笑怒骂不恋市井”</h5><img src="https://pic.downk.cc/item/5fec823e3ffa7d37b3de1094.jpg" style="zoom:80%;">

<br>

<a id="more"></a>

<h3 id="《不变的守侯》"><a href="#《不变的守侯》" class="headerlink" title="《不变的守侯》"></a>《不变的守侯》</h3><p>风将叶捻成无形的华</p>
<p>湖中半心石上的我</p>
<p>形单影只</p>
<p>如金钿坚定的心</p>
<p>独自守候</p>
<p>心海中</p>
<p>泛起期待的微波</p>
<br>

<p>我愿燃烧我的灵魂</p>
<p>照亮你的前路</p>
<p>我愿永远守候你</p>
<p>直至——</p>
<p>感动天使</p>
<p>用双翼抚慰我冰冷的身躯</p>
 <br>

<p>这不是生离死别的依恋</p>
<p>也不是惊天动地的爱歌</p>
<p>只是我不变的平凡守候</p>
<p>冀盼与你的相聚</p>
<p><strong>PS：这是我人生写的第一首完整的诗歌。记得不错的话那时候应该还是14岁，那是我第一次喜欢上了诗歌，找我当时的语文老师要了一个题目，她在一些诗歌平台发布过一些诗，拿过一些比赛的名次，也算小有名气吧。因为喜欢文学和诗歌的原因，和她关系也不错。后来写了不少诗，与仿冰心体的微诗加起来前后有小百首吧。初中那三年，是真的爱文学和诗歌。我的作家和诗人梦想也是那时坚定的。只是，时间真的能改变很多。</strong></p>
<br>

<h3 id="《夜雨下》"><a href="#《夜雨下》" class="headerlink" title="《夜雨下》"></a>《夜雨下》</h3><p>莫不是窗外红雾氤氲</p>
<p>  &nbsp;&nbsp;投映进了诗人无心的空白</p>
<p>落在窗棂上，落在灰暗的眼眸里</p>
<p>此刻的她更像个伤者</p>
<p>无光的瞳孔深处泛起浅红</p>
<p> &nbsp; &nbsp;泪滴滚落烫熨脸颊</p>
<p>心此刻同雨一般冰冷</p>
  <br>

<p>窗外则是一番喧嚣，路人</p>
<p>匆匆，伞翼推开了急雨的幕帘</p>
<p>此刻竟是寻不得一人止步</p>
<p> &nbsp; &nbsp;踏上征程的热情被浇熄</p>
<p>两旁不远处又是黑夜赋予的寂静：</p>
<p>稀朗或繁密的枯树丛木深邃如魅影</p>
<p>  &nbsp;&nbsp;无形中有着摄人心魄的力量</p>
  <br>

<p>流浪的诗人也好，归程的路人也罢</p>
<p> &nbsp; &nbsp;雨中疾步的征人：愿——</p>
<p>你脚下炙热，滚烫了冰意的黑</p>
<p><strong>PS：还记得这首诗歌是高二时候写的，发布在了我们学校的校刊上，名字还记得叫《樟苑》。</strong></p>
<p><strong>后来市里作家协会的几个人和媒体，还有一些外校的，来了我们学校，为了一个“诗歌进校园”的活动，找到了当时将诗歌发布在校刊上的三个人，其中一个就是我。那天当着一大堂的人，读了这首诗，和那几个人合了照，送了个本子给我当作纪念。明明那些人的职业和位置是我曾经的梦想，但是不知道为什么，得到他们的夸奖和他们近距离接触的时候，却没有想象中的那么喜悦。</strong></p>
<p><strong>或许诗歌还是少年的诗歌，只是不再炙热，而少年也终究不再是那个少年了。</strong></p>
 <br>

<h3 id="《雨祭》"><a href="#《雨祭》" class="headerlink" title="《雨祭》"></a>《雨祭》</h3><p>是否还有谁依然留恋</p>
<p>一场风将所有热度都带走</p>
<p>迎来的是雨憔悴的温柔</p>
  <br>

<p>琴弦上幻望如何收敛</p>
<p>静默抖出的音符微微颤抖</p>
<p>秋雨也不能将泪声重奏</p>
  <br>

<p>诗人拉下思想的帷帘</p>
<p>清樽在手且敬苦痛一杯酒</p>
<p>此刻便无人为风雨等候</p>
<p>​                   ——2017.9.29作</p>
 <br>

<h3 id="《打马过桥》"><a href="#《打马过桥》" class="headerlink" title="《打马过桥》"></a>《打马过桥》</h3><p>雨打湿手中纸页 </p>
<p>水溅墨莲滴滴 </p>
<p>我把雨写进诗里 </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;烟雨渗透苍白 </p>
 <br>

<p>我打马过桥来 </p>
 <br>

<p>眼前景是雾中景 </p>
<p>身后影是路人影 </p>
<p>脚下河，沉溺 </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;多少残破回忆 </p>
<p>多少人行远离 </p>
<p>独我仍留原地 </p>
<p>诗书页页翻篇 </p>
<p>聚散分合，形莽流沙 </p>
<p>谁还识得当初少年 </p>
 <br>

<p>随遇既安之 </p>
<p>我踩水过河去</p>
<p>​             ——2018.11.25随笔</p>
 <br>

<h3 id="《无题》"><a href="#《无题》" class="headerlink" title="《无题》"></a>《无题》</h3><p>我曾 </p>
<p>伫立于青峰之巅 </p>
<p>远眺群星孤月可望不即 </p>
<p>肉眼所触是熄灭万年的余辉 </p>
<p>也曾 </p>
<p>屈坐在石阶之上 </p>
<p>静看一花一叶落地成诗 </p>
<p>木笔刻记是转瞬即逝的残句 </p>
 <br>

<p>银河流转千百亿回 </p>
<p>昙花开落一夕之间 </p>
<p>时间的刻度谁都给不了标尺 </p>
<p>无力感在所难免 </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;但时光络绎不绝 </p>
 <br>

<p>我们凭依着星星的记忆存活 </p>
<p>而在没有星星的今夜 </p>
<p>我枕边即是星海浩瀚 </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;足以藏你入梦安眠 </p>
<p>​              ——19.2.4凌晨夜笔</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>诗歌</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>ajax学习笔记</title>
    <url>/2020/12/29/ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>原学习视频地址：<a href="https://www.bilibili.com/video/BV1NE411T7Z2?p=367">https://www.bilibili.com/video/BV1NE411T7Z2?p=367</a> ，p367-p371。</p>
</blockquote>
<h2 id="ajax的应用场景"><a href="#ajax的应用场景" class="headerlink" title="ajax的应用场景"></a>ajax的应用场景</h2><ol>
<li><p>页面上拉下载更多数据</p>
</li>
<li><p>列表数据无刷新分页</p>
</li>
<li><p>表单项离开焦点数据验证</p>
</li>
<li><p>搜索框提示文字下拉列表</p>
</li>
<li><p>……</p>
<a id="more"></a>

</li>
</ol>
<h2 id="ajax一些基本语法"><a href="#ajax一些基本语法" class="headerlink" title="ajax一些基本语法"></a>ajax一些基本语法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建ajax对象</span></span><br><span class="line"><span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest();  </span><br><span class="line">    <span class="comment">//IE8下使用 ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用open</span></span><br><span class="line"><span class="comment">  第一个参数：请求方式  get、post等</span></span><br><span class="line"><span class="comment">  第二个参数：url</span></span><br><span class="line"><span class="comment">  第三个参数：是否异步，true为异步</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>,<span class="string">&quot;1.txt&quot;</span>,<span class="string">&quot;true&quot;</span>)</span><br><span class="line"><span class="comment">//调用send</span></span><br><span class="line">xhr.send();</span><br><span class="line"><span class="comment">/*等待数据响应</span></span><br><span class="line"><span class="comment">  readystatechange  事件类型</span></span><br><span class="line"><span class="comment">  xhr.readyState  发生变化时候调用</span></span><br><span class="line"><span class="comment">  参数：0  (初始化)还没有调用open方法</span></span><br><span class="line"><span class="comment">       1  (载入)已调用send方法，正在发送请求</span></span><br><span class="line"><span class="comment">       2  (载入完成)send方法已完成，收到全部响应内容</span></span><br><span class="line"><span class="comment">       3  (解析)正在解析响应内容</span></span><br><span class="line"><span class="comment">       4  (完成)响应内容解析完成，可以在客户端调用了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState==<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="comment">//判断本次下载的状态是多少</span></span><br><span class="line">        <span class="keyword">if</span>(xhr.status==<span class="number">200</span>)&#123;</span><br><span class="line">            alert(<span class="string">&#x27;xhr.responseText&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            alert(<span class="string">&#x27;ERROR:&#x27;</span>+xhr.status)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try_catch"></a>try_catch</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    尝试执行的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">    <span class="comment">//error  错误对象，try中代码执行的异常信息</span></span><br><span class="line">    补救代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//try_throw_catch手动抛出异常</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    尝试执行的代码</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();  <span class="comment">//用户故意抛出的异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">    补救代码</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="GET和POST请求"><a href="#GET和POST请求" class="headerlink" title="GET和POST请求"></a>GET和POST请求</h2><p>HTML标签form的action和method属性</p>
<p>​    action    点击submit后要跳转到的链接 </p>
<p>​    method    表单要提交数据的方式，get、post等</p>
<h3 id="GET（默认）"><a href="#GET（默认）" class="headerlink" title="GET（默认）"></a>GET（默认）</h3><ul>
<li><p>提交方式：直接将数据拼接在url后进行提交，通过？进行拼接，查询字符串</p>
</li>
<li><p>好处：简单</p>
</li>
<li><p>缺点：</p>
<pre><code>   1. 不安全
      2. 最大2kb
      3. 无法实现上传</code></pre>
</li>
<li><p>ajax的post提交：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接以字符串拼接的方式写在后面</span></span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;1.get.php?username=yyy&amp;age=18&amp;password=123a&#x27;</span>,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3></li>
<li><p>提交方式：通过浏览器内部进行提交</p>
</li>
<li><p>好处：安全 、理论上无上限、可以上传</p>
</li>
<li><p>缺点：较复杂</p>
</li>
<li><p>form中需要添加enctype属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&#x27;post&#x27;</span> <span class="attr">enctype</span>=<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>ajax的get请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//send方法之前需要设置请求的格式</span></span><br><span class="line">xhr.sendRequestHeader(<span class="string">&#x27;content-type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要通过send方法进行提交查询字符串</span></span><br><span class="line"><span class="comment">//?name=value&amp;age=value2    search方式</span></span><br><span class="line"><span class="comment">//name=value&amp;age=value2  queryString方式</span></span><br><span class="line">xhr.open(<span class="string">&#x27;post&#x27;</span>,<span class="string">&#x27;1.post.php&#x27;</span>);</span><br><span class="line">xhr.send(<span class="string">&#x27;username=yyy&amp;age=18&amp;password=123a&#x27;</span>);       <span class="comment">//send中使用queryString方式</span></span><br></pre></td></tr></table></figure>
<h2 id="ajax函数封装"><a href="#ajax函数封装" class="headerlink" title="ajax函数封装"></a>ajax函数封装</h2></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用解构方式定义形参，method默认为get请求</span></span><br><span class="line"><span class="comment">//success  数据下载成功执行的函数</span></span><br><span class="line"><span class="comment">//error  数据下载失败执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$ajax</span>(<span class="params">&#123;method=<span class="string">&#x27;get&#x27;</span>,url,data，success,error&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        xhr=<span class="keyword">new</span> XMLHttpRequest(); </span><br><span class="line">    &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">        xhr=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断如果数据存在，转化为查询字符串</span></span><br><span class="line">    <span class="keyword">if</span>(data)&#123;</span><br><span class="line">        data=queryString(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当为get请求且有数据时使用get的方式拼接字符串</span></span><br><span class="line">    <span class="keyword">if</span>(method==<span class="string">&#x27;get&#x27;</span> &amp;&amp; data)&#123;</span><br><span class="line">        url+=<span class="string">&quot;?&quot;</span>+data;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.open(method,url,<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//传输数据时根据请求方式使用不同方式</span></span><br><span class="line">    <span class="keyword">if</span>(method==<span class="string">&#x27;get&#x27;</span>)&#123;</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        xhr.sendRequestHeader(<span class="string">&#x27;content-type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">        xhr.send(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等待数据响应</span></span><br><span class="line">    xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(xhr.readyState==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="comment">//判断本次下载的状态是多少</span></span><br><span class="line">            <span class="keyword">if</span>(xhr.status==<span class="number">200</span>)&#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    如何处理数据的方式不确定</span></span><br><span class="line"><span class="comment">                    使用回调函数</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="keyword">if</span>(success)</span><br><span class="line">                   success(xhr.responseText);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(error)</span><br><span class="line">                    error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将用户需传入的对象转化为查询字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryString</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        str+=attr+<span class="string">&quot;=&quot;</span>+obj[attr]+<span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    str.substring(<span class="number">0</span>,str.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用案例，使用对象和解构传参</span></span><br><span class="line">button.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $ajax(&#123;</span><br><span class="line">        method:<span class="string">&#x27;post&#x27;</span>,   <span class="comment">//若为get可不写</span></span><br><span class="line">        url:<span class="string">&#x27;1.post.php&#x27;</span>,</span><br><span class="line">        data:&#123;      <span class="comment">//可直接传入对象</span></span><br><span class="line">            username:<span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line">            age:<span class="number">18</span>;</span><br><span class="line">            passord:<span class="string">&#x27;123ab&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        success:<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">            alert(result);</span><br><span class="line">        &#125;,</span><br><span class="line">        error:<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">            alert(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="补充：JSON对象的两种方法"><a href="#补充：JSON对象的两种方法" class="headerlink" title="补充：JSON对象的两种方法"></a>补充：JSON对象的两种方法</h2><ul>
<li><p><code>JSON.stringfy()</code>    数据结构 =&gt; 字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>对象</span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">100</span>,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> str=<span class="built_in">JSON</span>.stringfy(arr);</span><br><span class="line">alert(str);    <span class="comment">//&#x27;[100,true,&#x27;hello&#x27;]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>数组</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    username:<span class="string">&#x27;nic&#x27;</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    password:<span class="string">&#x27;123ab&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> str=JSOn.stringfy(obj);</span><br><span class="line">alert(str);    <span class="comment">//&#x27;&#123;username:&#x27;nic&#x27;,age:18,password:&#x27;123ab&#x27;&#125;&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>JSON.parse()</code>   json格式字符串 =&gt; 数据结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&#x27;[100,true,&#x27;</span>hello<span class="string">&#x27;]&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> arrr=<span class="built_in">JSON</span>.parse(str);</span><br><span class="line">alert(arr);    <span class="comment">//[100,true,&#x27;hello&#x27;]</span></span><br></pre></td></tr></table></figure></li>
<li><p>php中：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">JSON.encode();    <span class="comment">//数据结构转化为字符串</span></span><br><span class="line">JSON.decode();    <span class="comment">//字符串转化为数据结构</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>学习笔记</category>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>关于更新到GitHub后博客内容未变问题</title>
    <url>/2020/12/29/%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>网站修改和更新文章后，在本地用 <code>hexo s</code> 部署到了GitHub后却发现自己的博客网站内容没有变化。找了一中午终于找到了原因所在。</p>
</blockquote>
<p>最开始更新完毕确认检查后，使用 <code>hexo d</code> 已经部署到了github，自己在github上也看到确实已经更新到了仓库，但是博客内容却一直没变。百度了下说是会有一段时间的延迟。但是等了一个晚上发现内容还是没有更新。于是又看了下GitHub的仓库，在右侧边栏发现了这个东西：</p>
<p><img src="https://pic.downk.cc/item/5feac4543ffa7d37b3180d86.png" alt="Environments/githubpages"></p>
<p>都知道github-pages是GitHub自带生成静态页面的功能，点进去后发现有一个更新日志，看了下最近的更新还是最开始部署到GitHub作测试的时候。于是知道博客内容没变是因为根本还没有更新。</p>
<p>然后查到了可能是分支问题，按照视频做的时候，根目录的<font color="red"> _config.yml </font>文件中deploy这一行是这样的：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:W-alker/W-alker.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>这样做，意思是将hexo部署到了master分支，导致我的仓库里多出了一个master分支。这才想起前段时间GitHub已经将仓库的默认主分支改为了main，所以我的仓库里有两个分支，一个main一个master，而main才是”active“分支，尽管我之前已经将默认分支改为了master分支，但是博客页面所在的分支还是main分支。两个分支的内容截然不同，修改之后的hexo文件更新在了master分支，而main分支保留的仍然是最开始未修改的文件。<em>也就是说，pages服务使用的是我的main分支生成的页面，而我需要生成页面的代码是在master分支里的。</em></p>
<p>于是一不做二不休，直接删除了这个仓库然后新建了同名的仓库，并且将配置文件里的branch改成了main，然后 <code>hexo clean</code> <code>hexo g</code> <code>hexo d</code> 重新部署，之后博客果然更新了。</p>
<p>后来觉得部署在GitHub上太慢，又百度着把博客部署在了gitee，但是又出现了很多问题，因为gitee的默认分支名还是maser，所以和pages服务冲突的问题又出现了好几次。最后干脆把GitHub的默认分支名改成了master，解决问题。</p>
<p><strong><em>总结：注意仓库分支。仓库最好是单分支，如果需要改到其他分支，记得将pages服务改到那个分支下。当然，你也可以直接将github的默认分支名重新改为maser，这样能避免你同时部署到其他代码托管平台如gitee和coding时候又出现问题。</em></strong></p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>gulp学习笔记</title>
    <url>/2020/12/29/gulp%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>学习gulp的简单笔记。原教学视频：<a href="https://www.bilibili.com/video/BV1NE411T7Z2?p=396">https://www.bilibili.com/video/BV1NE411T7Z2?p=396</a>。</p>
</blockquote>
<h2 id="gulp基本使用流程"><a href="#gulp基本使用流程" class="headerlink" title="gulp基本使用流程"></a>gulp基本使用流程</h2><ol>
<li>初始化项目目录：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm init      </span><br></pre></td></tr></table></figure>
<ol start="2">
<li>安装到项目文件夹：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp@3.9.1 --save-dev        &#x2F;&#x2F;下载gulp。--save-dev表示下载附带版本信息</span><br><span class="line">npm i gulp-scss gulp-minify-css gulp-rename -D    &#x2F;&#x2F;一次下载多个第三方插件。</span><br><span class="line">&#x2F;&#x2F;i是 install 的简写， -D是 --save-dev 的简写</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>创建一个gulpfile.js文件</p>
</li>
<li><p>在gulpfile.js文件中编写任务</p>
<p>(全局配置好命令行工具，之后会多出gulp命令行任务）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp-cli -g</span><br></pre></td></tr></table></figure></li>
<li><p>在控制台通过    gulp  任务名    ，运行编写好的任务</p>
<a id="more"></a>

</li>
</ol>
<h2 id="common-Js规范使用模块"><a href="#common-Js规范使用模块" class="headerlink" title="common.Js规范使用模块"></a>common.Js规范使用模块</h2><p>1.require()   将这个模块引入 </p>
<p>2.使用这个模块上的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);  <span class="comment">//引入一个gulp函数库</span></span><br><span class="line"><span class="comment">//编写第一个任务</span></span><br><span class="line"><span class="comment">//参数1：任务的名字，自定义    参数2：回调函数，任务执行的功能</span></span><br><span class="line">gulp.task(<span class="string">&#x27;hello&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="gulp基本函数"><a href="#gulp基本函数" class="headerlink" title="gulp基本函数"></a>gulp基本函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.src()    <span class="comment">//找到源文件路径</span></span><br><span class="line">gulp.dest()    <span class="comment">//找到目标文件路径，如果该文件路径不存在则会自动创建</span></span><br><span class="line">gulp.task()    <span class="comment">//建立gulp任务</span></span><br><span class="line">gulp.watch()    <span class="comment">//监控文件的变化</span></span><br><span class="line">.pipe()    <span class="comment">//理解程序运行管道</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">使用实例</span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);  <span class="comment">//引入一个gulp函数库</span></span><br><span class="line">gulp.task(<span class="string">&#x27;hello&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;       <span class="comment">//建立任务</span></span><br><span class="line">    gulp.src(<span class="string">&quot;./src/css/base.css&quot;</span>)    <span class="comment">//获取要处理的文件</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">&quot;./dist/css&quot;</span>));   <span class="comment">//放入指定文件夹</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="gulp使用监听"><a href="#gulp使用监听" class="headerlink" title="gulp使用监听"></a>gulp使用监听</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">&quot;watch&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  gulp.watch()  </span><br><span class="line"><span class="comment">//第一个参数：文件监听的路径；    第二个参数：要执行的任务</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="gulp使用插件"><a href="#gulp使用插件" class="headerlink" title="gulp使用插件"></a>gulp使用插件</h2><p>网址：<a href="https://gulpjs.com/plugins/">gulp插件</a></p>
<p><strong>使用步骤：</strong></p>
<p>&lt;1&gt; 下载插件到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install 插件名 --save-dev</span><br></pre></td></tr></table></figure>
<p>&lt;2&gt;通过require()  引入文件</p>
<p>&lt;3&gt;查阅插件用法并使用</p>
<p><strong>一些常用gulp插件：</strong></p>
<p>压缩html  ：<strong>gulp-htmlmin</strong></p>
<p>压缩css  ：<strong>gulp-csso</strong></p>
<p>重命名插件 ：<strong>gulp-rename</strong></p>
<p>处理js文件插件：</p>
<ul>
<li><strong>gulp-conact</strong>    合并文件</li>
<li><strong>gulp-uglify</strong>    压缩js 文件</li>
<li><strong>gulp-babel</strong>    ES6=&gt;ES5语法转换</li>
</ul>
<p>公共文件包含  ：<strong>gulp-file-include</strong></p>
<p>启动服务器  ：<strong>gulp-connect</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> connect=<span class="built_in">require</span>(<span class="string">&quot;gulp-connect&quot;</span>);</span><br><span class="line">gulp.task(<span class="string">&quot;server&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  connect.server(&#123;</span><br><span class="line">      root:<span class="string">&quot;dist&quot;</span>,  <span class="comment">//设置根目录</span></span><br><span class="line">      port:<span class="number">8000</span>,</span><br><span class="line">      <span class="comment">//livereload:true  //启动实时刷新</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="package-json文件"><a href="#package-json文件" class="headerlink" title="package.json文件"></a>package.json文件</h2><h3 id="项目依赖："><a href="#项目依赖：" class="headerlink" title="项目依赖："></a>项目依赖：</h3><p>在项目的开发阶段和线上运营阶段，都需要依赖的第三方包。</p>
<p>使用 <code>npm install 包名</code> 命令下载的文件会默认被添加到package.json文件的dependencies字段中。</p>
<p>重新安装时使用   <code>npm i --production </code>   可以只下载项目依赖。</p>
<h3 id="开发依赖："><a href="#开发依赖：" class="headerlink" title="开发依赖："></a>开发依赖：</h3><p>在项目的开发阶段需要依赖，线上运营阶段不需要的第三方包。</p>
<p>使用 <code>npm install 包名 --save-dev</code> 命令将包添加到package.json文件的devDependencies字段中。</p>
<p>使用    <code>npm install</code>   会重新下载所有依赖。</p>
<h3 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h3><p>用于记录模块与模块之间复杂的依赖关系。</p>
<ul>
<li><p>锁定包的版本，确保再次下载时不会因为包版本不同而产生问题。</p>
</li>
<li><p>加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可。</p>
</li>
</ul>
<h2 id="一份我的gulpfile-js文件示例"><a href="#一份我的gulpfile-js文件示例" class="headerlink" title="一份我的gulpfile.js文件示例"></a>一份我的gulpfile.js文件示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意node和gulp版本，版本冲突可能会发生错误</span></span><br><span class="line"><span class="keyword">const</span> gulp=<span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> htmlmin=<span class="built_in">require</span>(<span class="string">&#x27;gulp-htmlmin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fileinclude=<span class="built_in">require</span>(<span class="string">&#x27;gulp-file-include&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> rename=<span class="built_in">require</span>(<span class="string">&#x27;gulp-rename&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">&#x27;gulp-sass&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> csso = <span class="built_in">require</span>(<span class="string">&#x27;gulp-csso&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&#x27;gulp-babel&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">&#x27;gulp-uglify&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> imgmin=<span class="built_in">require</span>(<span class="string">&#x27;gulp-imagemin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> connect = <span class="built_in">require</span>(<span class="string">&#x27;gulp-connect&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//报错处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showError</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.toString());</span><br><span class="line">    <span class="built_in">this</span>.emit(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//html文件压缩</span></span><br><span class="line">gulp.task(<span class="string">&quot;htmlmin&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    gulp.src(<span class="string">&quot;src/*.html&quot;</span>)</span><br><span class="line">    .pipe(fileinclude())</span><br><span class="line">    .on(<span class="string">&#x27;error&#x27;</span>, showError)</span><br><span class="line">    .pipe(htmlmin(&#123; <span class="attr">collapseWhitespace</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">    .on(<span class="string">&#x27;error&#x27;</span>, showError)</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&quot;./dist&quot;</span>));</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//css代码压缩</span></span><br><span class="line">gulp.task(<span class="string">&quot;cssmin&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src([<span class="string">&quot;src/css/*.scss&quot;</span>,<span class="string">&quot;src/css/*.css&quot;</span>])</span><br><span class="line">    .pipe(sass())</span><br><span class="line">    .on(<span class="string">&#x27;error&#x27;</span>, showError)</span><br><span class="line">    .pipe(csso())</span><br><span class="line">    .on(<span class="string">&#x27;error&#x27;</span>, showError)</span><br><span class="line"><span class="comment">/*     .pipe(rename(&#123;</span></span><br><span class="line"><span class="comment">        suffix:&quot;.min&quot;</span></span><br><span class="line"><span class="comment">    &#125;)) */</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">&quot;./dist/css&quot;</span>));</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//js语法转换及代码压缩</span></span><br><span class="line">gulp.task(<span class="string">&#x27;jsmin&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>)  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./src/js/*.js&#x27;</span>)</span><br><span class="line">        .pipe(babel(&#123;</span><br><span class="line">            <span class="comment">//可以判断当前代码运行环境并将代码转化为当前运行环境支持的代码</span></span><br><span class="line">            presets: [<span class="string">&#x27;@babel/env&#x27;</span>]</span><br><span class="line">        &#125;))</span><br><span class="line">        .on(<span class="string">&#x27;error&#x27;</span>, showError)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .on(<span class="string">&#x27;error&#x27;</span>, showError)</span><br><span class="line"><span class="comment">/*         .pipe(rename(&#123;</span></span><br><span class="line"><span class="comment">            suffix:&quot;.min&quot;</span></span><br><span class="line"><span class="comment">        &#125;)) */</span></span><br><span class="line">        .pipe(gulp.dest(<span class="string">&#x27;./dist/js&#x27;</span>));</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">gulp.task(<span class="string">&#x27;jsmin-module&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>)  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./src/js/modules/*.js&#x27;</span>)</span><br><span class="line">        .pipe(babel(&#123;</span><br><span class="line">            presets: [<span class="string">&#x27;@babel/env&#x27;</span>]</span><br><span class="line">        &#125;))</span><br><span class="line">        .on(<span class="string">&#x27;error&#x27;</span>, showError)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .on(<span class="string">&#x27;error&#x27;</span>, showError)</span><br><span class="line"><span class="comment">/*         .pipe(rename(&#123;</span></span><br><span class="line"><span class="comment">            suffix:&quot;.min&quot;</span></span><br><span class="line"><span class="comment">        &#125;)) */</span></span><br><span class="line">        .pipe(gulp.dest(<span class="string">&#x27;./dist/js/modules&#x27;</span>));</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//图片拷贝处理</span></span><br><span class="line">gulp.task(<span class="string">&quot;images&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/img/*&#x27;</span>)</span><br><span class="line">        <span class="comment">//.pipe(imgmin())</span></span><br><span class="line">        .pipe(gulp.dest(<span class="string">&quot;./dist/img&quot;</span>));</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//服务器任务</span></span><br><span class="line">gulp.task(<span class="string">&quot;server&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>)  </span>&#123;</span><br><span class="line">    connect.server(&#123;</span><br><span class="line">        root: <span class="string">&quot;./dist/&quot;</span>,</span><br><span class="line">        port: <span class="number">5500</span>,</span><br><span class="line">        livereload: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//监听任务</span></span><br><span class="line">gulp.task(<span class="string">&quot;watch&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.watch(<span class="string">&quot;./src/*.html&quot;</span>, [<span class="string">&quot;htmlmin&quot;</span>]);</span><br><span class="line">    gulp.watch(<span class="string">&quot;./src/common/*.html&quot;</span>, [<span class="string">&quot;htmlmin&quot;</span>]);</span><br><span class="line">    gulp.watch(<span class="string">&quot;./src/css/*.css&quot;</span>,[<span class="string">&quot;cssmin&quot;</span>]);</span><br><span class="line">    gulp.watch(<span class="string">&quot;./src/css/*.scss&quot;</span>,[<span class="string">&quot;cssmin&quot;</span>]);</span><br><span class="line">    gulp.watch(<span class="string">&quot;./src/js/*.js&quot;</span>,[<span class="string">&quot;jsmin&quot;</span>]);</span><br><span class="line">    gulp.watch(<span class="string">&quot;./src/js/modules/*.js&quot;</span>,[<span class="string">&quot;jsmin-module&quot;</span>]);</span><br><span class="line">    gulp.watch(<span class="string">&quot;./src/img/*&quot;</span>, [<span class="string">&quot;images&quot;</span>]);</span><br><span class="line">&#125;)</span><br><span class="line">gulp.task(<span class="string">&quot;build&quot;</span>,[<span class="string">&#x27;htmlmin&#x27;</span>,<span class="string">&#x27;cssmin&#x27;</span>,<span class="string">&#x27;jsmin&#x27;</span>,<span class="string">&#x27;jsmin-module&#x27;</span>,<span class="string">&#x27;images&#x27;</span>,<span class="string">&#x27;server&#x27;</span>,<span class="string">&quot;watch&quot;</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>学习笔记</category>
        <category>gulp</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
</search>
